.//assistant/tools/news.ts
// assistant/tools/news.ts
import axios from 'axios';
import { debugLog } from '../errorLogger'; 
import { confirmExecution, displayCodeForEdit } from '../confirmation'; // Import confirmation functions

module.exports = {
  enabled: false,
  tools: {
    search_news_api: {
      schema:  {
        'name': 'search_news_api',
        'description': 'Performs a news search using the given query.',
        'input_schema': {
          'type': 'object',
          'properties': {
            'q': {
              'type': 'string',
              'description': 'The query to search for.',
              'required': true
            },
            'from': {
              'type': 'string',
              'description': 'The start date to search for.'
            },
            'to': {
              'type': 'string',
              'description': 'The end date to search for.'
            },
            'language': {
              'type': 'string',
              'description': 'The language to search for.'
            },
            'country': {
              'type': 'string',
              'description': 'The country to search for.'
            },
            'domains': {
              'type': 'string',
              'description': 'The domains to search for.'
            },
            'sources': {
              'type': 'string',
              'description': 'The sources to search for.'
            },
            'sortBy': {
              'type': 'string',
              'description': 'The sort order to search for.'
            },
            'num': {
              'type': 'number',
              'description': 'The number of results to return.'
            }
          }
        },
        'output_schema': {
          'type': 'array',
          'description': 'An array of news articles matching the search query.',
          'items': {
            'type': 'object',
            'properties': {
              'content': {
                'type': 'string',
                'description': 'The content of the news article, truncated to 100 characters.'
              },
              'title': {
                'type': 'string',
                'description': 'The title of the news article.'
              },
              'url': {
                'type': 'string',
                'description': 'The URL of the news article.'
              }
            }
          }
        }
      },
      action: async (values: any, api: any) => { // Add api parameter
        debugLog('search_news_api called with values:', values);

        // Display confirmation before execution
        const confirmed = await confirmExecution(api, `Execute news search with query: ${values.q}?`);
        if (!confirmed) {
          return "Execution cancelled.";
        }

        const trunc = (str: any, len: any) => {
          return str.length > len ? str.substring(0, len - 3) + '...' : str;
        }
        try {
          debugLog('Calling News API with query:', values.q);
          const response = await axios.get(`https://newsapi.org/v2/everything?q=${values.q}&apiKey=${process.env.NEWS_API_KEY}`);
          debugLog('News API response:', response.data);
          const results = response.data.articles.map((item: any) => ({
            content: trunc(item.content, 100),
            title: item.title,
            url: item.url,
          }));
          let num = values.num ? values.num : 10;
          const res = results.slice(0, num);
          debugLog('Returning search results:', res);
          return JSON.stringify(res);
        } catch (error: any) {
          debugLog('Error calling News API:', error);
          return `Error calling News API: ${error.message}`
        }
      }
    }
  }
}
export default module.exports;.//assistant/tools/puppeteer.ts


// assistant/tools/puppeteer.ts
const puppeteer = require('puppeteer');
import { debugLog } from '../errorLogger';

// Function to handle different form field types
const fillFormField = async (page, fieldSelector, value) => {
  const field = await page.$(fieldSelector);
  const fieldType = await field.evaluate(el => el.tagName.toLowerCase());

  switch (fieldType) {
    case 'input':
      const inputType = await field.evaluate(el => (el.type || 'text').toLowerCase());
      if (inputType === 'radio' || inputType === 'checkbox') {
        await field.evaluate((el, value) => { el.checked = value; }, value);
      } else {
        await field.type(value);
      }
      break;
    case 'select':
      await page.select(fieldSelector, value);
      break;
    default:
      console.warn(`Unsupported field type: ${fieldType}`);
  }
};

module.exports = {
  enabled: true,
  // Option to enable/disable headless mode
  headless: true,  
  tools: {
    take_screenshot: {
      schema: {
        "name": "take_screenshot",
        "description": "Capture a screenshot of a web page",
        "input_schema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the web page to capture"
            },
            "filePath": {
              "type": "string",
              "description": "File path to save the screenshot"
            }
          },
          "required": ["url", "filePath"]
        },
        "output_schema": {
          "type": "string",
          "description": "The output of the function, typically a success message."
        }
      },
      action: async ({ url, filePath }, api: any) => {
        debugLog(`take_screenshot called with url: ${url}, filePath: ${filePath}`);

        // Display confirmation before execution
        const confirmed = await confirmExecution(api, `Take screenshot of ${url} and save to ${filePath}?`);
        if (!confirmed) {
          return "Execution cancelled.";
        }

        try {
          debugLog('Launching Puppeteer browser...');
          const browser = await puppeteer.launch({ headless: module.exports.headless }); // Use headless option
          const page = await browser.newPage();
          await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'); // Set custom user agent
          debugLog(`Navigating to ${url}...`);
          await page.goto(url, { waitUntil: 'networkidle2' });
          debugLog(`Capturing screenshot to ${filePath}...`);
          await page.screenshot({ path: filePath });
          debugLog('Closing Puppeteer browser...');
          await browser.close();
          return `Screenshot saved to ${filePath}`;
        } catch (err) {
          debugLog("Error taking screenshot:", err); // Log the entire error object
          return JSON.stringify(err.message);
        }
      }
    },
    get_page_content:{
      "name": "get_page_content",
      "description": "Get the HTML content of a web page",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "URL of the web page"
          },
          "resultVar": {
            "type": "string",
            "description": "Optional. The variable name to store the result in."
          }
        },
        "required": ["url"]
      },
      "output_schema": {
        "type": "string",
        "description": "The HTML content of the web page."
      }
    },
    action: async ({ url }, api: any) => {
      debugLog(`get_page_content called with url: ${url}`);
      try {
        debugLog('Launching Puppeteer browser...');
        const browser = await puppeteer.launch({ headless: module.exports.headless }); // Use headless option
        const page = await browser.newPage();
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'); // Set custom user agent
        debugLog(`Navigating to ${url}...`);
        await page.goto(url, { waitUntil: 'networkidle2' });
        debugLog('Retrieving page content...');
        const content = await page.content();
        debugLog('Closing Puppeteer browser...');
        await browser.close();
        return content;
      } catch (err) {
        debugLog("Error getting page content:", err); // Log the entire error object
        return JSON.stringify(err.message);
      }
    }
  },
  submit_form: {
    schema: {
      "name": "submit_form",
      "description": "Submit a form on a web page",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "URL of the web page"
          },
          "formSelector": {
            "type": "string",
            "description": "Selector of the form to submit"
          },
          "formData": {
            "type": "object",
            "description": "Form data to submit"
          }
        },
        "required": ["url", "formSelector", "formData"]
      },
      "output_schema": {
        "type": "string",
        "description": "The output of the function, typically a success message or the response from the server."
      }
    },
    action: async ({ url, formSelector, formData }, api: any) => {
      debugLog(`submit_form called with url: ${url}, formSelector: ${formSelector}, formData: ${JSON.stringify(formData)}`);
      try {
        debugLog('Launching Puppeteer browser...');
        const browser = await puppeteer.launch({ headless: module.exports.headless }); // Use headless option
        const page = await browser.newPage();
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'); // Set custom user agent
        debugLog(`Navigating to ${url}...`);
        await page.goto(url, { waitUntil: 'networkidle2' });

        // Populate form fields
        debugLog('Populating form fields...');
        for (const [key, value] of Object.entries(formData)) {
          const fieldSelector = `${formSelector} [name="${key}"]`;
          debugLog(`Filling field ${key} with value ${value}...`);
          await fillFormField(page, fieldSelector, value); // Use the helper function
        }

        // Submit the form
        debugLog('Submitting form...');
        await page.$eval(formSelector, form => form.submit());

        debugLog('Closing Puppeteer browser...');
        await browser.close();
        return `Form submitted`;
      } catch (err) {
        debugLog("Error submitting form:", err); // Log the entire error object
        return JSON.stringify(err.message);
      }
    }
  },
}


export default module.exports;.//assistant/tools/jira.ts

// assistant/tools/jira.ts
import axios from 'axios';
import 'dotenv/config';
import { debugLog } from '../errorLogger';

async function callJIRA({ methodPath, data }: any, api: any) { // Add api parameter
  debugLog(`callJIRA called with methodPath: ${methodPath}, data: ${JSON.stringify(data)}`);

  // Display confirmation before execution
  const confirmed = await confirmExecution(api, `Call JIRA API with method path: ${methodPath}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  const url = `${config.domain}/rest/api/3/${methodPath}`;
  const auth = {
    username: config.username,
    password: config.token
  };
  try {
    debugLog(`Making JIRA API request to ${url}...`);
    const response = await axios({
      method: 'post',
      url,
      auth,
      data
    } as any);
    debugLog('JIRA API response:', response.data);
    return response.data;
  } catch (error: any) {
    debugLog('Error calling JIRA API:', error.response.data);
    return error.response.data;
  }
}

module.exports = {
  enabled: false,
  tools: {
    "call_jira": {
      schema: {
        "name": "call_jira",
        "description": "Call JIRA API",
        "input_schema": {
          "type": "object",
          "properties": {
            "methodPath": {
              "type": "string",
              "description": "The JIRA API method path"
            },
            "data": {
              "type": "object",
              "description": "The data to send to the JIRA API"
            }
          },
          "required": [
            "methodPath"
          ]
        },
        "output_schema": {
          "type": "object",
          "description": "The response from the JIRA API"
        }
      },
      action: callJIRA
    }
  },
  callJIRA
};

// JIRA API configuration obtained from environment variables for enhanced security
const config = {
  domain: process.env.JIRA_DOMAIN,
  username: process.env.JIRA_USERNAME,
  token: process.env.JIRA_API_KEY
};
.//assistant/tools/jscodeshift.ts

// assistant/tools/jscodeshift.ts
import jscodeshift from 'jscodeshift';
import fs from 'fs';
import vm from 'vm';
import { debugLog } from '../errorLogger';

module.exports = {
  enabled: true,
  tools: {
    transform_file: {
      schema: {
        "name": "transform_file",
        "description": "Apply a custom transformation to a JavaScript or TypeScript file",
        "input_schema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The path to the source code file to transform"
            },
            "transformationFilePath": {
              "type": "string",
              "description": "The path to the file containing the transformation code"
            }
          }
        },
        "output_schema": {
          "type": "string",
          "description": "The transformed file content"
        }
      },
      action: async ({ filePath, transformationFilePath }: any, api: any) => {
        try {
          debugLog(`transform_file called with filePath: ${filePath}, transformationFilePath: ${transformationFilePath}`);

          // Display code for editing and get confirmation
          const confirmed = await displayCodeForEdit(api, 
            `Transform file ${filePath} using code from ${transformationFilePath}?`, 
            transformationFilePath
          );
          if (!confirmed) {
            return "Execution cancelled.";
          }

          debugLog('Reading source code...');
          const sourceCode = fs.readFileSync(filePath, 'utf8');
          debugLog('Reading transformation code...');
          const transformationCode = fs.readFileSync(transformationFilePath, 'utf8');

          debugLog('Parsing source code with jscodeshift...');
          const j = jscodeshift.withParser('babel'); // or 'tsx' for TypeScript
          const root = j(sourceCode);

          // Create a secure context for the transformation
          debugLog('Creating secure context for transformation...');
          const context = vm.createContext({
            j, // Provide jscodeshift instance
            root, // Provide the AST root
            console, // Optionally expose console for debugging
          });

          // Execute the transformation code in the sandboxed context
          debugLog('Executing transformation code...');
          vm.runInContext(transformationCode, context);

          // Write back to the file
          debugLog('Writing transformed code back to file...');
          fs.writeFileSync(filePath, root.toSource());

          return `Transformation applied successfully.`;
        } catch (err: any) {
          debugLog('Error applying transformation:', err);
          return JSON.stringify(err.message);
        }
      }
    },
    // Additional tools for specific file-based transformations can be defined here.
  }
};

export default module.exports;.//assistant/tools/fixJson.ts


// assistant/tools/fixJson.ts
import { confirmExecution } from '../confirmation';
import { debugLog } from '../errorLogger';

export default {
  tools: {
    codemod: {
      // given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array
      // given some text content without any JSON within it, it will attempt to structure the text content into a JSON object
      schema: {
          
      },
      action: async (text: string, api: any) => {
        debugLog(`fixJson called with text: ${text}`);
         async function extractJSON(text: string): Promise<any> {
         const schema = await api.chat([{
            role: 'system',
            content: `Given some content that contains a JSON object or array, you ignore EVERYTHING BEFORE OR AFTER what is obviously JSON data, ignoring funky keys and weird data, and you output a syntactically-valid version of the JSON on a single line. If the content contains no JSON data, you output a JSON object containing the input data, structured in the most appropriate manner for the data.`,
         },{
            content: JSON.stringify(text),
          }], {}, 'gemini-1.5-flash-001');
          return schema;
        }
        return extractJSON(text);
      }
    }
  }
};.//assistant/tools/google.ts

// assistant/tools/google.ts
import 'dotenv/config';
import axios from 'axios';
import { debugLog } from '../errorLogger';

module.exports = {
  enabled: true,
  tools: {
    search_google: {
      schema: {
        "name": "search_google",
        "description": "perform a google search using the given query",
        "input_schema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to search for"
            }
          },
          "required": [
            "query"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The search results from Google."
        }
      },
      action: async ({ query }: any, api) => {
        debugLog(`search_google called with query: ${query}`);

        // Display confirmation before execution
        const confirmed = await confirmExecution(api, `Perform Google search with query: ${query}?`);
        if (!confirmed) {
          return "Execution cancelled.";
        }

        const config = {
          GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,
          GOOGLE_CX_ID: process.env.GOOGLE_CX_ID
        }
        try {
          debugLog('Calling Google Custom Search API...');
          const response = await axios.get(`https://www.googleapis.com/customsearch/v1?key=${config.GOOGLE_API_KEY}&cx=${config.GOOGLE_CX_ID}&q=${query}`);
          debugLog('Google Custom Search API response:', response.data);
          const results = response.data.items.map((item: any) => ({
            title: item.title,
            link: item.link
          }));
          const res = JSON.stringify(results);
          debugLog('Returning search results:', res);
          return res;
        } catch (error: any) {
          debugLog('Error calling Google Custom Search API:', error);
          return error.message;
        }
      }
    }
  }
}
export default module.exports;.//assistant/tools/execute.ts

// assistant/tools/execute.ts
const path = require('path');
const fs = require('fs').promises;
const { exec } = require('child_process');
import { debugLog } from '../errorLogger';

// Function to execute a command and handle output/errors consistently
const executeCommand = async (command) => {
  debugLog(`Executing command: ${command}`);
  return new Promise((resolve, reject) => {
    exec(command, (error, stdout, stderr) => {
      if (error) {
        debugLog(`Error executing command: ${error}`);
        reject(error); // Reject with the error object
      } else {
        debugLog(`Command output (stdout): ${stdout}`);
        debugLog(`Command output (stderr): ${stderr}`);
        // Resolve with an object containing stdout and stderr
        resolve({ stdout, stderr });
      }
    });
  });
};

// Function to create a temporary file, execute code, and clean up
const executeCodeInTempFile = async (language, code, extension) => {
  try {
    const fileName = path.join(__dirname, `${Date.now()}.${extension}`);
    const shebang = language === 'python' ? '#!/usr/bin/env python3\n' : ''; // Add shebang for Python
    debugLog(`Creating temporary file: ${fileName}`);
    await fs.writeFile(fileName, shebang + code);

    try {
      debugLog(`Executing code in temporary file: ${fileName}`);
      const { stdout, stderr }: any = await executeCommand(`${language} ${fileName}`);
      return { stdout, stderr };
    } finally {
      debugLog(`Deleting temporary file: ${fileName}`);
      await fs.unlink(fileName); // Ensure file deletion
    }
  } catch (err) {
    debugLog(`Error executing code in temporary file: ${err}`);
    throw err; // Re-throw errors for consistent handling
  }
};

export const execute_bash = async ({ command }, api) => {
  debugLog(`execute_bash called with command: ${command}`);
  // Display confirmation before execution
  const confirmed = await confirmExecution(api, `Execute Bash command: ${command}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }

  try {
    const { stdout, stderr }: any = await executeCommand(command);
    if (stderr) {
      // Log stderr for debugging but don't treat it as an error
      console.error('Bash command stderr:', stderr);
    }
    return stdout;
  } catch (error) {
    throw new Error(`Bash command execution failed: ${error.message}`);
  }
};

export const execute_nodejs_code = async ({ js }, api: any) => {
  debugLog(`execute_nodejs_code called with js: ${js}`);
  // Display confirmation before execution
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const { stdout, stderr } = await executeCodeInTempFile('node', js, 'js');
    if (stderr) {
      console.error('Node.js code stderr:', stderr);
    }
    return stdout;  
  } catch (error) {
    throw new Error(`Node.js code execution failed: ${error.message}`);
  }
};

export const execute_tsnodejs_code = async ({ js }, api: any) => {
  debugLog(`execute_tsnodejs_code called with js: ${js}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const { stdout, stderr } = await executeCodeInTempFile('ts-node', js, 'ts');
    if (stderr) {
      console.error('TypeScript code stderr:', stderr);
    }
    return stdout;  
  } catch (error) {
    throw new Error(`TypeScript code execution failed: ${error.message}`);
  }
};

export const execute_python_code = async ({ python }, api: any) => {
  debugLog(`execute_python_code called with python: ${python}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const { stdout, stderr } = await executeCodeInTempFile('python', python, 'py');
    if (stderr) {
      console.error('Python code stderr:', stderr);
    }
    return stdout;  
  } catch (error) {
    throw new Error(`Python code execution failed: ${error.message}`);
  }
};

export const execute_nodejs_file = async ({ file }, api: any) => {
  debugLog(`execute_nodejs_file called with file: ${file}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const filePath = path.isAbsolute(file) ? file : path.join(__dirname, file);
    const { stdout, stderr }: any = await executeCommand(`node ${filePath}`);
    if (stderr) {
      console.error('Node.js file stderr:', stderr);
    }
    return stdout;
  } catch (error) {
    throw new Error(`Node.js file execution failed: ${error.message}`);
  }
};

export const execute_tsnodejs_file = async ({ file }, api: any) => {
  debugLog(`execute_tsnodejs_file called with file: ${file}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const filePath = path.isAbsolute(file) ? file : path.join(__dirname, file);
    const { stdout, stderr }: any = await executeCommand(`ts-node ${filePath}`);
    if (stderr) {
    console.error('TypeScript file stderr:', stderr);
    }
    return stdout;
  } catch (error) {
    throw new Error(`TypeScript file execution failed: ${error.message}`);
  }
}

export const execute_python_file = async ({ file }, api: any) => {
  debugLog(`execute_python_file called with file: ${file}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const filePath = path.isAbsolute(file) ? file : path.join(__dirname, file);
    const { stdout, stderr }: any= await executeCommand(`python ${filePath}`);
    if (stderr) {
      console.error('Python file stderr:', stderr);
    }
    return stdout;
  } catch (error) {
    throw new Error(`Python file execution failed: ${error.message}`);
  }
};

module.exports = {
  enabled: true,
  tools: {
    execute_bash: {
      // Updated Schema
      "name": "execute_bash",
      "description": "Execute an arbitrary Bash command.",
      "input_schema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "description": "The Bash command to execute."
          }
        },
        "required": ["command"]
      },
      "output_schema": {
        "type": "string",
        "description": "The standard output of the executed Bash command."
      },
      action: execute_bash,
    },
    execute_file: {
      // Updated Schema
      "name": "execute_file",
      "description": "Execute a file containing TypeScript, JavaScript, or Python code.",
      "input_schema": {
        "type": "object",
        "properties": {
          "file": {
            "type": "string",
            "description": "The path to the source code file to execute."
          }
        },
        "required": ["file"]
      },
      "output_schema": {
        "type": "string",
        "description": "The standard output of the executed code."
      },
      action: async ({ file }: any, api: any) => {
        const ext = path.extname(file).toLowerCase(); // Use path.extname for reliability
        if (['.js', '.cjs', '.mjs'].includes(ext)) {
          return execute_nodejs_file({ file }, api);
        } else if (ext === '.ts') {
          return execute_tsnodejs_file({ file }, api);
        } else if (ext === '.py') {
          return execute_python_file({ file }, api);
        } else {
          throw new Error('Unsupported file type');  
        }
      },
    },
    execute_code: {
      // Updated Schema
      "name": "execute_code",
      "description": "Execute a code snippet in a specific language.",
      "input_schema": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "The code snippet to execute."
          },
          "language": {
            "type": "string",
            "description": "The language of the code snippet (bash, python, javascript, or typescript)."
          }
        },
        "required": ["code", "language"]
      },
      "output_schema": {
        "type": "string",
        "description": "The standard output of the executed code snippet."
      },
      action: async ({ code, language }: any, api: any) => {
        const lowerCaseLanguage = language.toLowerCase();  
        if (lowerCaseLanguage === 'bash') {
          return execute_bash({ command: code }, api);
        } else if (lowerCaseLanguage === 'python') {
          return execute_python_code({ python: code }, api);
        } else if (lowerCaseLanguage === 'javascript') {
          return execute_nodejs_code({ js: code }, api);
        } else if (lowerCaseLanguage === 'typescript') {
          return execute_tsnodejs_code({ js: code }, api);
        } else {
          throw new Error('Unsupported language');  
        }
      },
    }
  }
};

export default module.exports;
.//assistant/tools/manage_registry.ts
// assistant/tools/manage_registry.ts
// File: ./src/tools/registry_management.ts

import Assistant from '../assistant';
import { Tool } from '../tool_registry';
import { debugLog } from '../errorLogger';
import { confirmExecution } from '../confirmation';

interface RegistryManagementParams {
  action: 'list' | 'add' | 'update' | 'rollback' | 'history';
  name?: string;
  source?: string;
  tags?: string[];
  version?: string;
}

export const registryManagementTool: Tool = {
  name: 'registry_management',
  version: '1.0.0',
  description: 'Manage the tool registry',
  schema: {
    "description": "Manage the tool registry",
    "input_schema": {
      "type": "object",
      "properties": {
        "action": {
          "type": "string",
          "description": "The action to perform on the tool registry.",
          "enum": ["list", "add", "update", "rollback", "history"]
        },
        "name": {
          "type": "string",
          "description": "The name of the tool to manage."
        },
        "source": {
          "type": "string",
          "description": "The source code of the tool to add or update."
        },
        "tags": {
          "type": "array",
          "description": "The tags to add to the tool.",
          "items": {
            "type": "string"
          }
        },
        "version": {
          "type": "string",
          "description": "The version to rollback the tool to."
        }
      },
      "required": ["action"]
    },
    "output_schema": {
      "type": "any"
    }
  },
  execute: async (assistant: Assistant, params: RegistryManagementParams) => {
  debugLog(`registryManagementTool called with params: ${JSON.stringify(params)}`);
      // Display confirmation before adding the tool
    const confirmed = await confirmExecution(assistant, `Add tool '${name}' with the provided source and tags?`);
    if (!confirmed) {
      return false;
    }


    const { action, name, source, tags, version } = params;

    switch (action) {
      case 'list':
        return listTools(assistant);
      case 'add':
        return addTool(assistant, name!, source!, tags);
      case 'update':
        return updateTool(assistant, name!, source!);
      case 'rollback':
        return rollbackTool(assistant, name!, version!);
      case 'history':
        return getToolHistory(assistant, name!);
      default:
        throw new Error(`Invalid action: ${action}`);
    }
  },
};

async function listTools(assistant: Assistant): Promise<Tool[]> {
  debugLog('Listing all tools...');
  return assistant.toolRegistry.getToolList();
}

async function addTool(assistant: Assistant, name: string, source: string, schema: any, tags: string[] = []): Promise<boolean> {
  debugLog(`Adding tool: ${name} with source: ${source} and tags: ${tags}`);
  return assistant.toolRegistry.addTool(name, source, schema, tags);
}

async function updateTool(assistant: Assistant, name: string, source: string): Promise<boolean> {
  debugLog(`Updating tool: ${name} with source: ${source}`);
  return assistant.updateTool(name, source);
}

async function rollbackTool(assistant: Assistant, name: string, version: string): Promise<boolean> {
  debugLog(`Rolling back tool: ${name} to version: ${version}`);
  return assistant.rollbackTool(name, version);
}

async function getToolHistory(assistant: Assistant, name: string): Promise<string[]> {
  debugLog(`Getting history for tool: ${name}`);
  return assistant.toolRegistry.getToolHistory(name);
}
.//assistant/tools/evm.ts
// assistant/tools/evm.ts
const ethers = require('ethers');
import { debugLog } from '../errorLogger';

// Helper function to validate address
function validateAddress(address: string): boolean {
  debugLog(`Validating address: ${address}`);
  return ethers.utils.isAddress(address);
}

// Helper function to validate private key
function validatePrivateKey(privateKey: string): boolean {
  debugLog(`Validating private key: ${privateKey}`);
  return ethers.utils.isHexString(privateKey, 32);
}

// Helper function to validate ABI
function validateABI(abi: any): boolean {
  debugLog(`Validating ABI: ${JSON.stringify(abi)}`);
  return Array.isArray(abi);
}

// Helper function to validate transaction
function validateTransaction(transaction: any): boolean {
  debugLog(`Validating transaction: ${JSON.stringify(transaction)}`);
  return transaction.to && transaction.value && typeof transaction.to === 'string' && typeof transaction.value === 'string';
}

module.exports = {
  enabled: true,
  tools: {
    wallet_create: {
      schema: {
        "name": "wallet_create",
        "description": "Create a new Ethereum wallet.",
        "input_schema": {
          "type": "object",
          "properties": {
            "resultVar": {
              "type": "string",
              "description": "Optional. The variable to store the patched content in."
            }
          },
          "required": []
        },
        "output_schema": {
          "type": "string",
          "description": "The private key of the newly created wallet."
        }
      },
      action: async ({resultVar}: any, api: any) => {
        debugLog('wallet_create called');
        const wallet = ethers.Wallet.createRandom();
        debugLog(`Created new wallet with private key: ${wallet.privateKey}`);
        if (resultVar) {
          api.store[resultVar] = wallet.privateKey;
          debugLog(`Stored private key in variable: ${resultVar}`);
        }
        return wallet.privateKey;
      },
    },
    wallet_import: {
      schema: {
        "name": "wallet_import",
        "description": "Import an Ethereum wallet from a private key.",
        "input_schema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "The private key of the wallet."
            },
            "resultVar": {
              "type": "string",
              "description": "Optional. The variable to store the patched content in."
            }
          },
          "required": [
            "privateKey"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The private key of the imported wallet."
        }
      },
      action: async ({ privateKey, resultVar }:any, api: any) => {
        debugLog(`wallet_import called with privateKey: ${privateKey}`);
        if (!validatePrivateKey(privateKey)) {
          throw new Error('Invalid private key');
        }
        const wallet = new ethers.Wallet(privateKey);
        debugLog(`Imported wallet with private key: ${wallet.privateKey}`);
        if (resultVar) {
          api.store[resultVar] = wallet.privateKey;
          debugLog(`Stored private key in variable: ${resultVar}`);
        }
        return wallet.privateKey;
      },
    },
    wallet_balance: {
      schema: {
        "name": "wallet_balance",
        "description": "Get the balance of an Ethereum wallet.",
        "input_schema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The address of the wallet."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            },
            "resultVar": {
              "type": "string",
              "description": "Optional. The variable to store the patched content in."
            }
          },
          "required": [
            "address",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The balance of the wallet in ether."
        }
      },
      action: async ({ address, provider, resultVar }: any, api: any) => {
        debugLog(`wallet_balance called with address: ${address}, provider: ${provider}`);
        if (!validateAddress(address)) {
          throw new Error('Invalid Ethereum address');
        }
        debugLog(`Getting balance for address: ${address} from provider: ${provider}`);
        const balance = await new ethers.providers.JsonRpcProvider(provider).getBalance(address);
        debugLog(`Balance: ${balance}`);
        if (resultVar) {
          api.store[resultVar] = ethers.utils.formatEther(balance);
          debugLog(`Stored balance in variable: ${resultVar}`);
        }
        return ethers.utils.formatEther(balance);
      },
    },
    wallet_sendTransaction: {
      schema: {
        "name": "wallet_sendTransaction",
        "description": "Send a transaction from an Ethereum wallet.",
        "input_schema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "The private key of the wallet."
            },
            "transaction": {
              "type": "object",
              "properties": {
                "to": {
                  "type": "string",
                  "description": "The address of the recipient."
                },
                "value": {
                  "type": "string",
                  "description": "The amount to send in wei."
                },
                "gasLimit": {
                  "type": "string",
                  "description": "Optional. The gas limit for the transaction."
                },
                "nonce": {
                  "type": "number",
                  "description": "Optional. The nonce for the transaction."
                },
              },
              "required": [
                "to",
                "value"
              ]
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "privateKey",
            "transaction",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The transaction hash."
        }
      },
      action: async ({ privateKey, transaction, provider }: { privateKey: string, transaction: any, provider: string }) => {
        debugLog(`wallet_sendTransaction called with privateKey: ${privateKey}, transaction: ${JSON.stringify(transaction)}, provider: ${provider}`);
        if (!validatePrivateKey(privateKey)) {
          throw new Error('Invalid private key');
        }
        if (!validateTransaction(transaction)) {
          throw new Error('Invalid transaction object');
        }
        debugLog(`Sending transaction from wallet with private key: ${privateKey} to provider: ${provider}`);
        const wallet = new ethers.Wallet(privateKey, new ethers.providers.JsonRpcProvider(provider));
        const tx = await wallet.sendTransaction(transaction);
        debugLog(`Transaction hash: ${tx.hash}`);
        return tx.hash;
      },
    },
    wallet_estimateGas: {
      schema: {
        "name": "wallet_estimateGas",
        "description": "Estimate the gas cost of an Ethereum transaction.",
        "input_schema": {
          "type": "object",
          "properties": {
            "transaction": {
              "type": "object",
              "properties": {
                "to": {
                  "type": "string",
                  "description": "The address of the recipient."
                },
                "value": {
                  "type": "string",
                  "description": "The amount to send in wei."
                },
                "data": {
                  "type": "string",
                  "description": "Optional. The data for the transaction."
                },
              },
              "required": [
                "to",
                "value"
              ]
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "transaction",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The estimated gas cost."
        }
      },
      action: async ({ transaction, provider }: { transaction: any, provider: string }) => {
        debugLog(`wallet_estimateGas called with transaction: ${JSON.stringify(transaction)}, provider: ${provider}`);
        if (!validateTransaction(transaction)) {
          throw new Error('Invalid transaction object');
        }
        debugLog(`Estimating gas for transaction: ${JSON.stringify(transaction)} on provider: ${provider}`);
        const gasEstimate = await new ethers.providers.JsonRpcProvider(provider).estimateGas(transaction);
        debugLog(`Gas estimate: ${gasEstimate.toString()}`);
        return gasEstimate.toString();
      },
    },
    contract_deploy: {
      schema: {
        "name": "contract_deploy",
        "description": "Deploy an Ethereum smart contract.",
        "input_schema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "The private key of the wallet."
            },
            "abi": {
              "type": "string",
              "description": "The ABI of the contract, as a JSON string."
            },
            "bytecode": {
              "type": "string",
              "description": "The bytecode of the contract."
            },
            "args": {
              "type": "array",
              "description": "The arguments for the contract constructor."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "privateKey",
            "abi",
            "bytecode",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The address of the deployed contract."
        }
      },
      action: async ({ privateKey, abi, bytecode, args, provider }: { privateKey: string, abi: string, bytecode: string, args: any[], provider: string }) => {
        debugLog(`contract_deploy called with privateKey: ${privateKey}, abi: ${abi}, bytecode: ${bytecode}, args: ${JSON.stringify(args)}, provider: ${provider}`);
        if (!validatePrivateKey(privateKey)) {
          throw new Error('Invalid private key');
        }
        const parsedAbi = JSON.parse(abi);
        if (!validateABI(parsedAbi)) {
          throw new Error('Invalid ABI format');
        }
        debugLog(`Deploying contract with ABI: ${JSON.stringify(parsedAbi)} and bytecode: ${bytecode} to provider: ${provider}`);
        const wallet = new ethers.Wallet(privateKey, new ethers.providers.JsonRpcProvider(provider));
        const factory = new ethers.ContractFactory(parsedAbi, bytecode, wallet);
        const contract = await factory.deploy(...(args || []));
        await contract.deployed();
        debugLog(`Contract deployed at address: ${contract.address}`);
        return contract.address;
      },
    },
    contract_interact: {
      schema: {
        "name": "contract_interact",
        "description": "Interact with an Ethereum smart contract.",
        "input_schema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "The private key of the wallet."
            },
            "contractAddress": {
              "type": "string",
              "description": "The address of the contract."
            },
            "abi": {
              "type": "string",
              "description": "The ABI of the contract, as a JSON string."
            },
            "methodName": {
              "type": "string",
              "description": "The name of the method to call."
            },
            "args": {
              "type": "array",
              "description": "The arguments for the method."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "privateKey",
            "contractAddress",
            "abi",
            "methodName",
            "args",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The result of the method call."
        }
      },
      action: async ({ privateKey, contractAddress, abi, methodName, args, provider }: { privateKey: string, contractAddress: string, abi: string, methodName: string, args: any[], provider: string }) => {
        debugLog(`contract_interact called with privateKey: ${privateKey}, contractAddress: ${contractAddress}, abi: ${abi}, methodName: ${methodName}, args: ${JSON.stringify(args)}, provider: ${provider}`);
        if (!validatePrivateKey(privateKey)) {
          throw new Error('Invalid private key');
        }
        if (!validateAddress(contractAddress)) {
          throw new Error('Invalid Ethereum address');
        }
        const parsedAbi = JSON.parse(abi);
        if (!validateABI(parsedAbi)) {
          throw new Error('Invalid ABI format');
        }
        debugLog(`Interacting with contract at address: ${contractAddress} with method: ${methodName} and args: ${JSON.stringify(args)} on provider: ${provider}`);
        const wallet = new ethers.Wallet(privateKey, new ethers.providers.JsonRpcProvider(provider));
        const contract = new ethers.Contract(contractAddress, parsedAbi, wallet);
        const result = await contract[methodName](...(args || []));
        debugLog(`Method call result: ${result.toString()}`);
        return result.toString();
      },
    },
    contract_call: {
      schema: {
        "name": "contract_call",
        "description": "Call a method of an Ethereum smart contract.",
        "input_schema": {
          "type": "object",
          "properties": {
            "contractAddress": {
              "type": "string",
              "description": "The address of the contract."
            },
            "abi": {
              "type": "string",
              "description": "The ABI of the contract, as a JSON string."
            },
            "methodName": {
              "type": "string",
              "description": "The name of the method to call."
            },
            "args": {
              "type": "array",
              "description": "The arguments for the method."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "contractAddress",
            "abi",
            "methodName",
            "args",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The result of the method call."
        }
      },
      action: async ({ contractAddress, abi, methodName, args, provider }: { contractAddress: string, abi: string, methodName: string, args: any[], provider: string }) => {
        debugLog(`contract_call called with contractAddress: ${contractAddress}, abi: ${abi}, methodName: ${methodName}, args: ${JSON.stringify(args)}, provider: ${provider}`);
        if (!validateAddress(contractAddress)) {
          throw new Error('Invalid Ethereum address');
        }
        const parsedAbi = JSON.parse(abi);
        if (!validateABI(parsedAbi)) {
          throw new Error('Invalid ABI format');
        }
        debugLog(`Calling contract method: ${methodName} with args: ${JSON.stringify(args)} on provider: ${provider}`);
        const contract = new ethers.Contract(contractAddress, parsedAbi, new ethers.providers.JsonRpcProvider(provider));
        const result = await contract[methodName](...(args || []));
        debugLog(`Method call result: ${result.toString()}`);
        return result.toString();
      },
    },
    contract_events: {
      schema: {
        "name": "contract_events",
        "description": "Get events emitted by an Ethereum smart contract.",
        "input_schema": {
          "type": "object",
          "properties": {
            "contractAddress": {
              "type": "string",
              "description": "The address of the contract."
            },
            "abi": {
              "type": "string",
              "description": "The ABI of the contract, as a JSON string."
            },
            "eventName": {
              "type": "string",
              "description": "The name of the event to listen for."
            },
            "filters": {
              "type": "object",
              "description": "The filters to apply to the event."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "contractAddress",
            "abi",
            "eventName",
            "filters",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "A JSON stringified array of event data."
        }
      },
      action: async ({ contractAddress, abi, eventName, filters, provider }: { contractAddress: string, abi: string, eventName: string, filters: any, provider: string }) => {
        debugLog(`contract_events called with contractAddress: ${contractAddress}, abi: ${abi}, eventName: ${eventName}, filters: ${JSON.stringify(filters)}, provider: ${provider}`);
        if (!validateAddress(contractAddress)) {
          throw new Error('Invalid Ethereum address');
        }
        const parsedAbi = JSON.parse(abi);
        if (!validateABI(parsedAbi)) {
          throw new Error('Invalid ABI format');
        }
        debugLog(`Getting events for contract: ${contractAddress}, event: ${eventName}, filters: ${JSON.stringify(filters)} from provider: ${provider}`);
        const contract = new ethers.Contract(contractAddress, parsedAbi, new ethers.providers.JsonRpcProvider(provider));
        const events = await contract.queryFilter(contract.filters[eventName](), filters);
        debugLog(`Events: ${JSON.stringify(events)}`);
        return JSON.stringify(events.map((event: any) => event.args));
      },
    },
    utilities_formatEther: {
      schema: {
        "name": "utilities_formatEther",
        "description": "Convert a value from wei to ether.",
        "input_schema": {
          "type": "object",
          "properties": {
            "wei": {
              "type": "string",
              "description": "The value in wei."
            }
          },
          "required": [
            "wei"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The value in ether."
        }
      },
      action: async ({ wei }: { wei: string }) => {
        debugLog(`utilities_formatEther called with wei: ${wei}`);
        const etherValue = ethers.utils.formatEther(wei);
        debugLog(`Ether value: ${etherValue}`);
        return etherValue;
      },
    },
    utilities_parseEther: {
      schema: {
        "name": "utilities_parseEther",
        "description": "Convert a value from ether to wei.",
        "input_schema": {
          "type": "object",
          "properties": {
            "ether": {
              "type": "string",
              "description": "The value in ether."
            }
          },
          "required": [
            "ether"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The value in wei."
        }
      },
      action: async ({ ether }: { ether: string }) => {
        debugLog(`utilities_parseEther called with ether: ${ether}`);
        const weiValue = ethers.utils.parseEther(ether).toString();
        debugLog(`Wei value: ${weiValue}`);
        return weiValue;
      },
    },
    utilities_hash: {
      schema: {
        "name": "utilities_hash",
        "description": "Compute the hash of a value.",
        "input_schema": {
          "type": "object",
          "properties": {
            "input": {
              "type": "string",
              "description": "The input value."
            }
          },
          "required": [
            "input"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The hash of the input value."
        }
      },
      action: async ({ input }: { input: string }) => {
        debugLog(`utilities_hash called with input: ${input}`);
        const hash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(input));
        debugLog(`Hash: ${hash}`);
        return hash;
      },
    },
    utilities_computeAddress: {
      schema: {
        "name": "utilities_computeAddress",
        "description": "Compute the address of a public key.",
        "input_schema": {
          "type": "object",
          "properties": {
            "publicKey": {
              "type": "string",
              "description": "The public key."
            }
          },
          "required": [
            "publicKey"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The address corresponding to the public key."
        }
      },
      action: async ({ publicKey }: { publicKey: string }) => {
        debugLog(`utilities_computeAddress called with publicKey: ${publicKey}`);
        const address = ethers.utils.computeAddress(publicKey);
        debugLog(`Address: ${address}`);
        return address;
      },
    },
  },
};
.//assistant/tools/codemod.ts

// assistant/tools/codemod.ts
import * as ts from 'typescript';
import * as fs from 'fs';
import { parse, tsquery } from '@phenomnomnominal/tsquery';
import { debugLog } from '../errorLogger';

import {confirmExecution} from '../confirmation';

// Define custom error types for better error handling
class FileNotFoundError extends Error {
  constructor(filePath: string) {
    super(`File not found: ${filePath}`);
    this.name = 'FileNotFoundError';
  }
}

class InvalidSelectorError extends Error {
  constructor(selector: string) {
    super(`Invalid selector: ${selector}`);
    this.name = 'InvalidSelectorError';
  }
}

class CodeSnippetError extends Error {
  constructor(message: string) {
    super(`Code snippet error: ${message}`);
    this.name = 'CodeSnippetError';
  }
}

// Interface for codemod options
interface CodemodOptions {
  codeSnippet?: string;
  newName?: string;
}

// Interface for codemod function parameters
interface CodemodParams {
  filePath: string;
  operation: string;
  selector?: string; // Use 'selector' instead of 'selectors'
  resultVar?: string;
  options?: CodemodOptions;
}

// Type guard for TypeScript nodes
const isNode = (node: any): node is ts.Node => !!node && !!node.kind;

// Function to validate and parse a code snippet
function parseCodeSnippet(codeSnippet: string, expectedNodeType?: string): ts.Statement[] {
  debugLog(`parseCodeSnippet called with codeSnippet: ${codeSnippet}, expectedNodeType: ${expectedNodeType}`);
  // Use a more descriptive temporary file name
  const snippetSourceFile = ts.createSourceFile(
    'temporarySnippet.ts',
    codeSnippet,
    ts.ScriptTarget.Latest,
    true,
  );

  const diagnostics = snippetSourceFile.statements.flatMap((statement) => {
    if (expectedNodeType && !ts[`is${expectedNodeType}`](statement)) {
      return [
        new CodeSnippetError(
          `Expected a ${expectedNodeType} but found a ${ts.SyntaxKind[statement.kind]}.`,
        ),
      ];
    }
    return [];
  });

  if (diagnostics.length > 0) {
    debugLog(`Code snippet error: ${diagnostics[0].message}`);
    throw diagnostics[0];
  }

  debugLog(`Parsed code snippet: ${JSON.stringify(snippetSourceFile.statements)}`);
  return snippetSourceFile.statements as any
}

// Function to safely update a source file with modified statements
function safelyUpdateSourceFile(
  sourceFile: ts.SourceFile,
  modifiedStatements: ts.Statement[],
): ts.SourceFile {
  debugLog(`safelyUpdateSourceFile called with modifiedStatements: ${JSON.stringify(modifiedStatements)}`);
  if (!modifiedStatements.every(isNode)) {
    throw new Error('Modified statements array contains invalid or undefined nodes.');
  }
  // function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
  const updatedSourceFile = ts.factory.updateSourceFile(
    sourceFile,
    ts.factory.createNodeArray(modifiedStatements),
    sourceFile.isDeclarationFile
  );
  debugLog(`Updated source file: ${JSON.stringify(updatedSourceFile)}`);
  return updatedSourceFile;
}

// Function to append code to a source file
function appendCode(sourceFile: ts.SourceFile, codeSnippet: string): string {
  debugLog(`appendCode called with codeSnippet: ${codeSnippet}`);
  const newNodes = parseCodeSnippet(codeSnippet);
  const modifiedStatements = [...sourceFile.statements, ...newNodes];
  const updatedSourceFile = safelyUpdateSourceFile(sourceFile, modifiedStatements);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const result = printer.printFile(updatedSourceFile);
  debugLog(`Appended code to source file: ${result}`);
  return result;
}

// Function to remove a node from a source file based on a selector
function removeNode(sourceFile: ts.SourceFile, selector: string): string {
  debugLog(`removeNode called with selector: ${selector}`);
  const ast = parse(sourceFile.toString());
  const nodes = tsquery(ast as any, selector);

  if (nodes.length === 0) {
    throw new InvalidSelectorError(`No node found matching selector '${selector}' for removal.`);
  }

  const modifiedStatements = sourceFile.statements.filter(
    (statement) => !nodes.some((node) => node === statement),
  );

  const updatedSourceFile = safelyUpdateSourceFile(sourceFile, modifiedStatements);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const result = printer.printFile(updatedSourceFile);
  debugLog(`Removed node from source file: ${result}`);
  return result;
}

// Function to replace a node in a source file based on a selector
function replaceNode(sourceFile: ts.SourceFile, selector: string, codeSnippet: string): string {
  debugLog(`replaceNode called with selector: ${selector}, codeSnippet: ${codeSnippet}`);
  const parsedNodes = parseCodeSnippet(codeSnippet);
  if (parsedNodes.length !== 1) {
    throw new CodeSnippetError(
      'The code snippet must contain exactly one top-level statement for replacement.',
    );
  }

  const ast = parse(sourceFile.toString());
  const nodes = tsquery(ast as any, selector);

  if (nodes.length === 0) {
    throw new InvalidSelectorError(`No node found matching selector '${selector}' for replacement.`);
  }

  const replacementNode = parsedNodes[0];
  const modifiedStatements = sourceFile.statements.map((statement) =>
    nodes.some((node) => node === statement) ? replacementNode : statement,
  );

  const updatedSourceFile = safelyUpdateSourceFile(sourceFile, modifiedStatements);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const result = printer.printFile(updatedSourceFile);
  debugLog(`Replaced node in source file: ${result}`);
  return result;
}

// Function to find nodes in a source file based on a selector
function findNodesBySelector(sourceFile: ts.SourceFile, selector: string): ts.Node[] {
  debugLog(`findNodesBySelector called with selector: ${selector}`);
  const ast = parse(sourceFile.toString());
  const nodes = tsquery(ast as any, selector);
  debugLog(`Found nodes: ${JSON.stringify(nodes)}`);
  return nodes;
}

// Function to set information about a node based on a selector
function setNodeInfo(sourceFile: ts.SourceFile, selector: string, newName: string): string {
  debugLog(`setNodeInfo called with selector: ${selector}, newName: ${newName}`);
  const nodes = findNodesBySelector(sourceFile, selector);

  if (nodes.length === 0) {
    throw new InvalidSelectorError(`No nodes found for selector '${selector}'`);
  }
  if (nodes.length > 1) {
    throw new InvalidSelectorError(`Multiple nodes found for selector '${selector}'`);
  }

  const node = nodes[0];
  const modifiedStatements = sourceFile.statements.map((statement) => {
    if (statement === node) {
      // Use ts.factory to create a new node with the updated name
      if (ts.isFunctionDeclaration(node)) {
        return ts.factory.updateFunctionDeclaration(
          node,
          node.modifiers,
          node.asteriskToken,
          ts.factory.createIdentifier(newName),
          node.typeParameters,
          node.parameters,
          node.type,
          node.body,
        );
      } else if (ts.isClassDeclaration(node)) {
        return ts.factory.updateClassDeclaration(
          node,
          node.modifiers,
          ts.factory.createIdentifier(newName),
          node.typeParameters,
          node.heritageClauses,
          node.members,
        );
      } else if (ts.isVariableDeclaration(node)) {
        return ts.factory.updateVariableDeclaration(
          node,
          ts.factory.createIdentifier(newName),
          node.exclamationToken,
          node.type,
          node.initializer,
        );
      } else {
        throw new InvalidSelectorError(`Unsupported node type for selector '${selector}'`);
      }
    }
    return statement;
  });

  const updatedSourceFile = safelyUpdateSourceFile(sourceFile, modifiedStatements as any);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const result = printer.printFile(updatedSourceFile);
  debugLog(`Set node info in source file: ${result}`);
  return result;
}

// Main codemod function
const codemod = async function ({
  filePath,
  operation,
  selector,
  resultVar,
  options = {},
}: CodemodParams,
api: any): Promise<string> {
  debugLog(`codemod called with filePath: ${filePath}, operation: ${operation}, selector: ${selector}, resultVar: ${resultVar}, options: ${JSON.stringify(options)}`);
  return new Promise((resolve) => {
    try {
      if (!fs.existsSync(filePath)) {
        throw new FileNotFoundError(filePath);
      }

      debugLog(`Reading file content from: ${filePath}`);
      const fileContent = fs.readFileSync(filePath, { encoding: 'utf8' });
      const sourceFile = ts.createSourceFile(filePath, fileContent, ts.ScriptTarget.Latest, true);

      let result: string;

      // Display confirmation message based on the operation
      let confirmationMessage = "";
      switch (operation) {
        case 'append':
          confirmationMessage = `Append code to ${filePath}?`;
          break;
        case 'remove':
          confirmationMessage = `Remove code matching selector '${selector}' from ${filePath}?`;
          break;
        case 'replace':
          confirmationMessage = `Replace code matching selector '${selector}' in ${filePath} with the provided snippet?`;
          break;
        case 'get_info':
          confirmationMessage = `Get information about nodes matching selector '${selector}' in ${filePath}?`;
          break;
        case 'set_info':
          confirmationMessage = `Set information for nodes matching selector '${selector}' in ${filePath}?`;
          break;
        default:
          throw new Error(`Operation '${operation}' is not supported.`);
      }
      // Display confirmation before execution
      const confirmed = await confirmExecution(api, confirmationMessage);
      if (!confirmed) {
        return "Execution cancelled.";
      }
      if (resultVar) {
        api.store[resultVar] = fileContent;
        debugLog(`Stored result in variable: ${resultVar}`);
      }
      debugLog(`Writing result to file: ${filePath}`);
      fs.writeFileSync(filePath, fileContent, { encoding: 'utf8' });
      resolve(`Operation '${operation}' completed successfully on ${filePath}.`);
    } catch (error: any) {
      debugLog(`Error performing codemod operation: ${error.message}`);
      resolve(`Error performing operation '${operation}' on ${filePath}: ${error.message}`);
    }
  });
};

// Export the codemod function and its schema
export default {
  tools: {
    codemod: {
      schema: {
        "name": "codemod",
        "description": "Automates TypeScript/JavaScript code edits via AST.\nOperations: append, remove, replace, get_info, set_info.\nUsage: codemod <file> <operation> [selector] [--options]\nSelectors: Target functions, classes, variables using tsquery syntax (https://tsquery.github.io/).\nOptions: Code snippets, new names. \nFeatures: CLI-based, supports file and snippet manipulation, customizable through selectors and options, designed for efficient source code management.\nExecution: Node.js environment, leverages TypeScript Compiler API and tsquery.",
        "input_schema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The path to the TypeScript or JavaScript file to modify"
            },
            "operation": {
              "type": "string",
              "description": "The operation to perform (e.g., 'append', 'remove', 'replace', 'get_info', 'set_info')"
            },
            "selector": {
              "type": "string",
              "description": "Selector for identifying code parts using tsquery syntax (https://tsquery.github.io/)"
            },
            "resultVar": {
              "type": "string",
              "description": "Optional. The variable to store the patched content in."
            },
            "options": {
              "type": "object",
              "properties": {
                "codeSnippet": {
                  "type": "string",
                  "description": "Code snippet for append/replace operations"
                },
                "newName": {
                  "type": "string",
                  "description": "New name for the set_info operation"
                }
              },
              "description": "Additional options specific to the operation"
            }
          },
          "required": [
            "filePath",
            "operation"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The output of the codemod operation."  
        }
      },
      action: codemod,
    },
  },
};.//assistant/types/index.d.ts
import { EventEmitter } from "eventemitter3";

export interface ToolMetrics {
  versions: string[];
  totalUpdates: number;
  lastUpdated: string;
  testResults: {
    totalRuns: number;
    passed: number;
    failed: number;
    lastRun: string | null;
  };
  executionStats: {
    totalExecutions: number;
    averageExecutionTime: number;
    lastExecutionTime: number | null;
    fastestExecutionTime: number;
    slowestExecutionTime: number;
  };
  errorRate: number;
  usageCount: number;
}

export interface Assistant extends EventEmitter {
  apiKey: string;
  vscode: any;
  tools: { [key: string]: Tool }; // Use Tool interface
  store: any;
  callAgent(input: string, onUpdate: (update: any) => void): Promise<any>;
  extractJson(content: string): any[];
  getSchemas(): {
    name: string;
    schema: any;
  }[];
  callTool: (toolName: string, params: any) => Promise<any>;
}

// Define the structure of the tool repository
export interface ToolRepo {
  [toolName: string]: {
    versions: {
      [version: string]: string; // source code for the version
    };
  };
}

export interface RegistryData {
  tools: Tool[];
}.//assistant/memory/pruner.ts
import { MemoryStore, Memory } from './store';

export class MemoryPruner {
  async pruneMemories(memoryStore: MemoryStore): Promise<void> {
    const memories = await memoryStore.listMemories();
    const memoriesToPrune = this.identifyMemoriesToPrune(memories);
    await this.removeMemories(memoryStore, memoriesToPrune);
  }

  private identifyMemoriesToPrune(memories: Memory[]): string[] {
    const LOW_CONFIDENCE_THRESHOLD = 0.3;
    const MAX_MEMORIES = 1000; // Arbitrary limit

    let memoriesToPrune: string[] = [];

    // Prune low confidence memories
    memoriesToPrune = memoriesToPrune.concat(
      memories
        .filter(memory => memory.confidence < LOW_CONFIDENCE_THRESHOLD)
        .map(memory => memory.input)
    );

    // If we're still over the limit, remove oldest memories
    if (memories.length - memoriesToPrune.length > MAX_MEMORIES) {
      const sortedMemories = memories.sort((a, b) => b.confidence - a.confidence);
      memoriesToPrune = memoriesToPrune.concat(
        sortedMemories
          .slice(MAX_MEMORIES)
          .map(memory => memory.input)
      );
    }

    return memoriesToPrune;
  }

  private async removeMemories(memoryStore: MemoryStore, memoryInputs: string[]): Promise<void> {
    for (const input of memoryInputs) {
      // Assuming MemoryStore has a removeMemory method
      await memoryStore.removeMemory(input);
    }
  }
}.//assistant/memory/confidence.ts
export class ConfidenceCalculator {
  calculateInitialConfidence(chromaConfidence: number, response: string): number {
    const lengthScore = this.calculateLengthScore(response);
    const complexityScore = this.calculateComplexityScore(response);

    // Weighted average of factors
    const confidence = (
      chromaConfidence * 0.6 +
      lengthScore * 0.2 +
      complexityScore * 0.2
    );

    return Math.min(Math.max(confidence, 0), 1); // Ensure confidence is between 0 and 1
  }

  calculateRetrievalConfidence(storedConfidence: number, chromaConfidence: number): number {
    // Combine stored confidence with Chroma's similarity score
    const combinedConfidence = (storedConfidence + chromaConfidence) / 2;
    return Math.min(Math.max(combinedConfidence, 0), 1);
  }

  updateConfidence(oldConfidence: number, chromaConfidence: number): number {
    // Exponential moving average to smooth confidence updates
    const alpha = 0.3; // Smoothing factor
    const updatedConfidence = alpha * chromaConfidence + (1 - alpha) * oldConfidence;

    return Math.min(Math.max(updatedConfidence, 0), 1); // Ensure confidence is between 0 and 1
  }

  private calculateLengthScore(response: string): number {
    const words = this.simpleTokenize(response);
    const optimalLength = 50; // Adjust based on your use case
    const lengthDifference = Math.abs(words.length - optimalLength);
    return Math.exp(-lengthDifference / optimalLength);
  }

  private calculateComplexityScore(response: string): number {
    const words = this.simpleTokenize(response);
    const uniqueWords = new Set(words);
    const lexicalDiversity = uniqueWords.size / words.length;

    // Assuming a good lexical diversity is around 0.6-0.7
    return Math.min(lexicalDiversity / 0.7, 1);
  }

  private simpleTokenize(text: string): string[] {
    // Simple word-splitting function
    return text.toLowerCase().match(/\b(\w+)\b/g) || [];
  }
}.//assistant/memory/store.ts
// MemoryStore.ts
import { ChromaClient, Collection } from 'chromadb';

export interface Memory {
  input: string;
  response: string;
  confidence: number;
}

export class MemoryStore {
  private collection: Collection;

  constructor(private chromaClient: ChromaClient) {
    this.initializeCollection();
  }

  private async initializeCollection() {
    this.collection = await this.chromaClient.getOrCreateCollection({
      name: "agent_memories",
      metadata: { "hnsw:space": "cosine" }
    });
  }

  async storeMemory(input: string, response: string, confidence: number): Promise<void> {
    const id = this.generateId();
    await this.collection.add({
      ids: [id],
      documents: [response],
      metadatas: [{ input, confidence }],
    });
  }

  async findSimilarMemories(input: string, threshold: number): Promise<Array<Memory & { similarity: number }>> {
    await this.initializeCollection();
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 5,
    });

    return results.metadatas[0].map((metadata, index) => ({
      input: metadata.input,
      response: results.documents[0][index],
      confidence: metadata.confidence,
      similarity: 1 - (results.distances[0][index] || 0)
    })).filter(memory => memory.similarity > threshold) as any;
  }

  async updateMemory(input: string, response: string, newConfidence: number): Promise<void> {
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 1,
    });

    if (results.ids[0] && results.ids[0][0]) {
      const id = results.ids[0][0];
      await this.collection.update({
        ids: [id],
        documents: [response],
        metadatas: [{ input, confidence: newConfidence }],
      });
    }
  }

  async listMemories(): Promise<Memory[]> {
    const results = await this.collection.get();
    return results.metadatas.map((metadata, index) => ({
      input: metadata.input,
      response: results.documents[index],
      confidence: metadata.confidence,
    })) as any;
  }

  async removeMemory(input: string): Promise<void> {
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 1,
    });

    if (results.ids[0] && results.ids[0][0]) {
      const id = results.ids[0][0];
      await this.collection.delete({ ids: [id] });
    }
  }

  private generateId(): string {
    return Math.random().toString(36).substring(2, 15);
  }
}.//assistant/memory/consolidator.ts
import { MemoryStore, Memory } from './store';
import { ChromaClient } from 'chromadb';
import { ConfidenceCalculator } from './confidence';
import natural from 'natural';

export class MemoryConsolidator {
  private chromaClient: ChromaClient;
  private confidenceCalculator: ConfidenceCalculator;
  private tfidf: natural.TfIdf;

  constructor(chromaClient: ChromaClient) {
    this.chromaClient = chromaClient;
    this.confidenceCalculator = new ConfidenceCalculator();
    this.tfidf = new natural.TfIdf();
  }

  async consolidateMemories(memoryStore: MemoryStore): Promise<void> {
    const memories = await memoryStore.listMemories();
    this.buildTfidfModel(memories);
    const clusters = await this.clusterSimilarMemories(memories);
    
    for (const cluster of clusters) {
      if (cluster.length > 1) {
        const consolidatedMemory = await this.mergeMemories(cluster);
        await this.updateConsolidatedMemory(memoryStore, consolidatedMemory, cluster);
      }
    }
  }

  private buildTfidfModel(memories: Memory[]): void {
    memories.forEach(memory => {
      this.tfidf.addDocument(memory.input + ' ' + memory.response);
    });
  }

  private async clusterSimilarMemories(memories: Memory[]): Promise<Memory[][]> {
    const SIMILARITY_THRESHOLD = 0.8;
    const clusters: Memory[][] = [];
    const embeddingCache: { [key: string]: number[] } = {};

    for (const memory of memories) {
      let added = false;
      const memoryEmbedding = await this.getEmbedding(memory.input + ' ' + memory.response, embeddingCache);

      for (const cluster of clusters) {
        const clusterEmbedding = await this.getEmbedding(
          cluster[0].input + ' ' + cluster[0].response,
          embeddingCache
        );
        
        if (this.cosineSimilarity(memoryEmbedding, clusterEmbedding) > SIMILARITY_THRESHOLD) {
          cluster.push(memory);
          added = true;
          break;
        }
      }

      if (!added) {
        clusters.push([memory]);
      }
    }

    return clusters;
  }

  private async getEmbedding(text: string, cache: { [key: string]: number[] }): Promise<number[]> {
    if (!cache[text]) {
     const coll = await this.chromaClient.getOrCreateCollection({
      name: "agent_memories",
      metadata: { "hnsw:space": "cosine" }
     });
     cache[text] = await coll.embeddingFunction.generate([text])[0]
    }
    return cache[text];
  }

  private cosineSimilarity(vec1: number[], vec2: number[]): number {
    const dotProduct = vec1.reduce((sum, val, i) => sum + val * vec2[i], 0);
    const mag1 = Math.sqrt(vec1.reduce((sum, val) => sum + val * val, 0));
    const mag2 = Math.sqrt(vec2.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (mag1 * mag2);
  }

  private async mergeMemories(cluster: Memory[]): Promise<Memory> {
    const combinedInput = this.combineTexts(cluster.map(m => m.input));
    const combinedResponse = this.combineTexts(cluster.map(m => m.response));
    
    const newConfidence = await this.calculateMergedConfidence(cluster, combinedInput, combinedResponse);

    return {
      input: combinedInput,
      response: combinedResponse,
      confidence: newConfidence,
    };
  }

  private combineTexts(texts: string[]): string {
    const sentences = texts.flatMap(text => text.split(/[.!?]+/).filter(s => s.trim().length > 0));
    const uniqueSentences = Array.from(new Set(sentences));
    
    uniqueSentences.sort((a, b) => {
      const scoreA = this.tfidf.tfidf(a.split(' '), 0);
      const scoreB = this.tfidf.tfidf(b.split(' '), 0);
      return scoreB - scoreA;
    });

    return uniqueSentences.join('. ') + '.';
  }

  private async calculateMergedConfidence(cluster: Memory[], combinedInput: string, combinedResponse: string): Promise<number> {
    const individualConfidences = cluster.map(m => m.confidence);
    const averageConfidence = individualConfidences.reduce((sum, conf) => sum + conf, 0) / cluster.length;
    
    const newInitialConfidence = await this.confidenceCalculator.calculateInitialConfidence(1.0, combinedResponse);
    
    return (averageConfidence + newInitialConfidence) / 2;
  }

  private async updateConsolidatedMemory(
    memoryStore: MemoryStore,
    consolidatedMemory: Memory,
    originalMemories: Memory[]
  ): Promise<void> {
    await memoryStore.storeMemory(
      consolidatedMemory.input,
      consolidatedMemory.response,
      consolidatedMemory.confidence
    );

    for (const memory of originalMemories) {
      await memoryStore.removeMemory(memory.input);
    }
  }
}.//assistant/memory/refiner.ts
import { MemoryStore, Memory } from './store';
import { ConfidenceCalculator } from './confidence';
import Conversation from '../conversation';

export class MemoryRefiner {
  private confidenceCalculator: ConfidenceCalculator;

  constructor() {
    this.confidenceCalculator = new ConfidenceCalculator();
  }

  async refineMemories(memoryStore: MemoryStore, model: string = 'claude'): Promise<void> {
    const memories = await memoryStore.listMemories();
    for (const memory of memories) {
      if (memory.confidence < 0.8) {
        const refinedResponse = await this.getRefinedResponse(memory.input, memory.response, model);
        const newConfidence = this.confidenceCalculator.updateConfidence(
          memory.confidence,
          memory.confidence // TODO: replace with Chroma's similarity score
        );
      await memoryStore.updateMemory(memory.input, refinedResponse, newConfidence);
    }
  }
}

// TODO: not gonna work, becuse it has no context of the conversation
private async getRefinedResponse(input: string, previousResponse: string, model: string): Promise<string> {
  const convo = new Conversation(model);
  const prompt = `Given the following input and previous response, please provide an improved response:
  
Input: ${input}

Previous Response: ${previousResponse}

Improved Response:`;

  const response = await convo.chat([
    { role: 'system', content: 'You are an AI assistant tasked with improving responses.' },
    { role: 'user', content: prompt }
  ]);

  return response.content[0].text;
}
}.//assistant/workflow.ts

import chalk from 'chalk';

import Assistant from './assistant';
import { MemoryRefiner } from './memory/refiner';
import { MemoryConsolidator } from './memory/consolidator';
import { MemoryPruner } from './memory/pruner';

export interface WorkflowResult {
  success: boolean;
  data?: any;
  error?: Error;
}

export class CoreWorkflow extends Assistant {

  private memoryRefiner: MemoryRefiner;
  private memoryConsolidator: MemoryConsolidator;
  private memoryPruner: MemoryPruner;
  private lastMemoryMaintenanceTime: number;

  constructor(public toolRegistry: any, chromaClient: any) {
    super(toolRegistry, chromaClient);
    this.memoryRefiner = new MemoryRefiner();
    this.memoryConsolidator = new MemoryConsolidator(chromaClient);
    this.memoryPruner = new MemoryPruner();
    this.lastMemoryMaintenanceTime = Date.now();
  }

  async execute(input: string): Promise<WorkflowResult> {
    try {
      if (input.startsWith('.')) {
        await this.executeSpecialCommand(input);
        return { success: true };
      }
      //this.setupHandlers();
      this.history.push(input);
      this.working = true;

      // Existing execute logic
      const result = await this.callAgent(input);

      // Periodically perform memory maintenance
      if (this.shouldPerformMemoryMaintenance()) {
        await this.performMemoryMaintenance();
      }

      // if result is already a WorkflowResult, return it
      if (result.success !== undefined) {
        return result;
      }

      return { success: true, data: result };
    } catch (error) {
      console.log(chalk.bold.red(error.message));
      return await this.handleError(error, input);
    } finally {
      this.removeAllListeners();
      this.working = false;
      this.emit('show-prompt');
    }
  }

  private shouldPerformMemoryMaintenance(): boolean {
    const MAINTENANCE_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
    return Date.now() - this.lastMemoryMaintenanceTime > MAINTENANCE_INTERVAL;
  }

  private async performMemoryMaintenance(): Promise<void> {
    await this.memoryRefiner.refineMemories(this.memoryStore);
    await this.memoryConsolidator.consolidateMemories(this.memoryStore);
    await this.memoryPruner.pruneMemories(this.memoryStore);
    this.lastMemoryMaintenanceTime = Date.now();
  }

  setupHandlers() {
    this.on('taskId', (taskid: any) => {
      this.on(`${taskid}_task`, (chat: any) => {
        console.log(chalk.bold.yellow('Task: ' + chat.chat));
        this.removeListener(`${taskid}_task`);
      });
      this.on(`${taskid}_chat`, (chat: any) => {
        console.log(chalk.bold.green(chat));
        this.removeListener(`${taskid}_chat`);
      });
      this.on(`${taskid}_script`, (script: any) => {
        console.log(chalk.bold.blue('Script: ' + script));
        this.removeListener(`${taskid}_script`);
      });
      this.on(`${taskid}_results`, async (result: any) => {
        this.removeListener(`${taskid}_results`);
        console.log(chalk.bold.magenta(JSON.stringify(result, null, 2)) + '\n')
        
      });
      this.on('tool_update', (data: any) => {
        console.log(chalk.bold.cyan(`Tool '${data.name}' updated to version ${data.version}`));
      });

      this.on('tool_rollback', (data: any) => {
        console.log(chalk.bold.cyan(`Tool '${data.name}' rolled back to version ${data.version}`));
      });
    });
    this.on('text', (error: any) => {
      this.debug && console.log(chalk.italic.gray(error));
    });
    this.on('error', (error: any) => {
      console.log(chalk.bold.red(error));
    });
  }

  async executeSpecialCommand(command: string) {
    switch (command) {
      case '.help':
        this.showHelp();
        break;
      case '.debug':
        this.toggleDebug();
        break;
      case '.history':
        this.printHistory();
        break;
      default:
        console.log(`Unknown command: ${command}`);
    }
  }

  restoreSessionState() {
    // Restore the saved output and print it to the console
    process.stdout.write(this.savedOutput);
    this.printHistory();
  }

  showHelp() {
    console.log("Commands:");
    console.log("  .help\t\tShow this help message");
    console.log("  .debug\t\tToggle debug mode on/off");
    console.log("  .history\tShow command history for this session");
    console.log("  .state\t\tShow current state of the session");
    console.log("  .exit\t\tExit this session");
    console.log("  Ctrl+A\t\tCreate a new session");
    console.log("  Ctrl+C\t\tSwitch to the next session");
  }

  toggleDebug() {
    this.debug = !this.debug;
    console.log(`Debug mode is now ${this.debug ? 'on' : 'off'}`);
  }

  printHistory() {
    if (this.history.length === 0) {
      console.log('This session has no history yet.');
      return;
    }
    console.log(`Session History:`);
    this.history.forEach((command, index) => {
      console.log(`${index + 1}. ${command}`);
    });
  }

  private async handleError(error: Error, context: string): Promise<WorkflowResult> {
    const errorPrompt = `An error occurred during execution. Analyze the error and context, then respond with either:
1. A modified script to retry the operation, or
2. Instructions to update a tool if it's a tooling problem.

Error: ${error.message}
Context: ${context}

Respond in JSON format:
{
  "action": "retry" | "update_tool",
  "data": "<modified script>" | { "toolName": "<name>", "updatedSource": "<source>" }
}`;

    let response = await this.conversation.chat([
      { role: 'system', content: errorPrompt },
      { role: 'user', content: JSON.stringify({ error: error.message, context }) }
    ]);
    response = response.replace(/.*```json/g, '');
    response = response.replace(/.*```/g, '');
    response = response.replace(/[\r\n]+/g, '');
    let resolution = JSON.parse(response);
    if (resolution.action === 'retry') {
      return await this.execute(resolution.data);
    } else if (resolution.action === 'update_tool') {
      await this.updateTool(resolution.data.toolName, resolution.data.updatedSource);
      return await this.execute(context);
    } else {
      return { success: false, error: new Error('Unable to resolve the error') };
    }
  }

  async updateTool(name: string, source: string): Promise<boolean> {
    const updated = await this.toolRegistry.updateTool(name, source);
    if (updated) {
      super.emit('toolUpdated', { name, source });
    } else {
      throw new Error(`Failed to update tool: ${name}`);
    }
    return updated;
  }

}.//assistant/errorLogger.ts
import fs from 'fs';

export class ErrorLogger {
  private logFilePath: string;

  constructor(logFilePath: string) {
    this.logFilePath = logFilePath;
  }

  public logError(errorDetails: any): void {
    const errorLog = {
      timestamp: new Date().toISOString(),
      ...errorDetails
    };

    const logEntry = JSON.stringify(errorLog) + '\n';
    fs.appendFileSync(this.logFilePath, logEntry);
  }

  public getErrors(): any[] {
    const logContent = fs.readFileSync(this.logFilePath, 'utf-8');
    return logContent.split('\n')
      .filter(line => line.trim() !== '')
      .map(line => JSON.parse(line));
  }

  public analyzeErrors(): any {
    const errors = this.getErrors();
    // Implement error analysis logic here
    // For example, count occurrences of each error type
    const errorCounts: { [key: string]: number } = {};
    errors.forEach(error => {
      const errorType = error.error || 'Unknown';
      errorCounts[errorType] = (errorCounts[errorType] || 0) + 1;
    });
    return errorCounts;
  }
}

export const debugLog = (message: string, data?: any) => {
  console.log(message, data);
};
.//assistant/confirmation.ts

// confirmation.ts
import blessed from 'blessed';
import contrib from 'blessed-contrib';
import fs from 'fs';

// Function to display a confirmation prompt to the user
export async function confirmExecution(api: any, message: string): Promise<boolean> {
  return new Promise((resolve) => {
    const screen = blessed.screen({
      smartCSR: true
    });

    const questionBox = blessed.question({
      parent: screen,
      border: 'line',
      height: 'shrink',
      width: 'half',
      top: 'center',
      left: 'center',
      label: ' {blue-fg}Confirmation{/blue-fg} ',
      tags: true,
      keys: true,
      vi: true,
      content: message + '\n\n{green-fg}[Y]{/green-fg}es / {red-fg}[N]{/red-fg}o',
    });

    questionBox.on('submit', (answer: any) => {
      screen.destroy();
      resolve(answer.toLowerCase() === 'y');
    });

    questionBox.key(['escape', 'n'], () => {
      screen.destroy();
      resolve(false);
    });

    questionBox.focus();
    screen.render();
  });
}

// Function to display code for editing and get confirmation
export async function displayCodeForEdit(api: any, message: string, filePath: string): Promise<boolean> {
  return new Promise((resolve) => {
    const screen = blessed.screen({
      smartCSR: true
    });

    const grid = new contrib.grid({ rows: 12, cols: 12, screen: screen });

    const editor = grid.set(0, 0, 10, 12, contrib.markdown, {
      label: ` ${filePath} `,
      keys: true,
      vi: true,
      content: fs.readFileSync(filePath, 'utf8'),
    });

    const confirmBox = grid.set(10, 0, 2, 12, blessed.box, {
      content: message + '\n\n{green-fg}[S]{/green-fg}ave & Execute / {red-fg}[C]{/red-fg}ancel',
      tags: true,
      style: {
        fg: 'white',
        bg: 'black',
        border: {
          fg: '#f0f0f0'
        },
        hover: {
          bg: 'green'
        }
      }
    });

    confirmBox.key(['escape', 'c'], () => {
      screen.destroy();
      resolve(false);
    });

    confirmBox.key(['s'], () => {
      fs.writeFileSync(filePath, editor.getText());
      screen.destroy();
      resolve(true);
    });

    screen.render();
  });
}.//assistant/tool-base.ts
export default interface ToolBase {
    execute(params, api);
}.//assistant/script/cleanupManager.ts
import ToolRegistry, { Tool } from '../tool_registry';
import { ScriptPerformanceMonitor } from './performanceMonitor';

export class ScriptCleanupManager {
  private static readonly CLEANUP_THRESHOLD = 30 * 24 * 60 * 60 * 1000; // 30 days in milliseconds

  static async cleanupUnusedScripts(toolRegistry: ToolRegistry): Promise<void> {
    const allScripts = await toolRegistry.getToolList();
    const currentDate = new Date();

    for (const script of allScripts) {
      const metrics = ScriptPerformanceMonitor.getMetrics(script.name);
      if (metrics) {
        const daysSinceLastExecution = (currentDate.getTime() - metrics.lastExecutionTime.getTime()) / (24 * 60 * 60 * 1000);
        if (daysSinceLastExecution > 30 && metrics.executionCount < 5) {
          await this.archiveScript(toolRegistry, script);
        }
      }
    }
  }

  private static async archiveScript(toolRegistry: ToolRegistry, script: Tool): Promise<void> {
    await toolRegistry.updateTool(script.name, script.source, { ...script.schema, archived: true }, script.tags);
  }
}.//assistant/script/metadataManager.ts
import ToolRegistry from '../tool_registry';

export interface ScriptMetadata {
  originalQuery: string;
  creationDate: Date;
  lastModifiedDate: Date;
  author: string;
  version: string;
  tags: string[];
  dependencies: string[];
}

export class MetadataManager {
  static async addMetadata(toolRegistry: ToolRegistry, scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    const script = await toolRegistry.getTool(scriptName);
    if (script) {
      const updatedScript = {
        ...script,
        metadata: {
          ...script.metadata,
          ...metadata,
          lastModifiedDate: new Date()
        }
      };
      await toolRegistry.updateTool(scriptName, updatedScript.source, updatedScript.schema, updatedScript.metadata);
    }
  }

  static async getMetadata(toolRegistry: ToolRegistry, scriptName: string): Promise<ScriptMetadata | null> {
    const script = await toolRegistry.getTool(scriptName);
    return script ? script.metadata : null;
  }

  static async updateMetadata(toolRegistry: ToolRegistry, scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    const script = await toolRegistry.getTool(scriptName);
    if (script) {
      const updatedScript = {
        ...script,
        metadata: {
          ...script.metadata,
          ...metadata,
          lastModifiedDate: new Date()
        }
      };
      await toolRegistry.updateTool(scriptName, updatedScript.source, updatedScript.schema, updatedScript.metadata);
    }
  }

  static async removeMetadata(toolRegistry: ToolRegistry, scriptName: string): Promise<void> {
    const script = await toolRegistry.getTool(scriptName);
    if (script) {
      const updatedScript = {
        ...script,
        metadata: {
          originalQuery: '',
          creationDate: new Date(),
          lastModifiedDate: new Date(),
        }
      };
      await toolRegistry.updateTool(scriptName, updatedScript.source, updatedScript.schema, updatedScript.metadata);
    }
  }
}.//assistant/script/performanceMonitor.ts
export class ScriptPerformanceMonitor {
    private static metrics: Map<string, {
      executionCount: number,
      totalExecutionTime: number,
      averageExecutionTime: number,
      lastExecutionTime: Date
    }> = new Map();
  
    static recordExecution(scriptName: string, executionTime: number): void {
      const metric = this.metrics.get(scriptName) || {
        executionCount: 0,
        totalExecutionTime: 0,
        averageExecutionTime: 0,
        lastExecutionTime: new Date()
      };
  
      metric.executionCount++;
      metric.totalExecutionTime += executionTime;
      metric.averageExecutionTime = metric.totalExecutionTime / metric.executionCount;
      metric.lastExecutionTime = new Date();
  
      this.metrics.set(scriptName, metric);
    }
  
    static getMetrics(scriptName: string): any {
      return this.metrics.get(scriptName);
    }
  
    static getAllMetrics(): Map<string, any> {
      return this.metrics;
    }
  }.//assistant/script/validator.ts
import * as vm from 'vm2';

export class ScriptValidator {
  static async validate(script: string): Promise<boolean> {
    const staticAnalysisResult = await this.performStaticAnalysis(script);
    if (!staticAnalysisResult.valid) return false;

    const sandboxResult = await this.runInSandbox(script);
    if (!sandboxResult.valid) return false;

    return true;
  }

  private static async performStaticAnalysis(script: string): Promise<{valid: boolean, issues?: string[]}> {
    // Implement static code analysis here
    // This could use tools like ESLint or custom rules
    return { valid: true };
  }

  private static async runInSandbox(script: string): Promise<{valid: boolean, output?: any}> {
    const sandbox = new vm.VM({
      timeout: 5000,
      sandbox: {}
    });

    try {
      sandbox.run(script);
      return { valid: true };
    } catch (error) {
      console.error('Script execution in sandbox failed:', error);
      return { valid: false, output: error.message };
    }
  }
}.//assistant/assistant.ts
import "dotenv/config";
import { EventEmitter } from "eventemitter3";
import { ErrorLogger } from './errorLogger';
import Conversation from './conversation';
import { VM, VMScript } from 'vm2';
import { tools as importedTools } from './tools';

import { MemoryStore } from './memory/store';
import { ConfidenceCalculator } from './memory/confidence';
import { ChromaClient } from 'chromadb';
import fs from "fs";
import path from "path";
import { Tool } from "./tool_registry";
import { log, setLogLevel, toggleService } from '../logger';

interface Memory {
  input: string;
  response: string;
  confidence: number;
  adjustedConfidence?: number;
  usedTools: string[];
}

const errorLogger = new ErrorLogger('error.log');

export default class Assistant extends EventEmitter {

  public memoryStore: MemoryStore;
  public confidenceCalculator: ConfidenceCalculator;

  public chatWindow: any;
  public apiKey: string = process.env.ANTHROPIC_API_KEY || '';
  public vscode: any;

  store: any;

  private globalRetryCount: number = 0;
  private globalRetryLimit: number = 100;

  protected conversation: Conversation;
  protected errorLogger: ErrorLogger = errorLogger;

  public working = false;
  public debug = false;
  public history: string[] = [];
  public savedOutput = '';

  constructor(public toolRegistry: any, public chromaClient: ChromaClient) {
    super();
    this.store = {};
    this.conversation = new Conversation('claude');
    this.memoryStore = new MemoryStore(chromaClient);
    this.confidenceCalculator = new ConfidenceCalculator();

    this.ensureToolsDirectory();

    setLogLevel('info');
    toggleService('Assistant', true);
  }

  private ensureToolsDirectory() {
    const toolsDir = path.join(__dirname, 'tools');
    if (!fs.existsSync(toolsDir)) {
      fs.mkdirSync(toolsDir, { recursive: true });
    }
  }

  private logError(message: string) {
    log('error', message, 'Assistant');
  }

  private logInfo(message: string) {
    log('info', message, 'Assistant');
  }

  private logWarn(message: string) {
    log('warn', message, 'Assistant');
  }

  private logDebug(message: string) {
    log('debug', message, 'Assistant');
  }

  async getToolRegistryReport(): Promise<string> {
    return await this.toolRegistry.generateReport();
  }

  async improveToolManually(toolName: string, newSource: string): Promise<boolean> {
    return await this.toolRegistry.updateTool(toolName, newSource);
  }

  getToolSource(toolName: string) {
    const tool = this.toolRegistry.tools[toolName];
    return tool ? tool.source : null;
  }

  get tools(): { [key: string]: Tool } {
    return this.toolRegistry.tools;
  }

  async pause(duration: number) {
    return await new Promise(resolve => setTimeout(resolve, duration));
  }

  private isRetryableError(error: any): boolean {
    const retryableErrorMessages = [
      'network timeout',
      'connection refused',
      'server unavailable',
    ];
    return retryableErrorMessages.some(message =>
      error.message.toLowerCase().includes(message)
    );
  }

  protected async retryOperation<T>(operation: () => Promise<T>, maxRetries: number, delay: number, toolName?: string): Promise<T> {
    let retries = 0;
    while (true) {
      try {
        this.globalRetryCount++;
        if (this.globalRetryCount > this.globalRetryLimit) {
          throw new Error("Global retry limit exceeded.");
        }
        await this.pause(1000);
        return await operation();
      } catch (error: any) {
        if (retries >= maxRetries || !this.isRetryableError(error)) {
          throw error;
        }

        retries++;
        const retryDelay = delay * Math.pow(2, retries);
        const message = toolName ? `Error calling tool '${toolName}': ${error.message}` : `Error: ${error.message}`;
        this.logWarn(`${message}. Retrying in ${retryDelay}ms...`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      }
    }
  }

  async callTool(toolName: string, params: any) {
    this.logDebug(`Calling tool: ${toolName}`);
    if (Array.isArray(params)) params = params[0];

    return this.retryOperation(async () => {
      try {
        const tool = await this.toolRegistry.loadTool(toolName);
        if (!tool) {
          throw new Error(`Tool '${toolName}' not found.`);
        }

        return await this.toolRegistry.callTool(toolName, params);

      } catch (error: any) {
        if (toolName === 'ask' && error.message.includes('No response received')) {
          return "I'm sorry, but I didn't receive a response. Could you please try again?";
        } else if (toolName === 'busybox' && error.message.includes('No such file or directory')) {
          const alternativeLocation = await this.promptUser("The specified file or directory was not found. Please provide an alternative location:");
          if (alternativeLocation) {
            params.args[0] = alternativeLocation;
            return await this.callTool(toolName, params);
          }
        }
        throw error;
      }
    }, 3, 1000, toolName);
  }

  async showToolHistory(args: string[]) {
    if (args.length < 1) {
      this.logInfo("Usage: .tool history <name>");
      return;
    }

    const [name] = args;

    try {
      const history = await this.toolRegistry.getToolHistory(name);
      this.logInfo(name);
      history.forEach((entry: any) => {
        this.logInfo(`  ${entry}`);
      });
    } catch (error) {
      this.logError(`Error fetching tool history: ${error.message}`);
    }
  }

  async loadTool(name: string): Promise<Tool | undefined> {
    return await this.toolRegistry.loadTool(name);
  }

  async updateTool(name: string, source: string): Promise<boolean> {
    return await this.toolRegistry.updateTool(name, source);
  }

  async rollbackTool(name: string, version: string): Promise<boolean> {
    return await this.toolRegistry.rollbackTool(name, version);
  }

  private selectBestMemory(memories: Array<Memory & { similarity: number }>): Memory & { similarity: number } {
    return memories.reduce((best, current) =>
      (current.confidence * current.similarity > best.confidence * best.similarity) ? current : best
    );
  }

  private async adaptMemoryToInput(memory: Memory & { similarity: number }, newInput: string, model: string): Promise<string> {
    const convo = new Conversation(model);
    const prompt = `Given a new input and a similar previous experience, please adapt the previous response to fit the new input:

Previous Input: ${memory.input}
Previous Response: ${memory.response}
Tools Used: ${memory.usedTools.join(', ')}
New Input: ${newInput}

Adapted Response:`;

    const response = await convo.chat([
      { role: 'system', content: 'You are an AI assistant tasked with adapting previous responses to new inputs.' },
      { role: 'user', content: prompt }
    ]);

    return response.content[0].text;
  }

  async executeRegistryManagement(params: any): Promise<any> {
    return this.toolRegistry.tools['registry_management'].execute(this, params);
  }

  async callAgent(input: string, model = 'claude', resultVar?: string): Promise<{ success: boolean; data?: any; error?: Error; }> {
    const CONFIDENCE_THRESHOLD = 0.8;
    const SIMILARITY_THRESHOLD = 0.9;

    try {
      // Preprocessing step: Select relevant tools and retrieve similar memories
      const relevantTools = await this.toolRegistry.predictLikelyTools(input);
      const similarMemories = await this.memoryStore.findSimilarMemories(input, SIMILARITY_THRESHOLD);

      // Check if we can use an existing memory
      if (similarMemories.length > 0) {
        const adjustedMemories = similarMemories.map(memory => ({
          ...memory,
          adjustedConfidence: this.confidenceCalculator.calculateRetrievalConfidence(memory.confidence, memory.similarity)
        }));
        const bestMemory = this.selectBestMemory(adjustedMemories as any);

        if (bestMemory.adjustedConfidence > CONFIDENCE_THRESHOLD) {
          const adaptedResponse = await this.adaptMemoryToInput(bestMemory, input, model);
          await this.updateMemoryConfidence(bestMemory);
          return { success: true, data: adaptedResponse };
        }
      }

      // Prepare the prompt with the selected tools and similar memories
      const toolsRepresentation = this.toolRegistry.getCompactRepresentation(relevantTools);
      const memoriesRepresentation = this.prepareMemoriesRepresentation(similarMemories as any);

      const jsonPrompt = (compactRepresentation, memoriesRepresentation) => `Transform the given task into a sequence of subtasks, each with a JavaScript script that uses the provided tools to achieve the subtask objective.
  
  Available Tools:
  
  ${compactRepresentation}
  
  Similar Past Experiences:
  
  ${memoriesRepresentation}
  
  Additional tools can be explored using 'list_all_tools', 'get_tool_details', and 'load_tool'.
  
  Process:
  
  1. Analyze the task and identify necessary steps, considering similar past experiences
  2. Decompose into subtasks with clear objectives and input/output
  3. For each subtask, write a JavaScript script using the tools
    a. Access previous subtask results with taskResults.<taskName>_results: \`const lastResult = taskResults.firstTask_results; ...\`
    b. Store subtask results in a variable for future use: \`const result = { key: 'value' }; taskResults.subtask_results = result; ...\`
    b. End the script with a return statement for the subtask deliverable: \`return result;\`
  4. Test each script and verify the output
  5. Provide a concise explanation of the subtask's purpose and approach
  
  Data Management:
  
  - Store subtask results in resultVar (JSON/array format): \`taskResults.subtask_results = result;\`
  Access previous subtask data with taskResults.<resultVar>: \`const lastResult = taskResults.subtask_results; ...\`
  Include only resultVar instructions in responses, not the actual data.
  
  Output Format:
  \`\`\`json
  [
    {
    "task": "<taskName>:<description>",
    "script": "<JavaScript script>",
    "chat": "<subtask explanation>",
    "resultVar": "<optional result variable>"
    },
    // ... additional subtasks
  ]
  \`\`\``;

      const convo = new Conversation(model);
      const response = await convo.chat([
        {
          role: 'system',
          content: jsonPrompt(toolsRepresentation, memoriesRepresentation)
        },
        {
          role: 'user',
          content: this.escapeTemplateLiteral(JSON.stringify({
            task: input,
          })),
        },
      ]);

      let tasks = response.content[0].text;
      tasks = tasks.replace(/```json/g, '').replace(/```/g, '');
      tasks = tasks.replace(/\n/g, '');


      let message = '';
      try {
        tasks = this.extractJson(tasks);
      } catch (error: any) {
        message = error.message;
      }
      if (!Array.isArray(tasks) || tasks.length === 0) {
        this.logError(message);
        throw new Error('The task must be an array of subtasks. Check the format and try again. RETURN ONLY JSON RESPONSES' + message);
      }

      const results: any = [];
      const usedTools: Set<string> = new Set();

      this.store[input] = tasks;

      if (Array.isArray(tasks) && Array.isArray(tasks[0])) {
        tasks = tasks[0];
      }

      if (resultVar) {
        this.store[resultVar] = results;
      }

      for (const task of tasks) {
        let { task: taskName, script, chat } = task;
        const splitTask = taskName.split(':');
        let taskId = taskName;
        if (splitTask.length > 1) {
          taskId = splitTask[0];
          taskName = splitTask[1];
        }
        this.store['currentTaskId'] = taskId;
        this.emit('taskId', taskId);

        this.store[`${taskId}_task`] = task;
        this.emit(`${taskId}_task`, task);

        this.store[`${taskId}_chat`] = chat;
        this.emit(`${taskId}_chat`, chat);

        this.store[`${taskId}_script`] = script;
        this.emit(`${taskId}_script`, script);

        const sr = await this.callScript(script);
        task.scriptResult = sr;

        // Track used tools
        const toolsUsedInScript = this.extractUsedTools(script);
        toolsUsedInScript.forEach(tool => usedTools.add(tool));

        this.store[`${taskId}_result`] = sr;
        this.store[`${taskId}_results`] = sr;
        const rout = { id: taskId, task: taskName, script, result: sr };
        this.emit(`${taskId}_results`, rout);

        results.push(rout as any);
      }

      const newMemory = JSON.stringify(tasks);

      // Store the new memory with used tools
      const initialConfidence = this.confidenceCalculator.calculateInitialConfidence(1.0, newMemory);
      await this.memoryStore.storeMemory(input, newMemory, initialConfidence);

      // Update confidence for similar memories
      for (const memory of similarMemories) {
        await this.updateMemoryConfidence(memory as any);
      }

      if (resultVar) {
        this.store[resultVar] = results;
      }

      // After processing all tasks, consider optimizing scripts
      this.optimizeScripts(tasks);

      return { success: true, data: results };
    } catch (error: any) {
      return { success: false, error: error };
    }
  }

  private prepareMemoriesRepresentation(memories: Array<Memory & { similarity: number }>): string {
    return memories.map(memory => `
Input: ${memory.input}
Response: ${memory.response}
Tools Used: ${memory.usedTools.join(', ')}
Confidence: ${memory.confidence}
Similarity: ${memory.similarity}
`).join('\n');
  }

  private extractUsedTools(script: string): string[] {
    const toolRegex = /tools\.(\w+)/g;
    const matches = script.match(toolRegex);
    return matches ? [...new Set(matches.map(match => match.split('.')[1]))] : [];
  }

  private async updateMemoryConfidence(memory: Memory & { similarity: number }) {
    const newConfidence = this.confidenceCalculator.updateConfidence(memory.confidence, memory.similarity);
    await this.memoryStore.updateMemory(memory.input, memory.response, newConfidence);
  }

  // async callScript(script: string, retryLimit: number = 10): Promise<any> {
  //   let retryCount = 0;

  //   while (retryCount < retryLimit) {
  //     try {
  //       // Check if this script already exists as a tool
  //       const existingTool = await this.toolRegistry.getTool(script);
  //       if (existingTool) {
  //         await this.toolRegistry.callTool(existingTool.name, {});
  //         }

  //         // If not, execute the script as before
  //         const context = this.prepareContext();
  //         const result = await this.executeScript(script, context);

  //         // After successful execution, consider adding this script as a new tool
  //         this.considerAddingAsTool(script);

  //         return result;
  //       } catch (error: any) {
  //         this.logError(`Error calling script: ${error}`);

  //         retryCount++;

  //         if (retryCount >= retryLimit) {
  //           this.errorLogger.logError({
  //             error: error.message,
  //             stackTrace: error.stack,
  //             script: script,
  //             retryAttempts: retryCount
  //           });
  //           throw new Error(`Script execution failed after ${retryLimit} attempts.`);
  //         }

  //         const errorMessage = error.message;
  //         const stackTrace: any = error.stack;
  //         const errorLine = this.extractErrorLine(stackTrace);

  //         this.errorLogger.logError({
  //           error: errorMessage,
  //           stackTrace: stackTrace,
  //           script: script,
  //           errorLine: errorLine,
  //           retryAttempts: retryCount
  //         });

  //         try {
  //           let llmResponse = await this.callTool('callLLM', {
  //             system_prompt: 'Analyze the provided script, script error, and context, generate a fixed version of the script, and output it and an explanation of your work *in a JSON object*. Output the modified script and explanation *in JSON format* { modifiedScript, explanation }. ***OUTPUT RAW JSON ONLY***.',
  //             prompt: JSON.stringify({
  //               error: errorMessage,
  //               stackTrace: stackTrace,
  //               script: this.escapeTemplateLiteral(script),
  //               errorLine: errorLine,
  //             })
  //           });

  //           if (typeof llmResponse === 'string') {
  //             llmResponse = JSON.parse(llmResponse);
  //           }

  //           const { modifiedScript, explanation } = llmResponse as any;

  //           this.logInfo(explanation);

  //           script = this.unescapeTemplateLiteral(modifiedScript);

  //         } catch (fixError) {
  //           this.logError(`Error attempting to fix the script: ${fixError}`);
  //         }

  //         await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
  //       }
  //     }

  //     throw new Error("Reached end of callScript function. This should not happen.");
  //   }
  async callScript(script: string, retryLimit: number = 10): Promise<any> {
    let retryCount = 0;
  
    while (retryCount < retryLimit) {
      try {
        // Check if this script already exists as a tool
        const existingTool = await this.toolRegistry.getTool(script);
        if (existingTool) {
          return await this.toolRegistry.callTool(existingTool.name, {});
        }
  
        // If not, execute the script as before
        const context = this.prepareContext();
        console.log('Executing script with context keys:', Object.keys(context));
        console.log('Tools available:', Object.keys(context.tools));
        console.log('Script to execute:', script);
  
        const result = await this.executeScript(script, context);
  
        // After successful execution, consider adding this script as a new tool
        this.considerAddingAsTool(script);
  
        return result;
      } catch (error) {
        console.error(`Error calling script (attempt ${retryCount + 1}/${retryLimit}):`, error);
        console.error('Script:', script);
  
        retryCount++;
  
        if (retryCount >= retryLimit) {
          throw new Error(`Script execution failed after ${retryLimit} attempts. Last error: ${error.message}`);
        }
  
        // Wait before retrying
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
      }
    }
  }

  private prepareContext(): any {
    const context: any = {
      tools: {},
      taskResults: {},
      console: { log: console.log, error: console.error },
      require: require,
      fs: require('fs'),
      path: require('path'),
      axios: require('axios'),
      _: require('lodash'),
    };
  
    // Add tools from the ToolRegistry
    for (const toolName in this.toolRegistry.tools) {
      const toolFunction = async (...args: any[]) => {
        return await this.toolRegistry.callTool(toolName, args);
      };
      context.tools[toolName] = toolFunction;
      context[toolName] = toolFunction;
    }
  
    // Add tools from the imported tools.ts
    for (const [toolName, tool] of Object.entries(importedTools)) {
      const toolFunction = async (...args: any[]) => {
        return await tool.execute(...args, this);
      };
      context.tools[toolName] = toolFunction;
      context[toolName] = toolFunction;
    }
  
    // Add task results to the context
    for (const task in this.store) {
      context.taskResults[task] = this.store[task];
      context[task] = this.store[task];
    }
  
    return context;
  }


  private async executeScript(script: string, context: any): Promise<any> {
    const vm = new VM({
      timeout: 5000,
      sandbox: context,
    });
  
    const wrappedScript = `
      (async function() {
        ${script}
      })();
    `;
  
    return vm.run(wrappedScript);
  }



  // private async executeScript(script: string, context: any): Promise<any> {
  //   const escapedScript = this.escapeTemplateLiteral(script);
  //   const llmResponse = await this.conversation.chat([
  //     { role: 'system', content: `You are a NON-VERBAL, CODE-OUTPUTTING agent. Refactor the provided script to ES5 to integrate it with the below template then output the Javascript VERBATIM with NO COMMENTS.` },
  //     { role: 'user', content: `with (context) { return (async function() { return (${escapedScript})({ operations }, run); })(); }` }
  //   ]);
  //   const scriptFunction = new Function('context', 'api', `
  //     return async function() {
  //       return (async function() {
  //         return (${llmResponse.content[0].text})(context, api);
  //       })();
  //     };
  //   `);

  //   const result = await scriptFunction(context, this);

  //   // Update the store with new task results
  //   for (const task in context.taskResults) {
  //     this.store[task] = context.taskResults[task];
  //   }

  //   return result;
  // }

  private async considerAddingAsTool(script: string): Promise<void> {
    // This method would analyze the script and potentially add it as a new tool
    // You can implement the logic based on your specific requirements
    await this.toolRegistry.analyzeAndCreateToolFromScript(script, "Auto-generated from successful script execution");
  }

  private async optimizeScripts(tasks: any[]): Promise<void> {
    for (const task of tasks) {
      await this.toolRegistry.improveTools();
    }
  }

  getSchemas() {
    return this.toolRegistry.schemas;
  }

  private extractErrorLine(stackTrace: string) {
    const lineRegex = /at .*? \(.*?:(\d+):\d+\)/;
    const match = stackTrace.match(lineRegex);
    return match && match[1] ? parseInt(match[1], 10) : null;
  }

  async promptUser(question: string): Promise<string> {
    return new Promise((resolve) => {
      this.logInfo(question);
      this.chatWindow = (response: string) => {
        resolve(response);
      };
    });
  }

  extractJson(content: string) {
    return extractJson(content);
  }

  private escapeTemplateLiteral(str: string): string {
    return str;
  }

  private unescapeTemplateLiteral(str: string): string {
    return str.replace(/\\`/g, '`').replace(/\\\$\{/g, '${');
  }
}

export function extractJson(content: string): any[] {
  const jsonObjects: any[] = [];
  let depth = 0;
  let currentJson = '';
  let inString = false;
  let escapeNext = false;

  for (let i = 0; i < content.length; i++) {
    const char = content[i];

    if (escapeNext) {
      currentJson += char;
      escapeNext = false;
      continue;
    }

    if (char === '\\') {
      currentJson += char;
      escapeNext = true;
      continue;
    }

    if (char === '"' && !inString) {
      inString = true;
      currentJson += char;
      continue;
    }

    if (char === '"' && inString) {
      inString = false;
      currentJson += char;
      continue;
    }

    if (!inString) {
      if (char === '{' || char === '[') {
        if (depth === 0) {
          currentJson = '';
        }
        depth++;
      } else if (char === '}' || char === ']') {
        depth--;
        if (depth === 0) {
          currentJson += char;
          try {
            const parsed = JSON.parse(currentJson);
            jsonObjects.push(parsed);
          } catch (error) {
            // If parsing fails, we don't attempt to fix it
            // as it might be intentionally escaped JSON within a string
          }
          currentJson = '';
          continue;
        }
      }
    }

    currentJson += char;
  }

  return jsonObjects;
}.//assistant/tool_registry.ts
import * as fs from 'fs';
import * as path from 'path';
import { EventEmitter } from 'events';
import Conversation from './conversation';
import { Assistant } from './types';
import { ScriptValidator } from './script/validator';
import { ScriptPerformanceMonitor } from './script/performanceMonitor';
import { ScriptCleanupManager } from './script/cleanupManager';
import { MetadataManager, ScriptMetadata } from './script/metadataManager';
import {tools} from './tools';

interface RegistryData {
  tools: Tool[];
}

export class Tool extends EventEmitter {
  public name: string;
  public description: string
  public version: string;
  public source: string;
  public tags: string[];
  public schema: any;
  public active: boolean;
  public testHarness: string;
  private _path: string;
  public lastTestResult: {
    success: boolean;
    message: string;
  } | null;
  public metrics: {
    versions: string[];
    totalUpdates: number;
    lastUpdated: string;
    testResults: {
      totalRuns: number;
      passed: number;
      failed: number;
      lastRun: string | null;
    };
    executionStats: {
      totalExecutions: number;
      averageExecutionTime: number;
      lastExecutionTime: number | null;
      fastestExecutionTime: number;
      slowestExecutionTime: number;
    };
    errorRate: number;
    usageCount: number;
  };
  public metadata: ScriptMetadata;
  get path (): string {
    return this._path;
  }

  constructor(
    private registry: ToolRegistry,
    name: string,
    version: string,
    description: string,
    source: string,
    tags: string[],
    schema: any,
    metadata?: ScriptMetadata
  ) {
    
    super();
    this.name = name;
    this.version = version;
    this.description = description;
    this.source = source;
    this.tags = tags;
    this.schema = schema;
    this.testHarness = '';
    this.lastTestResult = null;
    this.initializeMetrics();
    this._path = path.join(__dirname, `../../tool_repo/${this.name}`);
    this.metadata = metadata || {
      originalQuery: '',
      creationDate: new Date(),
      lastModifiedDate: new Date(),
      author: 'Unknown',
      version: '1.0.0',
      tags: [],
      dependencies: []
    };
  }

  private initializeMetrics(): void {
    this.metrics = {
      versions: [this.version],
      totalUpdates: 0,
      lastUpdated: new Date().toISOString(),
      testResults: {
        totalRuns: 0,
        passed: 0,
        failed: 0,
        lastRun: null,
      },
      executionStats: {
        totalExecutions: 0,
        averageExecutionTime: 0,
        lastExecutionTime: null,
        fastestExecutionTime: Infinity,
        slowestExecutionTime: 0,
      },
      errorRate: 0,
      usageCount: 0,
    };
  }

  executor(): (params: any, api: Assistant) => Promise<any> {
    return async (params: any, api: Assistant) => {
      const toolModule = await import(this.source);
      return await toolModule.default.execute(params, api);
    };
  }

  public saveMetrics(): void {
    this.registry.updateMetrics(this.name, 'version', this.version);
  }

  public async generateTestHarness(): Promise<void> {
    try {
      const messages = [
        {
          role: 'system',
          content: `You are a test coverage generator for javascript functions. Given a javascript function and its schema and description, you generate a test harness which thoroughly tests the function. You write your test harnesses in the following format:
\`\`\`javascript
const testHarness = {
    beforeAll: (context) => {
        context.log('beforeAll');
    },
    test1: (context) => {
        context.log('test1');
        context.assert(true, 'Test 1 passed');
    },
    test2: (context) => {
        context.log('test2');
    },
};
\`\`\`

You output RAW Javascript CODE ONLY. Do not include any comments or explanations in the code.`,
        },
        {
          role: 'user',
          content: `Tool Source:\n\n${JSON.stringify(this.source)}\n\nSchema:\n\n${JSON.stringify(this.schema)}\n\n`,
        },
      ];
      const response = await this.registry.conversation.chat(messages);
      this.testHarness = response.content[0].text;
      this.saveTool();
      this.emit('info', `Test harness generated for tool ${this.name}`);
    } catch (error) {
      this.emit('error', `Error generating test harness for tool ${this.name}:`, error);
    }
  }

  public async hardenToolCode(): Promise<void> {
    try {
      const messages = [
        {
          role: 'system',
          content: `You are a tool hardener. You take the given Javascript and you harden it if you see any security or execution vulnerabilities. You harden code by:
        - removing any awaiters and other intermediate-output code
        - adding any missing import statements
        - fixing any broken code. 
        - You output only RAW JAVASCRIPT, WITHOUT ANY COMMENTARY, EXPLANATION or FORMATTING.`,
        },
        {
          role: 'user',
          content: this.source,
        },
      ];
      const response = await this.registry.conversation.chat(messages);
      this.source = response.content[0].text;
      this.saveTool();
      this.emit('info', `Tool ${this.name} hardened successfully.`);
    } catch (error) {
      this.emit('error', `Error hardening tool ${this.name}:`, error);
    }
  }

  public async enhanceToolCode(): Promise<void> {
    try {
      const messages = [
        {
          role: 'system',
          content: `You are a tool enhancer. You take the given Javascript and you enhance it by:
        - enhancing options and settings
        - adding functionality which will make the tool more useful
        - adding more logging and error handling
        - You output only RAW JAVASCRIPT, WITH COMMENTARY, EXPLANATION and FORMATTING.`,
        },
        {
          role: 'user',
          content: this.source,
        },
      ];
      const response = await this.registry.conversation.chat(messages);
      this.source = response.content[0].text;
      this.saveTool();
      this.emit('info', `Tool ${this.name} enhanced successfully.`);
    } catch (error) {
      this.emit('error', `Error enhancing tool ${this.name}:`, error);
    }
  }

  public async prepareFunction(): Promise<string> {
    try {
      const messages = [
        {
          role: 'system',
          content: `You prepare javascript code for execution. You take the given Javascript and you:
        - fix any broken code
        - remove any awaiters and other intermediate-output code
        - add any missing import statements
        - Do NOT export the function, just return it as a string
        - You output only RAW JAVASCRIPT, WITH COMMENTARY, EXPLANATION and FORMATTING.`,
        },
        {
          role: 'user',
          content: this.source,
        },
      ];
      const response = await this.registry.conversation.chat(messages);
      return response.content[0].text;
    } catch (error) {
      this.emit('error', `Error preparing function for tool ${this.name}:`, error);
      throw error;
    }
  }

  public async runTests(): Promise<void> {
    if (!this.testHarness) {
      this.emit('error', `No test harness found for tool ${this.name}`);
      return;
    }
    try {
      const context = {
        log: (message: string) => this.emit('info', `[${this.name} Test] ${message}`),
        assert: (condition: boolean, message: string) => {
          this.emit('info', `[${this.name} Test] ${message}`);
          if (!condition) {
            throw new Error(message);
          }
        },
      };
      const testHarness = new Function('context', `return ${this.testHarness}`)();
      await testHarness.beforeAll(context);
      for (const key in testHarness) {
        if (key !== 'beforeAll') {
          await testHarness[key](context);
        }
      }

      this.lastTestResult = {
        success: true,
        message: 'All tests passed successfully',
      };

      this.saveTool();
      this.updateMetrics('test', { success: true });
    } catch (error) {
      this.emit('error', `Error running tests for tool ${this.name}:`, error);
      this.lastTestResult = {
        success: false,
        message: `Test failed: ${error.message}`,
      };
      this.updateMetrics('test', { success: false });
    }
  }

  public async saveTool(): Promise<void> {
    try {
      const toolIndex = this.registry.registryData.tools.findIndex(t => t.name === this.name);
      if (toolIndex === -1) {
        this.emit('error', `Tool not found: ${this.name}`);
        return;
      }
      this.registry.registryData.tools[toolIndex] = this;
      this.registry.saveRegistry();
      this.emit('info', `Tool ${this.name} saved successfully.`);
    } catch (error) {
      this.emit('error', `Error saving tool ${this.name}:`, error);
    }
  }

  public async call(params: any, parent: any): Promise<any> {
    try {
      this.updateMetrics('usage', null);
      const startTime = Date.now();
      const result = await this.executor()(params, parent);
      const endTime = Date.now();
      this.updateMetrics('execution', endTime - startTime);
      return result;
    } catch (error) {
      this.updateMetrics('error', true);
      this.emit('error', `Error executing tool ${this.name}:`, error);
      throw error;
    }
  }

  public updateMetrics(updateType: 'version' | 'test' | 'execution' | 'error' | 'usage', data: any): void {
    switch (updateType) {
      case 'version':
        this.metrics.versions.push(data);
        this.metrics.totalUpdates++;
        this.metrics.lastUpdated = new Date().toISOString();
        break;
      case 'test':
        this.metrics.testResults.totalRuns++;
        if (data.success) {
          this.metrics.testResults.passed++;
        } else {
          this.metrics.testResults.failed++;
        }
        this.metrics.testResults.lastRun = new Date().toISOString();
        break;
      case 'execution':
        const executionTime = data;
        this.metrics.executionStats.totalExecutions++;
        this.metrics.executionStats.averageExecutionTime =
          (this.metrics.executionStats.averageExecutionTime * (this.metrics.executionStats.totalExecutions - 1) + executionTime) /
          this.metrics.executionStats.totalExecutions;
        this.metrics.executionStats.lastExecutionTime = executionTime;
        this.metrics.executionStats.fastestExecutionTime = Math.min(this.metrics.executionStats.fastestExecutionTime, executionTime);
        this.metrics.executionStats.slowestExecutionTime = Math.max(this.metrics.executionStats.slowestExecutionTime, executionTime);
        break;
      case 'error':
        this.metrics.errorRate = (this.metrics.errorRate * this.metrics.usageCount + (data ? 1 : 0)) / (this.metrics.usageCount + 1);
        break;
      case 'usage':
        this.metrics.usageCount++;
        break;
    }
    this.saveMetrics();
  }
}

class ToolRegistry extends EventEmitter {
  public registryData: RegistryData;
  private registryFile: string;
  private loadedTools: Set<string>;
  private repoPath: string;
  private metricsFile: string;
  private metrics: { [key: string]: any };
  private testInterval: NodeJS.Timeout;
  public conversation: Conversation;

  constructor(registryFile: string = './.registry', repoPath: string = '../../tool_repo', metricsFile: string = './.metrics') {
    super();
    const registryFileP = path.join(__dirname, repoPath, registryFile);

    if (!fs.existsSync(registryFileP)) {
      fs.mkdirSync(path.dirname(registryFileP), { recursive: true });
      fs.writeFileSync(registryFileP, JSON.stringify({ tools: [] }), 'utf8');
    }

    this.registryFile = path.join(__dirname, repoPath, registryFile);
    this.repoPath = path.join(__dirname, repoPath);
    this.metricsFile = path.join(__dirname, repoPath, metricsFile);

    this.loadedTools = new Set();
    this.registryData = { tools: [] };
    this.conversation = new Conversation('claude');
    this.metrics = {};
    this.initializeRegistry();
    this.startContinuousTesting();
  }

  async addScriptAsTool(name: string, source: string, originalQuery: string): Promise<boolean> {
    const isValid = await ScriptValidator.validate(source);
    if (!isValid) {
      console.error(`Script ${name} failed validation`);
      return false;
    }

    const success = await this.addTool(name, source, {}, ['ai-generated']);
    if (success) {
      await MetadataManager.addMetadata(this, name, {
        originalQuery,
        creationDate: new Date(),
        author: 'AI Assistant',
        version: '1.0.0',
        tags: ['ai-generated'],
        dependencies: []
      });
    }
    return success;
  }

  async executeTool(name: string, params: any): Promise<any> {
    const startTime = Date.now();
    const result = await this.call(name, params);
    const executionTime = Date.now() - startTime;
    ScriptPerformanceMonitor.recordExecution(name, executionTime);
    return result;
  }

  async call(name: string, params: any): Promise<any> {
    const tool = this.registryData.tools.find(t => t.name === name);
    if (!tool) {
      throw new Error(`Tool not found: ${name}`);
    }
    return await tool.call(params, this as any);
  }

  async performMaintenance(): Promise<void> {
    await ScriptCleanupManager.cleanupUnusedScripts(this);
    // Other maintenance tasks...
  }

  private startContinuousTesting() {
    this.testInterval = setInterval(() => {
      this.testAndImproveTools();
    }, 3600000); // Run every hour
  }

  private async testAndImproveTools() {
    for (const tool of this.registryData.tools) {
      const testResult = await this.testTool(tool);
      if (!testResult.success) {
        await this.improveTool(tool);
      }
    }
  }

  private async testTool(tool: Tool): Promise<{ success: boolean; error?: string }> {
    if (!tool.testHarness) {
      await tool.generateTestHarness();
    }
    try {
      await tool.runTests();
      return { success: tool.lastTestResult?.success || false, error: tool.lastTestResult?.message };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async improveTools(): Promise<void> {
    for (const tool of this.registryData.tools) {
      if (tool.lastTestResult && !tool.lastTestResult.success) {
        await this.improveTool(tool);
      }
    }
  }

  private async improveTool(tool: Tool): Promise<void> {
    try {
      const improvedCode = await this.conversation.chat([{
        role: 'system',
        content:
          'You are javascript developer working to improve javascript functions. Given the function\'s source code, schema, and any existing test results, <important>output an improved version of the function. If you cannot improve the function, output the original source code.</important><critical>output NO commentary, explanation or formatting</critical>',
      }, {
        role: 'user',
        content: `Tool Source: ${tool.source}\nSchema: ${JSON.stringify(tool.schema)}\nTest Results: ${JSON.stringify(tool.lastTestResult)}`,
      }], {} as any, 'gemini-1.5-flash-001');
      await this.updateTool(tool.name, improvedCode, tool.schema, tool.tags);
      this.emit('text', `Tool ${tool.name} improved based on test results`);
    } catch (error) {
      this.emit('error', `Error improving tool ${tool.name}:`, error);
    }
  }

  async updateMetrics(toolName: string, updateType: 'version' | 'test' | 'execution' | 'error' | 'usage', data: any): Promise<void> {
    if (!this.metrics[toolName]) {
      this.metrics[toolName] = {
        versions: [],
        totalUpdates: 0,
        lastUpdated: null,
        testResults: {
          totalRuns: 0,
          passed: 0,
          failed: 0,
          lastRun: null,
        },
        executionStats: {
          totalExecutions: 0,
          averageExecutionTime: 0,
          lastExecutionTime: null,
          fastestExecutionTime: Infinity,
          slowestExecutionTime: 0,
        },
        errorRate: 0,
        usageCount: 0,
      };
    }

    const metrics = this.metrics[toolName];

    switch (updateType) {
      case 'version':
        metrics.versions.push(data);
        metrics.totalUpdates++;
        metrics.lastUpdated = new Date().toISOString();
        break;
      case 'test':
        metrics.testResults.totalRuns++;
        if (data.success) {
          metrics.testResults.passed++;
        } else {
          metrics.testResults.failed++;
        }
        metrics.testResults.lastRun = new Date().toISOString();
        break;
      case 'execution':
        const executionTime = data;
        metrics.executionStats.totalExecutions++;
        metrics.executionStats.averageExecutionTime =
          (metrics.executionStats.averageExecutionTime * (metrics.executionStats.totalExecutions - 1) + executionTime) /
          metrics.executionStats.totalExecutions;
        metrics.executionStats.lastExecutionTime = executionTime;
        metrics.executionStats.fastestExecutionTime = Math.min(metrics.executionStats.fastestExecutionTime, executionTime);
        metrics.executionStats.slowestExecutionTime = Math.max(metrics.executionStats.slowestExecutionTime, executionTime);
        break;
      case 'error':
        metrics.errorRate = (metrics.errorRate * metrics.usageCount + (data ? 1 : 0)) / (metrics.usageCount + 1);
        break;
      case 'usage':
        metrics.usageCount++;
        break;
    }

    this.saveMetrics();
  }

  async generateReport(format: 'text' | 'json' = 'text'): Promise<string | object> {
    if (format === 'json') {
      return this.metrics;
    }

    let report = "Tool Registry Report\n=====================\n\n";

    for (const [toolName, toolMetrics] of Object.entries(this.metrics)) {
      report += `Tool: ${toolName}\n`;
      report += `------------------\n`;
      report += `Current Version: ${toolMetrics.versions[toolMetrics.versions.length - 1]}\n`;
      report += `Total Updates: ${toolMetrics.totalUpdates}\n`;
      report += `Last Updated: ${toolMetrics.lastUpdated}\n`;
      report += `Test Results:\n`;
      report += `  Total Runs: ${toolMetrics.testResults.totalRuns}\n`;
      report += `  Passed: ${toolMetrics.testResults.passed}\n`;
      report += `  Failed: ${toolMetrics.testResults.failed}\n`;
      report += `  Last Run: ${toolMetrics.testResults.lastRun}\n`;
      report += `Execution Stats:\n`;
      report += `  Total Executions: ${toolMetrics.executionStats.totalExecutions}\n`;
      report += `  Average Execution Time: ${toolMetrics.executionStats.averageExecutionTime.toFixed(2)}ms\n`;
      report += `  Fastest Execution Time: ${toolMetrics.executionStats.fastestExecutionTime.toFixed(2)}ms\n`;
      report += `  Slowest Execution Time: ${toolMetrics.executionStats.slowestExecutionTime.toFixed(2)}ms\n`;
      report += `  Last Execution Time: ${toolMetrics.executionStats.lastExecutionTime?.toFixed(2)}ms\n`;
      report += `Error Rate: ${(toolMetrics.errorRate * 100).toFixed(2)}%\n`;
      report += `Usage Count: ${toolMetrics.usageCount}\n\n`;
    }

    return report;
  }

  get tools(): { [key: string]: Tool } {
    return this.registryData.tools.reduce((tools, tool) => {
      tools[tool.name] = tool;
      return tools;
    }, {} as { [key: string]: Tool });
  }

  get schemas(): any {
    return this.registryData.tools.reduce((schemas, tool) => {
      schemas[tool.name] = tool.schema;
      return schemas;
    }, {} as any);
  }

  private async initializeRegistry(): Promise<void> {
    try {
      if (!fs.existsSync(this.registryFile)) {
        await this.importToolsFromFile();
      } else {
        console.log('Loading registry from file...');
        this.loadRegistry();
      }
    } catch (error) {
      console.error('Error initializing registry:', error);
      this.registryData = { tools: [] };
    }
  }

  async getToolHistory(name: string): Promise<string[]> {
    const tool = this.registryData.tools.find(t => t.name === name);
    if (!tool) {
      throw new Error(`Tool not found: ${name}`);
    }
    return this.metrics[name]?.versions || [];
  }

  private loadRegistry(): void {
    try {
      if (fs.existsSync(this.registryFile)) {
        const data = fs.readFileSync(this.registryFile, 'utf8');
        this.registryData = JSON.parse(data);
        console.log('Registry loaded successfully.');
      } else {
        this.registryData = { tools: [] };
        this.importToolsFromFile();
      }
    } catch (error) {
      console.error('Error loading registry:', error);
      this.registryData = { tools: [] };
    }
  }

  public saveRegistry(): void {
    try {
      const registryDataWithoutCircular = JSON.parse(JSON.stringify(this.registryData, (key, value) =>
        key === 'registry' || key === '_client' ? undefined : value
      ));
      const data = JSON.stringify(registryDataWithoutCircular, null, 2);
      fs.writeFileSync(this.registryFile, data, 'utf8');
      console.log('Registry saved successfully.');
    } catch (error) {
      console.error('Error saving registry:', error);
    }
  }

  private async importToolsFromFile(): Promise<void> {
    try {
      const toolsModule = await import('./tools');
      for (const [name, tool] of Object.entries(toolsModule.tools)) {
        await this.addTool(name, tool.execute.toString(), tool.schema || {}, tool.tags || []);
      }
      console.log('Tools imported from tools.ts file.');
    } catch (error) {
      console.error('Error importing tools from file:', error);
    }
  }

  public async getToolList(): Promise<Tool[]> {
    return this.registryData.tools;
  }

  public async createToolSchema(tool: string): Promise<any> {
    try {
      const messages = [{
        role: 'system',
        content: "Given the source code of a tool, you generate a schema for it. Example schema 1: { 'name': 'file', 'description': 'Performs file operations like read, write, append, prepend, replace, insert, remove, delete, copy', 'input_schema': { 'type': 'object', 'properties': { 'operation': { 'type': 'string', 'description': 'The operation to perform on the file. Supported operations: read, write, append, prepend, replace, insert_at, remove, delete, copy', 'enum': ['read', 'write', 'append', 'prepend', 'replace', 'insert_at', 'remove', 'delete', 'copy'], }, 'path': { 'type': 'string', 'description': 'The path to the file. Required for all operations except 'list_attached'.', }, 'match': { 'type': 'string', 'description': 'The string or regex pattern to match. Required for 'replace' and 'remove' operations.', }, 'data': { 'type': 'string', 'description': 'The data to write, append, prepend, replace, or insert. Required for 'write', 'append', 'prepend', 'replace', and 'insert_at' operations.', }, 'position': { 'type': 'number', 'description': 'The position to insert the data at. Required for 'insert_at' operation.', }, 'target': { 'type': 'string', 'description': 'The target path for the 'copy' operation.', }, }, 'required': ['operation'], }, 'output_schema': { 'type': 'string', 'description': 'A message indicating the result of the file operation.', }, }\n\nExample Schema 2: {'name': 'files', 'description': 'Performs batch file operations.', 'input_schema': {'type': 'object', 'properties': {'operations': {'type': 'array', 'description': 'An array of file operations to perform.', 'items': {'type': 'object', 'properties': {'operation': {'type': 'string', 'description': 'The operation to perform on the file.', 'enum': ['read', 'append', 'prepend', 'replace', 'insert_at', 'remove', 'delete', 'copy', 'attach', 'list_attached', 'detach']}, 'path': {'type': 'string', 'description': 'The path to the file. Required for all operations except 'list_attached'.', }, 'match': {'type': 'string', 'description': 'The string or regex pattern to match. Required for 'replace' and 'remove' operations.', }, 'data': {'type': 'string', 'description': 'The data to write, append, prepend, replace, or insert. Required for 'write', 'append', 'prepend', 'replace', and 'insert_at' operations.', }, 'position': {'type': 'number', 'description': 'The position to insert the data at. Required for 'insert_at' operation.', }, 'target': {'type': 'string', 'description': 'The target path for the 'copy' operation.', }, }, 'required': ['operation']}}}, 'required': ['operations']}, 'output_schema': {'type': 'string', 'description': 'A message indicating the result of the batch file operations.'}},",
      }, {
        role: 'user',
        content: 'Examine the source code of the tool and generate a schema for it: ' + JSON.stringify(tool)
      }];
      const response = await this.conversation.chat(messages);
      return JSON.parse(response.content[0].text);
    } catch (error) {
      console.error(`Error creating schema for tool ${tool}:`, error);
      throw error;
    }
  }

  public async cleanupToolCode(tool: string): Promise<string> {
    try {
      const messages = [{
        role: 'system',
        content: `You take the given Javascript and you:

1. fix any broken code, 
2. rewrite the function to remove awaiters and other intermediate-output code 
3. add any missing import statements - for example use \`const fs = await import('fs');\` for file system operations
4. Do NOT export the function, just return it as a string
5. FORMAT THE FUNCTION NICELY OVER MULTIPLE LINES

You output only RAW JAVASCRIPT, WITHOUT ANY COMMENTARY, EXPLANATION or FORMATTING`
      }, {
        role: 'user',
        content: tool
      }];
      let response = await this.conversation.chat(messages);
      response = response.content[0].text;
      response = response.replace(/.*```javascript/g, '');
      response = response.replace(/.*```/g, '');
      response = response.replace(/[\r\n]+/g, '');
      return response;
    } catch (error) {
      console.error(`Error cleaning up tool code for ${tool}:`, error);
      throw error;
    }
  }

  public async addToolSchema(tool: string, schema: any): Promise<boolean> {
    try {
      const toolIndex = this.registryData.tools.findIndex(t => t.name === tool);
      if (toolIndex === -1) {
        console.error(`Tool not found: ${tool}`);
        return false;
      }
      this.registryData.tools[toolIndex].schema = schema;
      this.saveRegistry();
      console.log(`Schema added for tool ${tool}`);
      return true;
    } catch (error) {
      console.error(`Error adding schema to tool ${tool}:`, error);
      return false;
    }
  }

  async loadTool(name: string): Promise<any | null> {
    try {
      if (this.loadedTools.has(name)) {
        console.log(`Tool ${name} already loaded.`);
        return null;
      }

      const tool = this.registryData.tools.find(t => t.name === name);
      if (!tool) {
        console.error(`Tool not found: ${name}`);
        return null;
      }

      const toolModule = await import(`${this.repoPath}/${name}.js`);
      this.loadedTools.add(name);
      console.log(`Tool ${name} loaded successfully.`);
      return toolModule.default;
    } catch (error) {
      console.error(`Error loading tool ${name}:`, error);
      return null;
    }
  }

  async updateTool(name: string, source: string, schema: any, tags: any): Promise<boolean> {
    try {
      const toolIndex = this.registryData.tools.findIndex(t => t.name === name);
      if (toolIndex === -1) {
        console.error(`Tool not found: ${name}`);
        return false;
      }

      const tool: Tool = this.registryData.tools[toolIndex];
      const newVersion = this.incrementVersion(tool.version);

      tool.version = newVersion;
      tool.tags = tags;
      tool.active = true;
      this.saveRegistry();

      if ((schema && schema !== tool.schema) || source) {
        source && (tool.source = source);
        schema && (tool.schema = schema);

        if (schema) {
          // Save schema to metadata
          const metadata: any = await MetadataManager.getMetadata(this, name);
          metadata.schema = schema;

          await MetadataManager.updateMetadata(this, name, metadata);
        }

        // re-run tests
        await tool.generateTestHarness();

        // Update metrics
        this.updateMetrics(name, 'version', newVersion);
      }

      await this.saveToolToRepo(name, source, newVersion);
      console.log(`Tool ${name} updated to version ${newVersion}.`);
      this.updateMetrics(name, 'version', newVersion);
      return true;
    } catch (error) {
      console.error(`Error updating tool ${name}:`, error);
      return false;
    }
  }

  validateToolInput(toolName: string, params: any): { valid: boolean; errors: any[] } {
    const tool = this.tools[toolName];
    if (!tool || !tool.schema) {
      return { valid: true, errors: [] };
    }
    // Implement input validation logic here
    return { valid: true, errors: [] };
  }

  private async saveToolToRepo(name: string, source: string, version: string): Promise<void> {
    try {
      const filePath = path.join(this.repoPath, `${name}.js`);
      fs.mkdirSync(path.dirname(filePath), { recursive: true });
      fs.writeFileSync(filePath, source);
      console.log(`Tool ${name} v${version} saved to repository successfully.`);
    } catch (error) {
      console.error(`Error saving tool ${name} to repository:`, error);
    }
  }

  async callTool(name: string, params: any): Promise<any> {
    const tool = this.tools[name];
    if (!tool) throw new Error(`Tool not found: ${name}`);
  
    try {
      const startTime = Date.now();
      const toolModule = await import(tool.path);
      const result = await toolModule.default(params, this);
      const endTime = Date.now();
      const executionTime = endTime - startTime;
      this.updateMetrics(name, 'execution', executionTime);
    } catch (error) {
      console.error(`Error executing tool ${name}:`, error);
      throw error;
    }
  }

  // async callTool(name: string, params: any): Promise<any> {
  //   try {
  //     const tool = this.registryData.tools.find(t => t.name === name);
  //     if (!tool) {
  //       throw new Error(`Tool not found: ${name}`);
  //     }

  //     const startTime = Date.now();
  //     const toolModule = await import(tool.path);
  //     const result = await toolModule.default.execute(params, this);
  //     const endTime = Date.now();
  //     const executionTime = endTime - startTime;
  //     this.updateMetrics(name, 'execution', executionTime);
  //     return result;
  //   } catch (error) {
  //     console.error(`Error executing tool ${name}:`, error);
  //     throw error;
  //   }
  // }

  async getTool(scriptOrName: string): Promise<Tool | null> {
    // First, try to find the tool by name
    const tool = this.tools[scriptOrName];
    if (tool) return tool;
  
    // If not found by name, check if any tool's source matches the script
    for (const t of Object.values(this.tools)) {
      if (t.source === scriptOrName) return t;
    }
  
    return null;
  }

  async rollbackTool(name: string, version: string): Promise<boolean> {
    try {
      const toolIndex = this.registryData.tools.findIndex(t => t.name === name);
      if (toolIndex === -1) {
        this.emit('error', `Tool not found: ${name}`);
        return false;
      }

      const source = await this.getTool(name);
      if (!source) {
        this.emit('error', `Source code not found for tool ${name} version ${version}`);
        return false;
      }

      const tool = this.registryData.tools[toolIndex];
      tool.version = version;
      tool.source = tool.source
      tool.active = true;
      this.saveRegistry();

      this.emit('text', `Tool ${name} rolled back to version ${version} successfully.`);
      this.updateMetrics(name, 'version', version);
      return true;
    } catch (error) {
      this.emit('error', `Error rolling back tool ${name}:`, error);
      return false;
    }
  }

  private incrementVersion(version: string): string {
    const [major, minor, patch] = version.split('.').map(Number);
    return `${major}.${minor}.${patch + 1}`;
  }

  async getToolTags(name: string): Promise<string[]> {
    const tool = this.registryData.tools.find(t => t.name === name);
    return tool ? tool.tags || [] : [];
  }

  async initialize(): Promise<void> {
    await this.initializeRegistry();
    this.loadMetrics();
    for (const tool of this.registryData.tools) {
      await this.loadTool(tool.name);
    }
    await this.generateAndRunTests();
  }

  getCompactRepresentation(): any {
    // schema.methodSignature - description
    return this.registryData.tools.map(tool => `${tool.schema.methodSignature} - ${tool.schema.description}`).join('\n');
  }

  async createNewToolWithLLM(
    description: string,
    schema: any,
    constraints: string[]
  ): Promise<Tool | null> {
    try {
      let toolCode = await this.conversation.chat([{
        role: 'system',
        content: `You create Javascript functions given a set of instructions. 
You will be given a description, a schema, and a set of constraints. 
Generate the JavaScript code for a tool that fulfills the requirements while observing the constraints..
Return a JSON object with the following format: { "name": "function_name", "description": "Brief description", "methodSignature": "function_name(param1: type, param2: type): returnType", "source": "function function_name(param1, param2) { ... }" }
You output only RAW JAVASCRIPT, WITHOUT ANY COMMENTARY, EXPLANATION or FORMATTING`
      }, {
        role: 'user',
        content: `Description: ${description}\nSchema: ${JSON.stringify(
          schema
        )}\nConstraints: ${constraints.join(', ')}`
      }], {} as any, 'gemini-1.5-flash-001');
      toolCode = toolCode.content[0].text;
      const { name, methodSignature } = JSON.parse(toolCode);

      await this.addTool(name, toolCode, schema, []);

      const toolName = schema.name;
      const success = await this.addTool(
        toolName,
        toolCode,
        schema,
        []
      );
      if (success) {
        this.emit('text', `Tool ${toolName} created successfully.`);
        return this.tools[toolName];
      } else {
        this.emit('error', 'Failed to add the generated tool to the registry.');
        return null;
      }
    } catch (error) {
      this.emit('error', 'Error creating tool with LLM:', error);
      return null;
    }
  }

  async generateAndRunTests(): Promise<void> {
    for (const tool of this.registryData.tools) {
      // load a real Tool instance
      const ttool = new Tool(this, tool.name, tool.version, tool.description, tool.source, tool.tags, tool.schema);
      await ttool.generateTestHarness();
      try {
        await ttool.runTests();
      } catch (error) {
        this.emit('text', `Error running tests for tool ${tool.name}:`, error);
      }
    }
  }

  async analyzeAndCreateToolFromScript(script: string, taskDescription: string): Promise<void> {
    const existingTools = await this.getToolList();
    const existingToolNames = existingTools.map(tool => tool.name);

    const analysisPrompt = `
        Given the following script and task description, determine if this script represents a unique and reusable functionality not adequately covered by existing tools.
  
        Existing tools: ${existingToolNames.join(', ')}
  
        Script:
        ${script}
  
        Task Description:
        ${taskDescription}
  
        If this script represents a unique and reusable functionality, provide the following in JSON format:
        1. A semantically-meaningful function name
        2. A brief description of the tool's functionality
        3. A method signature
        4. Any necessary modifications to make the script more generalized and reusable
  
        If the functionality is already adequately represented by existing tools, return null.
  
        Response format:
        {
          "name": "function_name",
          "description": "Brief description",
          "methodSignature": "function_name(param1: type, param2: type): returnType",
          "modifiedScript": "// Modified script code"
        }
      `;

    const analysisResult = await this.conversation.chat([{
      role: 'system',
      content: 'You are an AI assistant tasked with analyzing scripts and creating reusable tools.',
    }, {
      role: 'user',
      content: analysisPrompt,

    }]);

    if (analysisResult) {
      const { name, description, methodSignature, modifiedScript } = analysisResult;
      const schema = {
        name,
        description,
        methodSignature
      };

      await this.addAutoGeneratedTool(name, modifiedScript, schema);
    }
  }

  async addAutoGeneratedTool(name: string, source: string, schema: any): Promise<boolean> {
    const similarTool = this.registryData.tools.find(tool =>
      tool.name.toLowerCase().includes(name.toLowerCase()) ||
      name.toLowerCase().includes(tool.name.toLowerCase())
    );

    if (similarTool) {
      console.log(`Similar tool '${similarTool.name}' already exists. Skipping addition.`);
      return false;
    }

    return this.addTool(name, source, schema, ['auto-generated']);
  }

  async reviewAutoGeneratedTools(): Promise<void> {
    const autoGeneratedTools = this.registryData.tools.filter(tool => tool.tags.includes('auto-generated'));

    for (const tool of autoGeneratedTools) {
      const reviewPrompt = `
  Review the following auto-generated tool and determine if it should be kept, modified, or removed:
  
  Name: ${tool.name}
  Description: ${tool.schema.description}
  Method Signature: ${tool.schema.methodSignature}
  Source:
  ${tool.source}
  
  Provide your recommendation in JSON format:
  {
    "action": "keep" | "modify" | "remove",
    "reason": "Brief explanation",
    "modifications": "If action is 'modify', provide the modified source code here"
  }
  `;

      const reviewResult = await this.conversation.chat([{
        role: 'system',
        content: 'You are an AI assistant tasked with reviewing and maintaining the tool registry within which you operate.',
      }, {
        role: 'user',
        content: reviewPrompt
      }], {
        responseFormat: '{ "action": "string", "reason": "string", "modifications": "string" }[]'
      } as any);

      switch (reviewResult.action) {
        case 'keep':
          console.log(`Tool '${tool.name}' kept. Reason: ${reviewResult.reason}`);
          break;
        case 'modify':
          await this.updateTool(tool.name, reviewResult.modifications, tool.schema, tool.tags);
          console.log(`Tool '${tool.name}' modified. Reason: ${reviewResult.reason}`);
          break;
        case 'remove':
          await this.removeTool(tool.name);
          console.log(`Tool '${tool.name}' removed. Reason: ${reviewResult.reason}`);
          break;
      }
    }
  }

  async removeTool(name: string): Promise<boolean> {
    const initialLength = this.registryData.tools.length;
    this.registryData.tools = this.registryData.tools.filter(tool => tool.name !== name);
    const removed = this.registryData.tools.length < initialLength;
    if (removed) {
      this.saveRegistry();
      console.log(`Tool '${name}' removed successfully.`);
    }
    return removed;
  }

  async addTool(name: string, source: string, schema: any, tags: string[]): Promise<boolean> {
    try {
      if (this.registryData.tools.some(t => t.name === name)) {
        return false;
      }

      let standardizedSource = source;
      try {
        standardizedSource = await this.standardizeTool(name, source, schema);
      } catch (error) {
        console.warn(`Failed to standardize tool ${name}. Using original source.`, error);
      }

      const version = '1.0.0';
      const newTool = new Tool(this, name, version, schema.description, standardizedSource, tags, schema);

      this.registryData.tools.push(newTool);
      this.saveRegistry();

      await this.saveToolToRepo(name, standardizedSource, version);
      console.log(`Tool ${name} added successfully.`);
      return true;
    } catch (error) {
      console.error(`Error adding tool ${name}:`, error);
      return false;
    }
  }

  async performPeriodicMaintenance(): Promise<void> {
    await this.reviewAutoGeneratedTools();
    await this.improveTools();
    // Add any other maintenance tasks here
  }

  private loadMetrics(): void {
    try {
      if (fs.existsSync(this.metricsFile)) {
        const data = fs.readFileSync(this.metricsFile, 'utf8');
        this.metrics = JSON.parse(data);
        console.log('Metrics loaded successfully.');
      } else {
        this.metrics = {};
      }
    } catch (error) {
      console.error('Error loading metrics:', error);
      this.metrics = {};
    }
  }

  private saveMetrics(): void {
    try {
      const data = JSON.stringify(this.metrics, null, 2);
      fs.writeFileSync(this.metricsFile, data, 'utf8');
      console.log('Metrics saved successfully.');
    } catch (error) {
      console.error('Error saving metrics:', error);
    }
  }

  private initializeMetrics(toolName: string): void {
    if (!this.metrics[toolName]) {
      this.metrics[toolName] = {
        versions: [],
        totalUpdates: 0,
        lastUpdated: new Date().toISOString(),
        testResults: {
          totalRuns: 0,
          passed: 0,
          failed: 0,
          lastRun: null,
        },
        executionStats: {
          totalExecutions: 0,
          averageExecutionTime: 0,
          lastExecutionTime: null,
          fastestExecutionTime: Infinity,
          slowestExecutionTime: 0,
        },
        errorRate: 0,
        usageCount: 0,
      };
    }
  }

  async standardizeTool(name: string, source: string, schema: any): Promise<string> {
    const systemMessage = {
      role: 'system',
      content: `You are an AI assistant tasked with standardizing tool code into a specific module format. Use the template below, incorporating the given code into the execute function. Fix any obvious issues and ensure the code is properly formatted and exported.
Template:

import { Tool } from '../src/assistant/tool-base';

class ${name}Tool extends BaseTool {
  constructor() {
    super('${name}', '${schema.description}');
  }

  async execute(params, api) {
    // Tool implementation goes here
  }
}

export default new ${name}Tool();`
    };
    const userMessage = {
      role: 'user',
      content: `Original Tool Code:
${source}

Schema:
${JSON.stringify(schema, null, 2)}
  
Please provide the complete standardized tool module code, including the class definition and export.
<critical>DO NOT include any commentary, explanation, or formatting. YOUR OUTPUT SHOULD BE RAW Javascript Code</critical>`,
    }
    let response = await this.conversation.chat([systemMessage, userMessage]);
    return response.content[0].text;
  }

  async predictLikelyTools(userRequest: string): Promise<string[]> {
    const existingTools = await this.getToolList();
    const existingToolNames = existingTools.map(tool => tool.name);

    const prompt = `Given the following user request and list of existing tools, predict the most likely tools to be used and suggest new tools that need to be created to service the task.
  
User Request: ${userRequest}

Existing Tools: ${existingToolNames.join(', ')}

Provide your response in the following JSON format:
{
  "likelyTools": ["tool1", "tool2", ...],
  "newTools": ["newTool1", "newTool2", ...]
}
      `;

    const response = await this.conversation.chat([{
      role: 'system',
      content: 'You are an AI assistant tasked with predicting and suggesting tools for a given task.',
    }, {
      role: 'user',
      content: prompt
    }], {
      responseFormat: '{ "likelyTools": string[], "newTools": string[] }'
    } as any);

    return [...response.likelyTools, ...response.newTools];
  }
}

export default ToolRegistry;

export const toolRegistryTools = {
  list_tools: {
    name: 'list_tools',
    version: '1.1.0',
    description: 'List all tools in the registry, optionally filtered by tags',
    schema: {
      type: 'object',
      properties: {
        tags: { type: 'array', items: { type: 'string' }, description: 'Optional tags to filter tools' }
      }
    },
    execute: async (params: { tags?: string[] }, api: ToolRegistry) => {
      const allTools = await api.getToolList();
      if (params.tags && params.tags.length > 0) {
        return allTools.filter(tool => params.tags!.every(tag => tool.tags.includes(tag)));
      }
      return allTools;
    }
  },

  add_tool: {
    name: 'add_tool',
    version: '1.2.0',
    description: 'Add a new tool to the registry',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' },
        source: { type: 'string', description: 'Source code of the tool' },
        description: { type: 'string', description: 'Description of the tool' },
        tags: { type: 'array', items: { type: 'string' }, description: 'Tags for the tool' },
        schema: { type: 'object', description: 'Schema for the tool' },
        originalQuery: { type: 'string', description: 'Original query that led to the creation of this tool' }
      },
      required: ['name', 'source', 'description']
    },
    execute: async (params: any, api: ToolRegistry) => {
      const isValid = await ScriptValidator.validate(params.source);
      if (!isValid) {
        throw new Error('Tool validation failed');
      }
      const success = await api.addTool(params.name, params.source, params.schema || {}, params.tags || []);
      if (success) {
        await MetadataManager.addMetadata(api, params.name, {
          originalQuery: params.originalQuery || '',
          creationDate: new Date(),
          author: 'User',
          version: '1.0.0',
          tags: params.tags || [],
          dependencies: []
        });
      }
      return success;
    }
  },

  update_tool: {
    name: 'update_tool',
    version: '1.1.0',
    description: 'Update an existing tool in the registry',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool to update' },
        source: { type: 'string', description: 'New source code of the tool' },
        description: { type: 'string', description: 'New description of the tool' },
        tags: { type: 'array', items: { type: 'string' }, description: 'New tags for the tool' },
        schema: { type: 'object', description: 'New schema for the tool' }
      },
      required: ['name', 'source']
    },
    execute: async (params: any, api: ToolRegistry) => {
      const isValid = await ScriptValidator.validate(params.source);
      if (!isValid) {
        throw new Error('Tool validation failed');
      }
      return api.updateTool(params.name, params.source, params.schema, params.tags);
    }
  },

  delete_tool: {
    name: 'delete_tool',
    version: '1.0.0',
    description: 'Delete a tool from the registry',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool to delete' }
      },
      required: ['name']
    },
    execute: async (params: { name: string }, api: ToolRegistry) => {
      return api.removeTool(params.name);
    }
  },

  get_tool_metadata: {
    name: 'get_tool_metadata',
    version: '1.0.0',
    description: 'Get metadata for a specific tool',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' }
      },
      required: ['name']
    },
    execute: async (params: { name: string }, api: ToolRegistry) => {
      return MetadataManager.getMetadata(api, params.name);
    }
  },

  update_tool_metadata: {
    name: 'update_tool_metadata',
    version: '1.0.0',
    description: 'Update metadata for a specific tool',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' },
        metadata: { type: 'object', description: 'New metadata for the tool' }
      },
      required: ['name', 'metadata']
    },
    execute: async (params: { name: string, metadata: Partial<ScriptMetadata> }, api: ToolRegistry) => {
      await MetadataManager.addMetadata(api, params.name, params.metadata);
      return true;
    }
  },

  get_tool_performance: {
    name: 'get_tool_performance',
    version: '1.0.0',
    description: 'Get performance metrics for a specific tool',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' }
      },
      required: ['name']
    },
    execute: async (params: { name: string }, api: ToolRegistry) => {
      return ScriptPerformanceMonitor.getMetrics(params.name);
    }
  },

  get_all_performance_metrics: {
    name: 'get_all_performance_metrics',
    version: '1.0.0',
    description: 'Get performance metrics for all tools',
    schema: {},
    execute: async (params: {}, api: ToolRegistry) => {
      return ScriptPerformanceMonitor.getAllMetrics();
    }
  },

  run_maintenance: {
    name: 'run_maintenance',
    version: '1.0.0',
    description: 'Run maintenance tasks on the tool registry',
    schema: {},
    execute: async (params: {}, api: ToolRegistry) => {
      await api.performMaintenance();
      return 'Maintenance tasks completed';
    }
  },

  analyze_and_create_tool: {
    name: 'analyze_and_create_tool',
    version: '1.1.0',
    description: 'Analyze a script and create a new tool if it represents unique functionality',
    schema: {
      type: 'object',
      properties: {
        script: { type: 'string', description: 'The script to analyze' },
        taskDescription: { type: 'string', description: 'Description of the task the script performs' }
      },
      required: ['script', 'taskDescription']
    },
    execute: async (params: { script: string, taskDescription: string }, api: ToolRegistry) => {
      await api.analyzeAndCreateToolFromScript(params.script, params.taskDescription);
      return 'Analysis and tool creation completed';
    }
  },

  predict_likely_tools: {
    name: 'predict_likely_tools',
    version: '1.0.0',
    description: 'Predict likely tools to be used for a given task',
    schema: {
      type: 'object',
      properties: {
        userRequest: { type: 'string', description: 'The user request to analyze' }
      },
      required: ['userRequest']
    },
    execute: async (params: { userRequest: string }, api: ToolRegistry) => {
      return api.predictLikelyTools(params.userRequest);
    }
  },

  get_tool_history: {
    name: 'get_tool_history',
    version: '1.0.0',
    description: 'Get the version history of a specific tool',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' }
      },
      required: ['name']
    },
    execute: async (params: { name: string }, api: ToolRegistry) => {
      return api.getToolHistory(params.name);
    }
  },

  rollback_tool: {
    name: 'rollback_tool',
    version: '1.0.0',
    description: 'Rollback a tool to a previous version',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' },
        version: { type: 'string', description: 'Version to rollback to' }
      },
      required: ['name', 'version']
    },
    execute: async (params: { name: string, version: string }, api: ToolRegistry) => {
      return api.rollbackTool(params.name, params.version);
    }
  },

  generate_tool_report: {
    name: 'generate_tool_report',
    version: '1.0.0',
    description: 'Generate a comprehensive report about the tool registry',
    schema: {
      type: 'object',
      properties: {
        format: { type: 'string', enum: ['text', 'json'], description: 'Output format of the report' }
      }
    },
    execute: async (params: { format?: 'text' | 'json' }, api: ToolRegistry) => {
      return api.generateReport(params.format || 'text');
    }
  }
};
.//assistant/tools.ts

// tools.ts
// tools.ts
import 'dotenv/config';
import shell from 'shelljs';
import Conversation from './conversation';
import validator from 'validator';
import * as fs from 'fs/promises'; // Use fs.promises for async/await
import ajv from 'ajv';
import { text } from 'blessed';

const jsonSchemaValidator = new ajv();

async function jsonValidator(
  jsonSchema: string,
  jsonData: string,
): Promise<boolean> {
  try {
    const schema = JSON.parse(jsonSchema);
    const data = JSON.parse(jsonData);
    const validate = jsonSchemaValidator.compile(schema);
    const valid = validate(data);
    return valid;
  } catch (error) {
    return false;
  }
}


// Generic error handling function for file system operations
async function handleFileError(context: any, api: any) {
  const logError = (message: string, level: string = 'error') => {
   api.emit('error', `[${level.toUpperCase()}] ${message} `);
  };

  logError(`File operation error: ${JSON.stringify(context)} `);

  const llmResponse = await api.callTool('callLLM', {
   system_prompt: 'Analyze the file operation error and suggest a fix.',
   prompt: JSON.stringify(context),
  });

  if (llmResponse.fix) {
   logError(`Attempting LLM fix: ${llmResponse.fix} `, 'debug');
   try {
    // Attempt to apply the LLM's fix (make sure it's safe!)
    // ... (Implement safe fix application logic here)
   } catch (fixError: any) {
    logError(`LLM fix attempt failed: ${fixError.message} `, 'error');
   }
  }

  // Safe Fallback:
  if (context.errorCode === 'ENOENT') {
   logError('File not found. Suggest creating the file or checking the path.', 'info');
   // ... (Implement logic to suggest file creation or path correction)
  } else {
   logError(`Unhandled file error code: ${context.errorCode} `, 'error');
   // ... (Handle other error codes with appropriate fallbacks)
  }
}

export const tools: { [key: string]: any } = {
'files': {
   'name': 'files',
   'version': '1.0.0',
   'description': 'Performs batch file operations.',
   'schema': {
    'name': 'files',
    'description': 'Performs batch file operations.',
    'input_schema': {
     'type': 'object',
     'properties': {
      'operations': {
       'type': 'array',
       'description': 'An array of file operations to perform.',
       'items': {
        'type': 'object',
        'properties': {
         'operation': {
          'type': 'string',
          'description': 'The operation to perform on the file.',
          'enum': ['read', 'append', 'prepend', 'replace', 'insert_at', 'remove', 'delete', 'copy', 'attach', 'list_attached', 'detach'],
         },
         'path': {
          'type': 'string',
          'description': "The path to the file. Required for all operations except 'list_attached'.",
         },
         'match': {
          'type': 'string',
          'description': "The string or regex pattern to match. Required for 'replace' and 'remove' operations.",
         },
         'data': {
          'type': 'string',
          'description': "The data to write, append, prepend, replace, or insert. Required for 'write', 'append', 'prepend', 'replace', and 'insert_at' operations.",
         },
         'position': {
          'type': 'number',
          'description': "The position to insert the data at. Required for 'insert_at' operation.",
         },
         'target': {
          'type': 'string',
          'description': "The target path for the 'copy' operation.",
         },
        },
        'required': ['operation'],
       },
      },
     },
     'required': ['operations'],
    },
    'output_schema': {
     'type': 'string',
     'description': 'A message indicating the result of the batch file operations.',
    },
   },
   execute: async function ({ operations }: any, run: any) {
    try {
     const fs = require('fs');
     const pathModule = require('path');
     const cwd = process.cwd();
     for (const { operation, path, match, data, position, target } of operations) {
      const p = pathModule.join(cwd, path || '');
      const t = pathModule.join(cwd, target || '');
      if (!fs.existsSync(p || t)) {
       return `Error: File not found at path ${p || t} `;
      }
      let text = fs.readFileSync(p, 'utf8');
      switch (operation) {
       case 'read':
        return text;
       case 'append':
        text += data;
        break;
       case 'prepend':
        text = data + text;
        break;
       case 'replace':
        text = text.replace(match, data);
        break;
       case 'insert_at':
        text = text.slice(0, position) + data + text.slice(position);
        break;
       case 'remove':
        text = text.replace(match, '');
        break;
       case 'delete':
        fs.unlinkSync(p);
        break;
       case 'copy':
        fs.copyFileSync(p, t);
        break;
       default:
        return `Error: Unsupported operation ${operation} `;
      }
      fs.writeFileSync(p, text);
     }
     return `Successfully executed batch operations on files`;
    } catch (error: any) {
     const context = {
      errorCode: error.code,
      operations: operations,
      // ... other details
     };
     await handleFileError(context, run);
     return `File operation '${operations}' failed. Check logs for details.`;
    }
   },
  }, 
  'get_file_tree': {
    'name': 'get_file_tree',
    'version': '1.0.0',
    'description': 'Retrieves the file tree structure from the given path.',
    'schema': {
      'name': 'get_file_tree',
      'description': 'Retrieves the file tree structure from the given path.',
      'methodSignature': 'get_file_tree(value: string, n: number): object',
    },
    execute: async ({ value, n }: any, state: any) => {
      const fs = require('fs');
      const pathModule = require('path');
      const cwd = process.cwd();
      const explore = (dir: any, depth: any) => {
        dir = pathModule.join(cwd, dir || '');
        if (depth < 0) return null;
        const directoryTree: any = { path: dir, children: [] };
        try {
          const fsd = fs.readdirSync(dir, { withFileTypes: true });
          fsd.forEach((dirent: any) => {
            const fullPath = pathModule.join(dir, dirent.name); // Use pathModule instead of path
            // ignore node_modules and .git directories
            if (dirent.isDirectory() && (dirent.name === 'node_modules' || dirent.name === '.git')) return;
            if (dirent.isDirectory()) {
              directoryTree.children.push(explore(fullPath, depth - 1));
            } else {
              directoryTree.children.push({ path: fullPath });
            }
          });
        } catch (e: any) {
          return e.message;
        }
        return directoryTree;
      };
      return explore(value, n);
    },
  },
  'say_aloud': {
    'name': 'say_aloud',
    'version': '1.0.0',
    'description': 'Speaks the given text aloud using PlayHT. PASS IN A text and voice PARAMETERS TO SPEAK ALOUD.',
    'schema': {
      'name': 'say_aloud',
      'description': 'Speaks the given text aloud using PlayHT. PASS IN A text and voice PARAMETERS TO SPEAK ALOUD. voice can be either \'male\' or \'female\'.',
      'methodSignature': 'say_aloud({text, voice}:{string, string}): string',
    },
    execute: async (params: any, api: any) => {
      const PlayHT = require('playht');
      const fs = require('fs');
      var player = require('play-sound')({});

      const apiKey = process.env.PLAYHT_AUTHORIZATION;
      const userId = process.env.PLAYHT_USER_ID;
      const maleVoice = process.env.PLAYHT_MALE_VOICE;
      const femaleVoice = process.env.PLAYHT_FEMALE_VOICE;

      // Initialize PlayHT API
      PlayHT.init({
        apiKey: apiKey,
        userId: userId,
      });
      function getNonce() {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      }

      async function speakSentence(sentence: string, voice: string) {
        if (!sentence) return;
        const stream = await PlayHT.stream(sentence, {
          voiceEngine: 'PlayHT2.0-turbo',
          voiceId: voice === 'male' ? maleVoice : femaleVoice,
        });
        const chunks: any = [];
        stream.on('data', (chunk: any) => chunks.push(chunk));

        return new Promise((resolve, reject) => {
          stream.on('end', () => {
            const buf = Buffer.concat(chunks);
            // save the audio to a file
            const filename = `${getNonce()}.mp3`;
            fs.writeFileSync(filename, buf);
            player.play(
              filename,
              function (err: any) {
                fs.unlinkSync(filename);
                resolve('done');
              },
            );
          });
        });
      }

      if (!Array.isArray(params)) params = [params];
      for (const param of params) {
        // if params is a string, convert it to an object
        let { text, voice } = param;
        voice = voice || 'female';
        if (!text) throw new Error('Text is required to speak aloud');
        if (!voice) throw new Error('Voice is required to speak aloud');

        let sentences = await api.callTool('callLLM', {
          system_prompt:
            'convert the following text into a number of sentences meant to be spoken aloud. This means breaking the text into sentences that are easy to read and understand as well as phonetically pronouncing any difficult words, urls, or acronyms. *** Return your response as a RAW JSON ARRAY of strings. ***',
          prompt: text,
          responseFormat: `string[]`,
        });
        sentences = sentences instanceof Array ? sentences : JSON.parse(sentences);
        const consumeSentence = async () => {
          return new Promise((resolve, reject) => {
            const loop: any = async () => {
              const sentence = sentences.shift();
              if (!sentence) return resolve('done');
              await speakSentence(sentence, voice);
              return await loop();
            };
            return loop();
          });
        };
        await consumeSentence();
  
      }

      return '(aloud) ' + text;
    },
  },
  pause: {
    'name': 'pause',
    'version': '1.0.0',
    'description': 'Pause execution for the specified duration.',
    'schema': {
      'name': 'pause',
      'description': 'Pause execution for the specified duration.',
      "methodSignature": "pause(duration: number): void",
    },
    execute: async ({ duration }: any) => {
      return await new Promise((resolve) => setTimeout(resolve, duration));
    },
  },  
  echo: {
    'name': 'echo',
    'version': '1.0.0',
    'description': 'Print the given text to the console',
    'schema': {
      'name': 'echo',
      'description': 'Print the given text to the console',
      'input_schema': {
        'type': 'object',
        'properties': {
          'text': {
            'type': 'string',
            'description': 'The text to print',
          },
        },
        'required': ['text'],
      },
    },
    execute: async ({ text }: any, api: any) => {
      api.emit('text', text);
      return text;
    },
  },
  callLLM: {
    'name': 'callLLM',
    'version': '1.0.0',
    'description': 'Call the LLM with the given system prompt and prompt, optionally specifying the model and response format and setting a result variable.',
    'schema': {
      'name': 'callLLM',
      "methodSignature": "callLLM(params: { prompt: string, system_prompt?: string, model?: string, responseFormat?: string, resultVar?: string }[]): any",
      'description': 'Call the LLM with the given system prompt and prompt, optionally specifying the model and response format and setting a result variable.',
    },
    execute: async (params: any, api: any) => {
      if (!Array.isArray(params)) params = [params];
      for (const param of params) {
        let { prompt, system_prompt, model, responseFormat, resultVar } = param;
        try {
          if (!prompt) {
            throw new Error("Both 'prompt' and 'system_prompt' are required parameters for the 'callLLM' tool.");
          }
          if (!system_prompt) system_prompt = prompt;
          model = model || 'claude';
          if (model !== 'claude' && model !== 'gemini') {
            throw new Error("Invalid model specified. Choose either 'claude' or 'gemini'.");
          }
          if (responseFormat) {
            system_prompt = `${system_prompt}. Response Format: You MUST respond with a JSON - encoded string in the following format: \n\`\`\`typescript\n${responseFormat}\n\`\`\`\n`;
          }
          const convo = new Conversation(model);
          const response = await convo.chat([
            {
              role: 'system',
              content: system_prompt,
            },
            {
              role: 'user',
              content: prompt,
            },
          ]);

          const data = response.content[0].text.trim();

          // Validate JSON structure before parsing
          if (responseFormat) {
            try {
              const isValidJson = jsonValidator(responseFormat, data);
              if (!isValidJson) {
                throw new Error('Invalid JSON structure in LLM response. Actual response: ' + data) + ' Expected response format: ' + responseFormat;
              }

              const rr = JSON.parse(data);
              if (resultVar) {
                api.store[resultVar] = rr;
              }
              return rr;
            } catch (error: any) {
              api.emit('error', `JSON parsing failed for LLM response: ${data}`);
              if (resultVar) {
                api.store[resultVar] = data;
              }
              return data;
            }
          } else {
            if (resultVar) {
              api.store[resultVar] = data;
            }
            return data;
          }
        } catch (error: any) {
          const llmResponse = await api.callTool('callLLM', {
            system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
            prompt: JSON.stringify({
              error: error.message,
              stackTrace: error.stack,
              context: { prompt, system_prompt, model, responseFormat, resultVar },
            }),
          });
          if (llmResponse.fix) {
            return llmResponse.fix;
          }
          throw error;
        }
      }
    },
  },
  'call_agent': {
    'name': 'call_agent',
    'version': '1.0.0',
    'description': 'Call the agent with the given task to perform.',
    'schema': {
      'name': 'call_agent',
      "methodSignature": "call_agent(params: { prompt: string, model?: string, resultVar?: string }): any",
      'description': 'Call the agent with the given task to perform.'
    },
    execute: async ({ prompt, model = 'claude', resultVar }: any, api: any) => {
      try {
        if (!prompt) {
          throw new Error("The 'prompt' parameter is required for the 'call_agent' tool.");
        }
        if (model !== 'claude' && model !== 'gemini') {
          throw new Error("Invalid model specified. Choose either 'claude' or 'gemini'.");
        }
        const compactRepresentation = () => {
          return JSON.stringify(api.getSchemas());
        };
        const convo = new Conversation(model);
        const jsonPrompt = `Transform the given task into a sequence of subtasks, each with a JavaScript script that uses the provided tools to achieve the subtask objective.

Available Tools:

${compactRepresentation()}

Additional tools can be explored using 'list_all_tools', 'get_tool_details', and 'load_tool'.

Process:

1. Analyze the task and identify necessary steps
2. Decompose into subtasks with clear objectives and input/output
3. For each subtask, write a JavaScript script using the tools
  a. Access previous subtask results with taskResults.<taskName>_results: \`const lastResult = taskResults.firstTask_results; ...\`
  b. Store subtask results in a variable for future use: \`const result = { key: 'value' }; taskResults.subtask_results = result; ...\`
  b. End the script with a return statement for the subtask deliverable: \`return result;\`
4. Test each script and verify the output
5. Provide a concise explanation of the subtask's purpose and approach

Data Management:

- Store subtask results in resultVar (JSON/array format): \`taskResults.subtask_results = result;\`
Access previous subtask data with taskResults.<resultVar>: \`const lastResult = taskResults.subtask_results; ...\`
Include only resultVar instructions in responses, not the actual data.

Output Format:
\`\`\`json
[
  {
  "task": "<taskName>:<description>",
  "script": "<JavaScript script>",
  "chat": "<subtask explanation>",
  "resultVar": "<optional result variable>"
  },
  // ... additional subtasks
]
\`\`\`

CRITICAL: Verify the JSON output for accuracy and completeness before submission. *** OUTPUT ONLY JSON ***`;
        const response = await convo.chat([
          {
            role: 'system',
            content: jsonPrompt,
          },
          {
            role: 'user',
            content: JSON.stringify({
              task: 'First off: OUTPUTTING ONLY *VALID*, RAW JSON IS CRITICAL! Now read and handle this: ' + prompt,
            }),
          },
        ]);
        let tasks = response.content[0].text;

        // crop anything outside the ````json and ``` to get only the json response
        tasks = tasks.replace(/.*```json/g, '');
        tasks = tasks.replace(/.*```/g, '');
        tasks = tasks.replace(/[\r\n]+/g, '');
        let message = '';
        try {
          tasks = JSON.parse(tasks);
        } catch (error: any) {
          tasks = api.extractJson(response.content[0].text);
          message = error.message;
        }
        if (!Array.isArray(tasks) || tasks.length === 0) {
          api.emit('error', message);
          throw new Error('The task must be an array of subtasks. Check the format and try again. RETURN ONLY JSON RESPONSES' + message);
        }

        const results = [];

        api.store[prompt] = tasks;

        if (resultVar) {
          api.store[resultVar] = results;
        }

        for (const task of tasks) {
          let { task: taskName, script, chat } = task;
          const splitTask = taskName.split(':');
          let taskId = taskName;
          if (splitTask.length > 1) {
            taskId = splitTask[0];
            taskName = splitTask[1];
          }
          api.store['currentTaskId'] = taskId;
          api.emit('taskId', taskId);

          api.store[`${taskId}_task`] = task;
          api.emit(`${taskId}_task`, task);

          api.store[`${taskId}_chat`] = chat;
          api.emit(`${taskId}_chat`, chat);

          api.store[`${taskId}_script`] = script;
          api.emit(`${taskId}_script`, script);

          const sr = await api.callScript(script);
          task.scriptResult = sr;

          api.store[`${taskId}_result`] = sr;
          api.store[`${taskId}_results`] = sr;
          const rout = { id: taskId, task: taskName, script, result: sr };
          api.emit(`${taskId}_results`, rout);

          results.push(rout);
        }

        if (resultVar) {
          api.store[resultVar] = results;
        }

        return results;
      } catch (error: any) {
        const llmResponse = await api.callTool('callLLM', {
          system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          prompt: JSON.stringify({
            error: error.message,
            stackTrace: error.stack,
            context: { prompt, model, resultVar },
          }),
        });
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
      }
    },
  },
  'call_agents': {
    'name': 'call_agents',
    'version': '1.0.0',
    'description': 'Call multiple agents with the given tasks to perform.',
    'schema': {
      'name': 'call_agents',
      "methodSignature": "call_agents(params: { prompts: string[], resultVar?: string }): any",
      'description': 'Call multiple agents with the given tasks to perform.',
    },
    execute: async ({ prompts, resultVar }: any, api: any) => {
      try {
        if (!prompts || !Array.isArray(prompts)) {
          throw new Error("The 'prompts' parameter must be an array for the 'call_agents' tool.");
        }
        const results = await Promise.all(
          prompts.map(async (prompt: string) => {
            return await api.callTool('call_agent', { prompt, model: 'claude' });
          }),
        );
        if (resultVar) {
          api.store[resultVar] = results;
        }
        return results;
      } catch (error: any) {
        const llmResponse = await api.callTool('callLLM', {
          system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          prompt: JSON.stringify({
            error: error.message,
            stackTrace: error.stack,
            context: { prompts, resultVar },
          }),
        });
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
        throw error;
      }
    },
  },
  callLLMs: {
    'name': 'callLLMs',
    'version': '1.0.0',
    'description': 'Call the LLM with the given system prompt and prompts concurrently.',
    'schema': {
      'name': 'callLLMs',
      "methodSignature": "callLLMs(params: { prompts: string[], system_prompt: string, resultVar?: string }): any",
      'description': 'Call the LLM with the given system prompt and prompts concurrently.',
    },
    execute: async ({ prompts, system_prompt, resultVar }: any, api: any) => {
      try {
        if (!prompts || !Array.isArray(prompts) || !system_prompt) {
          throw new Error("The 'prompts' parameter must be an array and 'system_prompt' is required for the 'callLLMs' tool.");
        }
        const results = await Promise.all(
          prompts.map(async (prompt: string) => {
            return await api.callTool('callLLM', { prompt, system_prompt });
          }),
        );
        if (resultVar) {
          api.store[resultVar] = results;
        }
        return results;
      } catch (error: any) {
        const llmResponse = await api.callTool('callLLM', {
          system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          prompt: JSON.stringify({
            error: error.message,
            stackTrace: error.stack,
            context: { prompts, system_prompt, resultVar },
          }),
        });
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
        throw error;
      }
    },
  },
  // apply a universal patch to a file
  'apply_patch': {
    'name': 'apply_patch',
    'version': '1.0.0',
    'description': 'Apply a universal patch to a file. Pass a file path, a patch string, and an optional resultVar to save the patched file contents.',
    'schema': {
      'name': 'apply_patch',
      "methodSignature": "apply_patch({ file: string, patch: string, resultVar?: string }): string",
      'description': 'Apply a universal patch to a file. Pass a file path, a patch string, and an optional resultVar to save the patched file contents.',
      "required": ["file", "patch"],
    },
    execute: async (params: any, api: any) => {
      if(!Array.isArray(params)) params = [params];
      for (const { file, patch, resultVar } of params) {
        try {
          if (!file || !patch) {
            throw new Error("Both 'file' and 'patch' are required parameters for the 'apply_patch' tool.");
          }
          const existsSync = require('fs').existsSync;
          const filePath =  require('path').resolve(file);
          if (!(await existsSync(filePath))) {
            throw new Error(`The file '${file}' does not exist.`);
          }
          try {
            const result = await api.callTool('busybox', {
              command: 'patch',
              args: [file],
              options: { input: patch },
              resultVar,
            });
            if (resultVar) {
              api.store[resultVar] = result;
            }
            return result;
          } catch (error: any) {
            try {
              const fileContent = await fs.readFile(file, 'utf8');
              return await api.callTool('callLLM', {
                system_prompt:
                  'Given one or more universal patches and file content, analyze the patches and the file content to determine the best way to apply the patch to the content, then apply the patch to the file. Return ONLY the patched file contents IN ITS ENTIRETY.',
                prompt: `File content: ${fileContent}\n\nPatch: ${patch}`,
              });
            } catch (error: any) {
              throw new Error(`Failed to apply patch: ${error.message} Tool source: ${error.stack}`);
            }
          }
        } catch (error: any) {
          const llmResponse = await api.callTool('callLLM', {
            system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
            prompt: JSON.stringify({
              error: error.message,
              stackTrace: error.stack,
              context: { file, patch, resultVar },
            }),
          });
          if (llmResponse.fix) {
            return llmResponse.fix;
          }
          throw error;
        }
      }
    },
  },
  'generate_patches': {
    'name': 'generate_patches',
    'version': '1.0.0',
    'description':
      'Generate a number of patches for a number of files given a list of file paths and instructions for what to generate. Use this tool to make changes to one or more files given a set of instructions.',
    'schema': {
      'name': 'generate_patches',
      "methodSignature": "generate_patches(params: { files: string[], instructions: string, resultVar?: string }): string",
      'description':
        'Generate a number of patches for a number of files given a list of file paths and instructions for what to generate. Use this tool to make changes to one or more files given a set of instructions.',
    },
    execute: async ({ files, instructions, resultVar }: any, api: any) => {
      try {
        const content = files
          .map((file: string) => {
            return [file, api.fs.readFileSync(file).toString()].join('\n');
          })
          .join('\n\n');
        const prompt = `INSTRUCTIONS: ${instructions}\n\nFILES:\n\n${content}\n\nRemember to provide a JSON array of objects with the following format: [{ file: <file>, patch: <patch> }].`;
        const llmResponse = await api.callTool('callLLM', {
          system_prompt:
            'Analyze the provided files, then analyse the instructions. Then, generate one or more patches for the files based on the given instructions. Return your patches as a JSON array of objects with the following format: [{ file: <file>, patch: <patch> }]. OUTPUT ONLY RAW JSON!',
          prompt,
        });
        if (resultVar) {
          api.store[resultVar] = llmResponse;
        }
        return llmResponse;
      } catch (error: any) {
        const llmResponse = await api.callTool('callLLM', {
          system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          prompt: JSON.stringify({
            error: error.message,
            stackTrace: error.stack,
            context: { files, instructions },
          }),
        });
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
        throw error;
      }
    },
  },
  'get_tools_home': {
    'name': 'get_tools_home',
    'version': '1.0.0',
    'description': 'Get the path to the tools home directory.',
    'schema': {
      'name': 'get_tools_home',
      "methodSignature": "get_tools_home(): string",
      'description': 'Get the path to the tools home directory.',
    },
    execute: async (params: any, api: any) => {
      const thisFolder = __dirname;
      const toolsHome = thisFolder + '/tools';
      return toolsHome;
    },
  },
  'list_all_tools': {
    'name': 'list_all_tools',
    'version': '1.0.0',
    'description': 'List all the tools available in the tools home directory.',
    'schema': {
      'name': 'list_all_tools',
      "methodSignature": "list_all_tools(): { type: 'array', items: { name: 'string' } }",
      'description': 'List all the tools available in the tools home directory.',
    },
    execute: async (params: any, api: any) => {
      const toolsHome = await api.callTool('get_tools_home', {});
      //const tools = fs.readdirSync(toolsHome).filter((file: string) => file.endsWith('.ts')).map((file: string) => file.replace('.ts', ''));
      const tools = await fs.readdir(toolsHome);
      return tools;
    },
  },
  'get_tool_details': {
    'name': 'get_tool_details',
    'version': '1.0.0',
    'description': 'Get the details of a tool.',
    'schema': {
      'name': 'get_tool_details',
      "methodSignature": "get_tool_details(tool: string): { name: 'string', description: 'string', input_schema: 'object', output_schema: 'object' }",
      'description': 'Get the details of a tool.',
    },
    execute: async ({ tool }: any, api: any) => {
      const toolsHome = await api.callTool('get_tools_home', {});
      const toolPath = `${toolsHome}/${tool}.ts`;
      const existsSync = require('fs').existsSync;
      if (!existsSync(toolPath)) {
        throw new Error(`The tool '${tool}' does not exist.`);
      }
      const toolModule = require(toolPath);
      return toolModule.schema;
    },
  },
  'get_tools_details': {
    'name': 'get_tools_details',
    'version': '1.0.0',
    'description': 'Get the details of the specified tools.',
    'schema': {
      'name': 'get_tools_details',
      "methodSignature": "get_tools_details(tools: string[]): { name: 'string', description: 'string', input_schema: 'object', output_schema: 'object' }[]",
      'description': 'Get the details of the specified tools.',
    },
    execute: async (params: any, api: any) => {
      const { tools } = params;
      const toolsDetails = await Promise.all(
        tools.map(async (tool: string) => {
          return await api.callTool('get_tool_details', { tool });
        }),
      );
      return toolsDetails;
    },
  },
  'list_active_tools': {
    'name': 'list_active_tools',
    'version': '1.0.0',
    'description': 'List all the active tools in the current session.',
    'schema': {
      'name': 'list_active_tools',
      "methodSignature": "list_active_tools(): string[]",
      'description': 'List all the active tools in the current session.',
    },
    execute: async (params: any, api: any) => {
      return Object.keys(api.tools);
    },
  },
  'load_tool': {
    'name': 'load_tool',
    'version': '1.0.0',
    'description': 'Load a tool from a file path.',
    'schema': {
      name: 'load_tool',
      "methodSignature": "load_tool(path: string): string",
      description: 'Load a tool from a file path.',
    },
    execute: async ({ path }: any, api: any) => {
      try {
        const toolModule = require(path);
        const toolName = toolModule.name; // Assuming the tool module exports its name
        api.toolRegistry.addTool(toolName, toolModule.source, toolModule.schema, toolModule.tags || []);
        return toolName;
      } catch (error: any) {
        throw new Error(`Failed to load tool: ${error.message} Tool source: ${error.stack}`);
      }
    },
  },
  'load_tool_source': {
    'name': 'load_tool_source',
    'version': '1.0.0',
    'description': 'Load a tool from a file path and return the source code.',
    'schema': {
      'name': 'load_tool_source',
      "methodSignature": "load_tool_source(path: string): string",
      'description': 'Load a tool from a file path and return the source code.',
    },
    execute: async ({ path }: any, api: any) => {
      try {
        const tool = await fs.readFile(path, 'utf8');
        return tool;
      } catch (error: any) {
        throw new Error(`Failed to load tool source: ${error.message} Tool source: ${error.stack}`);
      }
    },
  },
  'save_tool': {
    'name': 'save_tool',
    'version': '1.0.0',
    'description': 'Save a tool to a file path.',
    'schema': {
      name: 'save_tool',
      'methodSignature': 'save_tool(params: { tool: object, path: string }): string',
      description: 'Save a tool to a file path.',
    },
    execute: async ({ tool, path }: any, api: any) => {
      try {
        const name = Object.keys(tool)[0];
        await fs.writeFile(path, `module.exports = ${JSON.stringify(tool, null, 2)};`);
        return name;
      } catch (error: any) {
        throw new Error(`Failed to save tool: ${error.message} Tool source: ${error.stack}`);
      }
    },
  },
  search_news_api: {
    'name': 'search_news_api',
    'version': '1.0.0',
    'description': 'Performs a news search using the given query.',
    'schema': {
      'name': 'search_news_api',
      "methodSignature": "search_news_api(params: { q: string, from?: string, to?: string, language?: string, country?: string, domains?: string, sources?: string, sortBy?: string, num?: number }): string",
      'description': 'Performs a news search using the given query.',
    },
    execute: async (values: any) => {
      const axios = require('axios');
      const trunc = (str: any, len: any) => {
        return str.length > len ? str.substring(0, len - 3) + '...' : str;
      }
      try {
        const response = await axios.get(`https://newsapi.org/v2/everything?q=${values.q}&apiKey=${process.env.NEWS_API_KEY}`);
        const results = response.data.articles.map((item: any) => ({
          content: trunc(item.content, 100),
          title: item.title,
          url: item.url,
        }));
        // keep only the first num results
        let num = values.num ? values.num : 10;
        const res = results.slice(0, num);
        return JSON.stringify(res);
      } catch (error: any) {
        return `Error calling News API: ${error.message}`
      }
    }
  },
  search_google: {
    'name': 'search_google',
    'version': '1.0.0',
    'description': 'perform a google search using the given query',
    'schema': {
      "name": "search_google",
      "methodSignature": "search_google(params: { query: string }): string",
      "description": "perform a google search using the given query",
    },
    execute: async ({ query }: any) => {
      const config = {
        GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,
        GOOGLE_CX_ID: process.env.GOOGLE_CX_ID
      }
      try {
        const axios = require('axios');
        const response = await
          axios.get(`https://www.googleapis.com/customsearch/v1?key=${config.GOOGLE_API_KEY}&cx=${config.GOOGLE_CX_ID}&q=${query}`);
        const results = response.data.items.map((item: any) => ({
          title: item.title,
          link: item.link
        }));
        const res = JSON.stringify(results);
        return res;
      } catch (error: any) {
        return error.message;
      }
    }
  },
  fixJson: {
    // given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array
    // given some text content without any JSON within it, it will attempt to structure the text content into a JSON object
    'name': 'fixJson',
    'version': '1.0.0',
    'description': 'given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array, given some text content without any JSON within it, it will attempt to structure the text content into a JSON object',
    'schema': {
      'name': 'fixJson',
      'methodSignature': 'fixJson(params: { json: string, resultVar?: string }): any',
      'description': 'given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array, given some text content without any JSON within it, it will attempt to structure the text content into a JSON object',
    },
    execute: async ({ json, resultVar }: any, api: any) => {
      const convo = new Conversation('gemini');
      const sp = `Given some content that contains a JSON object or array, you ignore EVERYTHING BEFORE OR AFTER what is obviously JSON data, ignoring funky keys and weird data, and you output a syntactically-valid version of the JSON, with other quoting characters properly escaped, on a single line. If the content contains no JSON data, you output a JSON object containing the input data, structured in the most appropriate manner for the data.`;
      const tasks = await convo.chat([
        {
          role: 'system',
          content: sp
        },
        {
          role: 'user',
          content: json,
        },
      ], {} as any, 'gemini-1.5-flash-001');
      let task = tasks.content[0].text;
      try {
        task = JSON.parse(task);
      } catch (error: any) {
        task = api.extractJson(task);
      }
      if (resultVar) {
        api.store[resultVar] = task;
      }
      return task;
    }
  }

};
.//assistant/maintenance.ts
import Assistant from './assistant';
import ToolRegistry from './tool_registry';
import { MemoryStore } from './memory/store';

export class MaintenanceManager {
  private assistant: Assistant;
  private toolRegistry: ToolRegistry;
  private memoryStore: MemoryStore;

  constructor(assistant: Assistant, toolRegistry: ToolRegistry, memoryStore: MemoryStore) {
    this.assistant = assistant;
    this.toolRegistry = toolRegistry;
    this.memoryStore = memoryStore;
  }

  async performMaintenance(): Promise<void> {
    await this.reviewAutoGeneratedTools();
    await this.optimizeMemory();
  }

  private async reviewAutoGeneratedTools(): Promise<void> {
    await this.toolRegistry.reviewAutoGeneratedTools();
  }

  private async optimizeMemory(): Promise<void> {
    // Implement memory optimization logic
    // For example, remove old or low-confidence memories
    const memories = await this.memoryStore.listMemories();
    const lowConfidenceMemories = memories.filter(memory => memory.confidence < 0.3);
    for (const memory of lowConfidenceMemories) {
      await this.memoryStore.removeMemory(memory.input);
    }
  }
}.//assistant/conversation.ts

// conversation.ts
import { AnthropicVertex } from '@anthropic-ai/vertex-sdk';
import { VertexAI } from '@google-cloud/vertexai';

export default class Conversation {
  model: string;
  projectId: string;
  location: string;
  client: any;
  vertexAI: any;
  constructor(model: any) {
    this.model = model.toLowerCase();

    if (this.model !== 'claude' && this.model !== 'gemini') {
      throw new Error("Invalid model specified. Choose either 'claude' or 'gemini'.");
    }

    // Vertex AI Configuration (adjust if needed)
    this.projectId = 'silent-blade-417120';
    this.location = this.model === 'claude' ? 'us-east5' : 'us-central1';

    if (this.model === 'claude') {
      this.client = new AnthropicVertex({
        region: this.location,
        projectId: this.projectId,
      });
    } else {
      this.vertexAI = new VertexAI({
        project: this.projectId,
        location: this.location
      });
    }
  }

  async chat(messages: any[], options = {
    max_tokens : 4000, 
    temperature : 0.15,
    responseFormat: ''
  }, model = 'gemini-1.5-pro-001') {
    const {}: any = options;
    if(!Array.isArray(messages)) {
      throw new Error('Messages must be an array of objects.');
    }

    if (this.model === 'claude') {
      return this.chatWithClaude(messages, options);
    } else {
      return this.chatWithGemini(messages, options, model);
    }
  }

  async chatWithClaude(messages: any[], options = {
    max_tokens : 4000, 
    temperature : 0.15,
    responseFormat : ''
  }) {
    let { max_tokens, temperature, responseFormat } = options;
    if(responseFormat !== '') {
      responseFormat = `\n\nRESPONSE FORMAT. *** YOU are REQUIRED to return the response in JSON formatted with the following format: ${responseFormat} Do NOT SURROUND with Codeblocks ***`
    }
    try {
      let system = "You are a helpful assistant.";
      if (messages[0].role === "system") {
        system = messages[0].content + (responseFormat ? responseFormat : '');
        messages.shift();
      }
      if(responseFormat !== '') {
        messages[messages.length - 1].content += responseFormat;
      }
      let result = await this.client.messages.create({
        messages: messages,
        model: 'claude-3-5-sonnet@20240620',
        system,
        max_tokens: max_tokens || 4000,
        temperature: temperature,
      });
      if(responseFormat !== '') {
        try {
        result = JSON.parse(result.content[0].text);
        } catch (error) {
          result = result.content[0].text;
        }
      }
      return result;
    } catch (error) {
      console.error(error);
      return error;
    }
  }

  async chatWithGemini(messages: any[], options: any, model: string = 'gemini-1.5-pro-001') {
    const { max_tokens, temperature } = options;
    const generativeModel = this.vertexAI.getGenerativeModel({
      model: model,
    });
    const prompt = messages.map(message => `${message.role}: ${message.content}`).join('\n');

    const resp = await generativeModel.generateContent(prompt, {
      temperature: temperature,
      maxOutputTokens: max_tokens,
    });

    const contentResponse = await resp.response;
    return contentResponse;
  }
}.//assistant/index.ts
//SUB
import { CoreWorkflow } from "./workflow";
import { generateUsername } from "unique-username-generator";
import * as packageJson from "../../package.json";
import fs from 'fs';
import ToolRegistry from "./tool_registry";
import { ChromaClient } from "chromadb";
import Assistant from "./assistant";

export class AssistantSessionManager extends ToolRegistry {

    sessions: any[];
    activeSessionIndex: number;
    commandMode: boolean = false;

    constructor(public chromaClient: ChromaClient) {
        super();
        console.clear();
        this.sessions = [];
        this.activeSessionIndex = 0;
    }

    createNewSession() {
        const newSession = new AssistantSession(this, this.chromaClient);
        this.sessions.push(newSession);
        this.activeSessionIndex = this.sessions.length - 1;
        this.switchToSession(this.activeSessionIndex, false);
        this.emit('newSessionCreated', this.sessions[this.activeSessionIndex]);
       
    }

    switchToNextSession() {
        this.saveSessionState();
        this.activeSessionIndex = (this.activeSessionIndex + 1) % this.sessions.length;
        this.switchToSession(this.activeSessionIndex);
    }

    switchToSession(index: number, showPrompt: boolean = true) {
        this.activeSessionIndex = index;
        if (this.sessions[this.activeSessionIndex]) {
            console.clear();
            showPrompt && console.log(`\n--- Switched to session ${this.activeSessionIndex} ---`);
            this.sessions[this.activeSessionIndex].restoreSessionState();
            this.emit('sessionSwitched', this.sessions[this.activeSessionIndex]);
        }
    }

    executeCommandInActiveSession(command: string) {
        if (this.sessions.length === 0) {
            this.createNewSession();
        }
        this.emit('beforeExecuteCommand', { command });
        this.sessions[this.activeSessionIndex].execute(command);
        this.emit('afterExecuteCommand', { command });
    }

    saveSessionState() {
        this.sessions[this.activeSessionIndex].savedOutput = this.sessions[this.activeSessionIndex]._buffer ? this.sessions[this.activeSessionIndex]._buffer.toString() : '';
        this.emit('saveSessionState', this.sessions[this.activeSessionIndex].savedOutput);
    }
}


export class AssistantSession extends CoreWorkflow {

    id: string;
    debug: boolean = false;
    savedOutput: string = '';
    _buffer: any;

    sessionManager: AssistantSessionManager;
    actionHandlers: any = {};

    constructor(sessionManager: AssistantSessionManager, chromaClient: any) {
        super(sessionManager, chromaClient);
        this.id = generateUsername("", 2, 38);
        this.sessionManager = sessionManager;
        this.sessionManager.sessions.push(this);
        this.setupHandlers();
        this.setupWorkflowListeners();
    }

    emit<T extends string | symbol>(event: T, ...args: any[]): boolean {
        super.emit(event, ...args);
        this._buffer = this._buffer || [];
        this._buffer.push({ event, data: args });
        return true;
    }

    async execute(command: string) {
        if (command.startsWith('.')) {
          this.emit('beforeExecuteSpecialCommand', { command })
          await this.executeSpecialCommand(command);
          this.emit('afterExecuteSpecialCommand', { command });
        } else {
          this.emit('beforeExecuteCommand', { command })
          const result = await super.execute(command);
          this.emit('afterExecuteCommand', { command });
          return result.success ? { success: true, data: result.data } : { success: false, error: result.error };
        }
        return { success: true, data: '' };
      }

    private setupWorkflowListeners() {
        this.on('taskComplete', (data) => this.emit('taskComplete', data));
        this.on('toolUpdated', (data) => this.emit('toolUpdated', data));
    }

    async processInput(input: string): Promise<any> {
        const result = await this.execute(input);
        if (result.success) {
            return result.data;
        } else {
            throw result.error;
        }
    }

    setupHandlers() {
        super.setupHandlers();
        this.on('interrupt', (error: any) => {
            this.onInterrupt();
        });
    }

    async executeSpecialCommand(command: string) {
        super.executeSpecialCommand(command);
        switch (command) {
            case '.state':
                this.showState();
                break;
            case '.exit':
                this.exitSession();
                break;
            default:
                this.emit('text', `Unknown command: ${command}`);
        }
    }

    onInterrupt() {
        if (!this.working) {
            this.emit('goodbye');
            console.log('Goodbye!');
            process.exit(0);
        }
        this.removeAllListeners();
        this.sessionManager.sessions = this.sessionManager.sessions.filter((session) => session.id !== this.id);
        this.sessionManager.activeSessionIndex = 0;
        this.sessionManager.switchToSession(0);
        this.emit('text', 'Session interrupted.');
    }

    restoreSessionState() {
        this.emit('restoreSessionState', this.savedOutput);
        this.printHistory();
    }

    showHelp() {
        const helpMessage = `Commands:
.help\t\tShow this help message
.debug\t\tToggle debug mode on/off
.history\tShow command history for this session
.state\t\tShow current state of the session
.exit\t\tExit this session
Ctrl+A\t\tCreate a new session
Ctrl+C\t\tSwitch to the next session`;
        this.emit('text', helpMessage);
        return helpMessage;
    }

    toggleDebug() {
        this.debug = !this.debug;
        this.emit('text', `Debug mode is now ${this.debug ? 'on' : 'off'}`);
    }

    printHistory() {
        if (this.history.length === 0) {
            this.emit('text', 'This session has no history yet.');
            return;
        }
        const sessionHistory: any = [`Session History:`]
        this.history.forEach((command, index) => {
            sessionHistory.push(`${index + 1}. ${command}`);
        });
        this.emit('text', sessionHistory.join('\n'));
    }

    showState() {
        const state = {
            id: this.id,
            debug: this.debug,
            history: this.history
        };
        this.emit('text', JSON.stringify(state, null, 2));
    }

    exitSession() {
        this.removeAllListeners();
        this.sessionManager.sessions = this.sessionManager.sessions.filter((session) => session.id !== this.id);
        this.sessionManager.activeSessionIndex = 0;
        this.sessionManager.switchToSession(0);
    }

    async handleToolCommand(args: string[]) {
        const [subCmd, ...subArgs] = args;

        switch (subCmd) {
            case 'list':
                this.listTools();
                break;
            case 'add':
                await this.addTool(subArgs);
                break;
            case 'update':
                await this.updateTool(args[0], args[1]); // args[0] = name, args[1] = source file
                break;
            case 'rollback':
                await this.rollbackTool(args[0], args[1]); // args[0] = name, args[1] = version
                break;
            case 'history':
                await this.showToolHistory(subArgs);
                break;
            case 'help':
            default:
                this.showToolHelp();
        }
    }

    // Call a tool with error handling and fallback strategies
    async callTool(toolName: string, params: any) {
        return super.callTool(toolName, params);
    }

    async listTools() {
        const tools = await this.sessionManager.getToolList();
        const toolNames = tools.map((tool: any) => `${tool.name} (v${tool.version})`);
        return [...toolNames];
    }

    async addTool(args: string[]) {
        if (args.length < 2) {
            this.emit('text', "Usage: .tool add <name> <source_file> <schema> [tag1,tag2,...]");
            return;
        }

        const [name, sourceFile, schema, tagsString] = args;
        const tags = tagsString ? tagsString.split(',') : [];

        try {
            const source: any = fs.readFileSync(sourceFile, 'utf8');
            const added = await this.sessionManager.addTool(name, source, schema, tags);
            if (added) {
                this.emit('text', `Tool '${name}' added successfully.`);
            } else {
                this.emit('warning',`Tool '${name}' already exists.`);
            }
        } catch (error) {
            this.emit('error', error.message);
        }
    }

    async createToolSchema(source: string) {
        const schema = this.sessionManager.createToolSchema(source);
        this.emit('text', JSON.stringify(schema, null, 2));
        return schema;
    }

    async updateTool(name: string, sourceFile: string): Promise<boolean> {
        try {
            const source: any = await fs.readFileSync(sourceFile, 'utf8');
            const updated: any = await this.updateTool(name, source);
            if (updated) {
                this.emit('toolUpdated', { name, version: updated.version });
            } else {
                this.emit('warning', `Tool '${name}' not found.`);
            }
            return updated;
        } catch (error) {
            this.emit('error', error.message);
        }
        return false;
    }

    async rollbackTool(name: string, version: string): Promise<boolean> {
        try {
            const rolledBack: any = await this.rollbackTool(name, version);
            if (rolledBack) {
                this.emit('toolRolledBack', { name, version });
            } else {
                this.emit('warning', `Failed to rollback tool '${name}' to version ${version}.`);
            }
        } catch (error) {
            this.emit('error', error.message);
        }
        return false;
    }

    showToolHelp() {
        const ret = `Tool management commands:
.tool list\t\t\tList all available tools
.tool add <name> <file> [tags]\tAdd a new tool
.tool update <name> <file>\tUpdate an existing tool
.tool rollback <name> <version>\tRollback a toolto a specific version
.tool history <name>\t\tShow version history of a tool`;
        this.emit('text', ret);
        return ret;
    }

    interrupt() {
        this.emit('interrupt');
    }

    // Call the language model agent
    async callAgent(input: string, model = 'claude', resultVar?: string): Promise<{ success: boolean; data?: any; error?: Error; }> {
        return super.callAgent(input, model, resultVar);
    }
    
    // Execute a JavaScript script with retry and error handling using vm2
    async callScript(script: string, retryLimit: number = 3): Promise<any> {
        return super.callScript(script, retryLimit);
    }
}

const client = new ChromaClient({
    path: 'http://localhost:8000',
});

// Main execution
const sessionManager = new AssistantSessionManager(client);

const assistant = new Assistant(sessionManager, sessionManager.chromaClient);

sessionManager.createNewSession();

sessionManager.on('newSessionCreated', (session) => {
    session.emit('text', `Assistant v${packageJson.version} ready. Type '.help' for available commands.`);
});

export default sessionManager;
export { assistant }.//colors.ts
import chalk from 'chalk';

export const colors = {
  userInput: chalk.cyan,
  aiResponse: chalk.green,
  error: chalk.red,
  warning: chalk.yellow,
  info: chalk.blue,
  debug: chalk.gray,
  success: chalk.green,
};
.//fuzzy_search.ts
export function fuzzySearch(items: string[], query: string): string[] {
    const lowercaseQuery = query.toLowerCase();
    return items.filter(item => {
      const lowercaseItem = item.toLowerCase();
      let i = 0, n = -1, l;
      for (; l = lowercaseQuery[i++] ;) {
        if (!~(n = lowercaseItem.indexOf(l, n + 1))) return false;
      }
      return true;
    });
  }.//logger.ts
// logger.ts

import winston from 'winston';
import chalk from 'chalk';

// Define custom log levels
const logLevels = {
  error: 0,
  warn: 1,
  info: 2,
  text: 2,
  debug: 3,
  verbose: 4,
};

// Create color scheme for log levels
const logColors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  text: 'green',
  debug: 'blue',
  verbose: 'cyan',
};

// Create Winston logger instance
const logger = winston.createLogger({
  levels: logLevels,
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message, service }) => {
      const color = logColors[level] || 'white';
      return `${chalk.gray(timestamp)} ${chalk[color](level.toUpperCase())} [${service}]: ${message}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

// Create a function to dynamically enable/disable log levels
function setLogLevel(level: string) {
  logger.level = level;
}

// Create a function to enable/disable specific services
const enabledServices = new Set<string>();

function toggleService(service: string, enabled: boolean) {
  if (enabled) {
    enabledServices.add(service);
  } else {
    enabledServices.delete(service);
  }
}

// Create a wrapper function for logging
function log(level: string, message: string, service: string) {
  if (enabledServices.has(service) || enabledServices.size === 0) {
    logger.log({ level, message, service });
  }
}

export { logger, setLogLevel, toggleService, log };.//ui.ts
import readline from 'readline';
import chalk from 'chalk';
import boxen from 'boxen';
import { EventEmitter } from 'eventemitter3';
import { Theme, themes } from './themes';

export class UI extends EventEmitter {
  readlineInterface: any;
  currentTheme: Theme;

  constructor() {
    super();
    this.readlineInterface = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: '> '
    });

    this.currentTheme = themes.default;
  }

  applyTheme(theme: Theme) {
    this.currentTheme = theme;
    this.updateOutput(`Applied ${theme.name} theme`, 'info');
    this.emit('themeChanged', theme as Theme);
  }

  switchTheme(themeName: string) {
    const newTheme = themes[themeName];
    if (newTheme) {
      this.applyTheme(newTheme);
      this.updateOutput(`Switched to ${newTheme.name} theme`, 'info');
      this.emit('themeChanged', newTheme);
    } else {
      this.updateOutput(`Theme '${themeName}' not found`, 'error');
    }
  }

  updateOutput(
    content: string,
    type: 'userInput' | 'aiResponse' | 'error' | 'warning' | 'info' | 'debug' | 'success' = 'info'
  ) {
    let coloredContent;
    switch (type) {
      case 'userInput':
        coloredContent = chalk.cyan(content);
        break;
      case 'aiResponse':
        coloredContent = chalk.green(content);
        break;
      case 'error':
        coloredContent = chalk.red(content);
        break;
      case 'warning':
        coloredContent = chalk.yellow(content);
        break;
      case 'info':
        coloredContent = chalk.blue(content);
        break;
      case 'debug':
        coloredContent = chalk.gray(content);
        break;
      case 'success':
        coloredContent = chalk.green(content);
        break;
      default:
        coloredContent = content;
    }
    // status is shown right above the prompt - we use terminal escape codes to move the cursor up
    process.stdout.write('\u001b[1A\u001b[2K');
    console.log(coloredContent);
  }

  getInput(): Promise<string> {
    return new Promise((resolve) => {
      this.readlineInterface.question('', (input) => {
        resolve(input);
      });
    });
  }

  displayBoxedContent(content: string, title?: string) {
    const boxedContent = boxen(content, {
      padding: 1,
      margin: 1,
      borderStyle: 'round',
      borderColor: 'cyan',
      title: title,
      titleAlignment: 'center',
    });
    console.log(boxedContent);
  }
}.//index.ts
import Assistant from "./assistant/assistant";
import { AssistantSessionManager, AssistantSession } from "./assistant/index";
import { MaintenanceManager } from './assistant/maintenance';
import chalk from "chalk";
import boxen from "boxen";
import { themes } from './themes';
import readline from 'readline';
import * as packageJson from "../package.json";
import fs from 'fs';
import { ChromaClient } from "chromadb";
import { tools } from "./assistant/tools";
import ajv from 'ajv';
import { Tool, toolRegistryTools } from "./assistant/tool_registry";
import { log, setLogLevel, toggleService } from './logger';
import { UI } from "./ui";
import os from 'os';
import { WorkflowResult } from "./assistant/workflow";

const jsonSchemaValidator = new ajv();

async function jsonValidator(
    jsonSchema: string,
    jsonData: string,
): Promise<boolean> {
    try {
        const schema = JSON.parse(jsonSchema);
        const data = JSON.parse(jsonData);
        const validate = jsonSchemaValidator.compile(schema);
        const valid = validate(data);
        return valid;
    } catch (error) {
        return false;
    }
}

// Generic error handling function for file system operations
async function handleFileError(context: any, api: any) {
    const logError = (message: string, level: string = 'error') => {
        log(level, message, 'FileOperations');
    };

    logError(`File operation error: ${JSON.stringify(context)} `);

    const llmResponse = await api.callTool('callLLM', {
        system_prompt: 'Analyze the file operation error and suggest a fix.',
        prompt: JSON.stringify(context),
    });

    if (llmResponse.fix) {
        logError(`Attempting LLM fix: ${llmResponse.fix} `, 'debug');
        try {
            // Attempt to apply the LLM's fix (make sure it's safe!)
            // ... (Implement safe fix application logic here)
        } catch (fixError: any) {
            logError(`LLM fix attempt failed: ${fixError.message} `, 'error');
        }
    }

    // Safe Fallback:
    if (context.errorCode === 'ENOENT') {
        logError('File not found. Suggest creating the file or checking the path.', 'info');
        // ... (Implement logic to suggest file creation or path correction)
    } else {
        logError(`Unhandled file error code: ${context.errorCode} `, 'error');
        // ... (Handle other error codes with appropriate fallbacks)
    }
}


class TerminalSessionManager extends AssistantSessionManager {
    ui: UI;
    commandHistory: string[] = [];
    currentHistoryPage: number = 1;
    itemsPerPage: number = 10;

    extraTools: any = {
        wait_for_keypress: {
            'name': 'wait_for_keypress',
            'version': '1.0.0',
            'description': 'wait_for_keypress pauses execution until the user presses a key. Returns the key that was pressed and sets it to the resultVar if provided.',
            'schema': {
                'name': 'wait_for_keypress',
                'description': 'wait_for_keypress pauses execution until the user presses a key. Returns the key that was pressed and sets it to the resultVar if provided.',
                "methodSignature": "wait_for_keypress(resultVar?: string): string",
            },
            execute: async ({ resultVar }: any, api: any) => {
                const readline = require('readline');
                const rl = readline.createInterface({
                    input: process.stdin,
                    output: process.stdout,
                });

                return new Promise((resolve) => {
                    rl.question('Press any key to continue...', (key: string) => {
                        rl.close();
                        if (resultVar) {
                            api.store[resultVar] = key;
                        }
                        resolve(key);
                    });
                });
            },
        },
        'busybox2': {
            'name': 'files',
            'version': '1.0.0',
            'description': 'Performs file operations. Supported operations include read, append, prepend, replace, insert_at, remove, delete, copy..',
            'schema': {
                'name': 'busybox2',
                'description': 'Performs file operations. Supported operations include read, append, prepend, replace, insert_at, remove, delete, copy..',
                "methodSignature": "files(operations: { operation: string, path?: string, match?: string, data?: string, position?: number, target?: string }[]): string",
            },
            execute: async function ({ operations }: any, run: any) {
                try {
                    const fs = require('fs');
                    const pathModule = require('path');
                    const cwd = process.cwd();
                    for (const { operation, path, match, data, position, target } of operations) {
                        const p = pathModule.join(cwd, path || '');
                        const t = pathModule.join(cwd, target || '');
                        if (!fs.existsSync(p || t)) {
                            return `Error: File not found at path ${p || t} `;
                        }
                        let text = fs.readFileSync(p, 'utf8');
                        switch (operation) {
                            case 'read':
                                return text;
                            case 'append':
                                text += data;
                                break;
                            case 'prepend':
                                text = data + text;
                                break;
                            case 'replace':
                                text = text.replace(match, data);
                                break;
                            case 'insert_at':
                                text = text.slice(0, position) + data + text.slice(position);
                                break;
                            case 'remove':
                                text = text.replace(match, '');
                                break;
                            case 'delete':
                                fs.unlinkSync(p);
                                break;
                            case 'copy':
                                fs.copyFileSync(p, t);
                                break;
                            default:
                                return `Error: Unsupported operation ${operation} `;
                        }
                        fs.writeFileSync(p, text);
                    }
                    return `Successfully executed batch operations on files`;
                } catch (error: any) {
                    const context = {
                        errorCode: error.code,
                        operations: operations,
                        // ... other details
                    };
                    await handleFileError(context, run);
                    return `File operation '${operations}' failed. Check logs for details.`;
                }
            },
        },
    }

    // constructor(public chromaClient: ChromaClient) {

    //     super(chromaClient);
    //     this.ui = new UI();
    //     this.initializeSessionManagement();
    //     this.startStatusBarUpdates();
    //     this.initializeThemeSupport();

    //     readline.emitKeypressEvents(process.stdin);
    //     if (process.stdin.isTTY) process.stdin.setRawMode(true);

    //     this.addTool('wait_for_keypress', this.extraTools.wait_for_keypress.execute.toString(), this.extraTools.wait_for_keypress.schema, ['utility']);
    //     this.addTool('list_tools', toolRegistryTools.list_tools.execute.toString(), toolRegistryTools.list_tools.schema, ['utility']);
    //     this.addTool('add_tool', toolRegistryTools.add_tool.execute.toString(), toolRegistryTools.add_tool.schema, ['utility']);
    //     this.addTool('update_tool', toolRegistryTools.update_tool.execute.toString(), toolRegistryTools.update_tool.schema, ['utility']);
    //     this.addTool('delete_tool', toolRegistryTools.delete_tool.execute.toString(), toolRegistryTools.delete_tool.schema, ['utility']);
    //     this.addTool('get_tool_metadata', toolRegistryTools.get_tool_metadata.execute.toString(), toolRegistryTools.get_tool_metadata.schema, ['utility']);
    //     this.addTool('update_tool_metadata', toolRegistryTools.update_tool_metadata.execute.toString(), toolRegistryTools.update_tool_metadata.schema, ['utility']);
    //     this.addTool('get_tool_performance', toolRegistryTools.get_tool_performance.execute.toString(), toolRegistryTools.get_tool_performance.schema, ['utility']);
    //     this.addTool('get_all_performance_metrics', toolRegistryTools.get_all_performance_metrics.execute.toString(), toolRegistryTools.get_all_performance_metrics.schema, ['utility']);
    //     this.addTool('run_maintenance', toolRegistryTools.run_maintenance.execute.toString(), toolRegistryTools.run_maintenance.schema, ['utility']);
    //     this.addTool('analyze_and_create_tool', toolRegistryTools.analyze_and_create_tool.execute.toString(), toolRegistryTools.analyze_and_create_tool.schema, ['utility']);
    //     this.addTool('predict_likely_tools', toolRegistryTools.predict_likely_tools.execute.toString(), toolRegistryTools.predict_likely_tools.schema, ['utility']);
    //     this.addTool('get_tool_history', toolRegistryTools.get_tool_history.execute.toString(), toolRegistryTools.get_tool_history.schema, ['utility']);
    //     this.addTool('rollback_tool', toolRegistryTools.rollback_tool.execute.toString(), toolRegistryTools.rollback_tool.schema, ['utility']);
    //     this.addTool('generate_tool_report', toolRegistryTools.generate_tool_report.execute.toString(), toolRegistryTools.generate_tool_report.schema, ['utility']);
    //     this.addTool('busybox2', this.extraTools.busybox2.execute.toString(), this.extraTools.busybox2.schema, ['utility']);

    //     const toolList = Object.values(tools);
    //     toolList.forEach((tool) => {
    //         this.addTool(tool.name, tool.execute.toString(), tool.schema, tool.tags);
    //     });

    //     setTimeout(async () => {
    //         this.sessions[this.activeSessionIndex] && this.sessions[this.activeSessionIndex].emit('text', 'running self-improvement tasks...')
    //         await this.generateAndRunTests();
    //         await this.improveTools();
    //     }, 60000);

    //     
    // }
    constructor(public chromaClient: ChromaClient) {
        super(chromaClient);
        this.ui = new UI();
        this.initializeSessionManagement();
        this.startStatusBarUpdates();
        this.initializeThemeSupport();
        this.initializeHistoryBrowser();
        this.registerExtraTools();
    }

    private registerExtraTools() {
        const extraTools = {
            wait_for_keypress: {
                name: 'wait_for_keypress',
                version: '1.0.0',
                description: 'Pauses execution until the user presses a key.',
                schema: {
                    name: 'wait_for_keypress',
                    description: 'Pauses execution until the user presses a key.',
                    methodSignature: "wait_for_keypress(resultVar?: string): string",
                },
                execute: async ({ resultVar }: any, api: any) => {
                    const readline = require('readline');
                    const rl = readline.createInterface({
                        input: process.stdin,
                        output: process.stdout,
                    });
    
                    return new Promise((resolve) => {
                        rl.question('Press any key to continue...', (key: string) => {
                            rl.close();
                            if (resultVar) {
                                api.store[resultVar] = key;
                            }
                            resolve(key);
                        });
                    });
                },
            },
            busybox2: {
                name: 'files',
                version: '1.0.0',
                description: 'Performs file operations.',
                schema: {
                    name: 'busybox2',
                    description: 'Performs file operations.',
                    methodSignature: "files(operations: { operation: string, path?: string, match?: string, data?: string, position?: number, target?: string }[]): string",
                },
                execute: async function ({ operations }: any, run: any) {
                    try {
                        const fs = require('fs');
                        const pathModule = require('path');
                        const cwd = process.cwd();
                        for (const { operation, path, match, data, position, target } of operations) {
                            const p = pathModule.join(cwd, path || '');
                            const t = pathModule.join(cwd, target || '');
                            if (!fs.existsSync(p || t)) {
                                return `Error: File not found at path ${p || t} `;
                            }
                            let text = fs.readFileSync(p, 'utf8');
                            switch (operation) {
                                case 'read':
                                    return text;
                                case 'append':
                                    text += data;
                                    break;
                                case 'prepend':
                                    text = data + text;
                                    break;
                                case 'replace':
                                    text = text.replace(match, data);
                                    break;
                                case 'insert_at':
                                    text = text.slice(0, position) + data + text.slice(position);
                                    break;
                                case 'remove':
                                    text = text.replace(match, '');
                                    break;
                                case 'delete':
                                    fs.unlinkSync(p);
                                    break;
                                case 'copy':
                                    fs.copyFileSync(p, t);
                                    break;
                                default:
                                    return `Error: Unsupported operation ${operation} `;
                            }
                            fs.writeFileSync(p, text);
                        }
                        return `Successfully executed batch operations on files`;
                    } catch (error: any) {
                        const context = {
                            errorCode: error.code,
                            operations: operations,
                            // ... other details
                        };
                        await handleFileError(context, run);
                        return `File operation '${operations}' failed. Check logs for details.`;
                    }
                },
            },
        };

        this.addTool('wait_for_keypress', this.extraTools.wait_for_keypress.execute.toString(), this.extraTools.wait_for_keypress.schema, ['utility']);
        this.addTool('list_tools', toolRegistryTools.list_tools.execute.toString(), toolRegistryTools.list_tools.schema, ['utility']);
        this.addTool('add_tool', toolRegistryTools.add_tool.execute.toString(), toolRegistryTools.add_tool.schema, ['utility']);
        this.addTool('update_tool', toolRegistryTools.update_tool.execute.toString(), toolRegistryTools.update_tool.schema, ['utility']);
        this.addTool('delete_tool', toolRegistryTools.delete_tool.execute.toString(), toolRegistryTools.delete_tool.schema, ['utility']);
        this.addTool('get_tool_metadata', toolRegistryTools.get_tool_metadata.execute.toString(), toolRegistryTools.get_tool_metadata.schema, ['utility']);
        this.addTool('update_tool_metadata', toolRegistryTools.update_tool_metadata.execute.toString(), toolRegistryTools.update_tool_metadata.schema, ['utility']);
        this.addTool('get_tool_performance', toolRegistryTools.get_tool_performance.execute.toString(), toolRegistryTools.get_tool_performance.schema, ['utility']);
        this.addTool('get_all_performance_metrics', toolRegistryTools.get_all_performance_metrics.execute.toString(), toolRegistryTools.get_all_performance_metrics.schema, ['utility']);
        this.addTool('run_maintenance', toolRegistryTools.run_maintenance.execute.toString(), toolRegistryTools.run_maintenance.schema, ['utility']);
        this.addTool('analyze_and_create_tool', toolRegistryTools.analyze_and_create_tool.execute.toString(), toolRegistryTools.analyze_and_create_tool.schema, ['utility']);
        this.addTool('predict_likely_tools', toolRegistryTools.predict_likely_tools.execute.toString(), toolRegistryTools.predict_likely_tools.schema, ['utility']);
        this.addTool('get_tool_history', toolRegistryTools.get_tool_history.execute.toString(), toolRegistryTools.get_tool_history.schema, ['utility']);
        this.addTool('rollback_tool', toolRegistryTools.rollback_tool.execute.toString(), toolRegistryTools.rollback_tool.schema, ['utility']);
        this.addTool('generate_tool_report', toolRegistryTools.generate_tool_report.execute.toString(), toolRegistryTools.generate_tool_report.schema, ['utility']);
        this.addTool('busybox2', this.extraTools.busybox2.execute.toString(), this.extraTools.busybox2.schema, ['utility']);

        // Register toolRegistryTools
        Object.entries(toolRegistryTools).forEach(([name, tool]) => {
            this.addTool(name, tool.execute.toString(), tool.schema, ['utility']);
        });
    }

    initializeThemeSupport() {
        this.ui.readlineInterface.on('line', (line: string) => {
            if (line.startsWith('.theme')) {
                const themeName = line.split(' ')[1];
                this.ui.switchTheme(themeName);
            } else {
                this.executeCommandInActiveSession(line);
            }
        });
    }

    initializeHistoryBrowser() {
        const commands = [
            '.history - Show command history',
            '.clear - Clear the screen',
            '.help - Show this help message',
            '.exit - Exit the current session',
            '.tools - Manage tools'
        ];
        this.ui.readlineInterface.on('line', (line: string) => {
            if (line.trim() === '.history') {
                this.showHistory();
            } else if (line.trim() === '.clear') {
                console.clear();
            } else if (line.trim() === '.help') {
                this.showHelp();
            } else if (line.trim() === '.exit') {
                this.exitSession();
            } else if (line.trim().startsWith('.tools')) {
                const args = line.trim().split(' ').slice(1);
                this.handleToolCommand(args);
            } else {
                this.executeCommandInActiveSession(line);
                this.commandHistory.push(line);
                this.currentHistoryPage = Math.ceil(this.commandHistory.length / this.itemsPerPage);
            }
        });
    }

    showHistory() {
        if (this.commandHistory.length === 0) {
            this.ui.updateOutput('No commands in history.', 'info');
            return;
        }
        const startIndex = (this.currentHistoryPage - 1) * this.itemsPerPage;
        const endIndex = Math.min(startIndex + this.itemsPerPage, this.commandHistory.length);
        for (let i = startIndex; i < endIndex; i++) {
            this.ui.updateOutput(`${i + 1}. ${this.commandHistory[i]}`, 'info');
        }
    }

    initializeSessionManagement() {
        this.createNewSession();
    }

    handleLogCommand(command: string) {
        const [, subCommand, ...args] = command.split(' ');
        switch (subCommand) {
            case 'level':
                setLogLevel(args[0]);
                log('info', `Log level set to: ${args[0]}`, 'TerminalSessionManager');
                break;
            case 'enable':
                toggleService(args[0], true);
                log('info', `Logging enabled for service: ${args[0]}`, 'TerminalSessionManager');
                break;
            case 'disable':
                toggleService(args[0], false);
                log('info', `Logging disabled for service: ${args[0]}`, 'TerminalSessionManager');
                break;
            default:
                log('error', 'Invalid log command. Use: .log level <level> | .log enable <service> | .log disable <service>', 'TerminalSessionManager');
        }
    }

    createNewSession() {
        const newSession = new TerminalSession(this, this.chromaClient);
        this.sessions.push(newSession);
        this.activeSessionIndex = this.sessions.length - 1;
        this.switchToSession(this.activeSessionIndex, false);
    }

    switchToPreviousSession() {
        if (this.sessions.length > 1) {
            this.activeSessionIndex = (this.activeSessionIndex - 1 + this.sessions.length) % this.sessions.length;
            this.switchToSession(this.activeSessionIndex);
        }
    }

    switchToNextSession() {
        if (this.sessions.length > 1) {
            this.activeSessionIndex = (this.activeSessionIndex + 1) % this.sessions.length;
            this.switchToSession(this.activeSessionIndex);
        }
    }

    async switchToSession(index: number, showPrompt: boolean = true) {
        this.activeSessionIndex = index;
        if (this.sessions[this.activeSessionIndex]) {
            super.switchToSession(index);
            this.ui.updateOutput(`Switched to session ${this.sessions[index].id}`);
            if (showPrompt) {
                this.ui.readlineInterface.prompt();
            }
        }
    }


    async executeCommandInActiveSession(command: string) {
        if (this.sessions.length === 0) {
            this.createNewSession();
        }
        const activeSession = this.sessions[this.activeSessionIndex] as TerminalSession;
        try {
            const result = await activeSession.execute(command);
            if (result.success) {
                this.ui.updateOutput(`Result: ${JSON.stringify(result.data)}`, 'aiResponse');
            } else {
                this.ui.updateOutput(`Error: ${result.error?.message}`, 'error');
            }
        } catch (error) {
            console.error('Error executing command:', error);
            this.ui.updateOutput(`Unexpected error: ${(error as Error).message}`, 'error');
        }
    }

    saveSessionState() {
        // Implementation removed as it was related to blessed
    }

    startStatusBarUpdates() {
        setInterval(() => {
            const activeSession = this.sessions[this.activeSessionIndex];
            const sessionInfo = `${activeSession.id} (${this.activeSessionIndex + 1}/${this.sessions.length})`;
            const activeTools = this.getActiveTools();
            const memoryUsage = process.memoryUsage().heapUsed / 1024 / 1024;
            const performance = os.loadavg()[0];
            this.ui.updateOutput(`Session: ${sessionInfo} | Active Tools: ${activeTools.join(', ')} | Memory: ${memoryUsage.toFixed(2)}MB | Performance: ${performance.toFixed(2)}ms`, 'info');
        }, 10000);
    }

    getActiveTools() {
        // Implement logic to get currently active tools
        return ['Tool1', 'Tool2']; // Placeholder
    }

    showHelp() {
        const helpText = `
Commands:
.help\t\tShow this help message
.debug\tToggle debug mode on/off
.history\tShow command history for this session
.state\t\tShow current state of the session
.exit\t\tExit this session
Ctrl+A\t\tCreate a new session
Ctrl+C\t\tSwitch to the next session
.log level <level>\tSet the log level (error, warn, info, debug, verbose)
.log enable <service>\tEnable logging for a specific service
.log disable <service>\tDisable logging for a specific service
`;
        this.ui.updateOutput(boxen(helpText, { padding: 1 }));
    }

    exitSession() {
        this.sessions[this.activeSessionIndex].emit('interrupt');
    }

    async handleToolCommand(args: string[]) {
        const [subCmd, ...subArgs] = args;

        switch (subCmd) {
            case 'list':
                this.listTools();
                break;
            case 'add':
                await this.addTool(subArgs[0], subArgs[1], subArgs[2], subArgs.slice(3)); // args[0] = name, args[1] = source file, args[2] = schema, args[3] = tags
                break;
            case 'update':
                await this.updateTool(args[0], args[1]); // args[0] = name, args[1] = source file
                break;
            case 'rollback':
                await this.rollbackTool(args[0], args[1]); // args[0] = name, args[1] = version
                break;
            case 'history':
                await this.showToolHistory(subArgs[0]); // args[0] = name
                break;
            case 'help':
            default:
                this.showToolHelp();
        }
    }

    // Call a tool with error handling and fallback strategies
    async callTool(toolName: string, params: any) {
        return super.callTool(toolName, params);
    }

    async listTools() {
        const tools = await this.getToolList();
        this.ui.updateOutput(chalk.bold("Available tools:"));
        tools.forEach((tool: any) => {
            this.ui.updateOutput(` ${chalk.cyan(tool.name)} (v${tool.version})`);
        });
        return tools.map((tool: any) => tool.name);
    }


    async addTool(name: string, source: string, schema: any, tags: string[]): Promise<boolean> {
        try {
            const added = await super.addTool(name, source, schema, tags);
            if (added) {
                log('info', chalk.green(`Tool '${name}' added successfully.`), 'TerminalSession');
            } else {
                log('warn', chalk.yellow(`Tool '${name}' already exists.`), 'TerminalSession');
            }
        } catch (error) {
            log('error', chalk.red(`Error adding tool: ${error.message}`), 'TerminalSession');
            return false;
        }

        return true;
    }

    async createToolSchema(source: string) {
        const schema = this.createToolSchema(source);
        return schema;
    }

    async updateTool(name: string, sourceFile: any): Promise<boolean> {
        if (arguments.length < 2) {
            this.ui.updateOutput("Usage: .tool update <name> <source_file>", 'error');
            return false;
        }

        try {
            // get the current tool
            const tool: Tool = await this.getTool(name);
            tool.source = sourceFile.improvedFunction;
            // we need to recreate the schema
            const schema = await this.createToolSchema(sourceFile.improvedFunction);

            // update the tool
            tool.schema = schema;
            const updated: any = await tool.saveTool();
            
            if (updated) {
                this.ui.updateOutput(`Tool '${name}' updated successfully.`, 'success');
            } else {
                this.ui.updateOutput(`Tool '${name}' not found.`, 'warning');
            }
            return updated;
        } catch (error) {
            this.ui.updateOutput(`Error updating tool: ${error.message}`, 'error');
            return false;
        }
    }

    async showToolHistory(name: string) {
        if (arguments.length < 1) {
            this.ui.updateOutput("Usage: .tool history <name>", 'error');
            return;
        }
        try {
            const history = await this.getToolHistory(name);
            this.ui.updateOutput(`Version history for tool '${name}':`);
            history.forEach((version: any) => {
                this.ui.updateOutput(` v${version.version} - ${version.date}`);
            });
        } catch (error) {
            this.ui.updateOutput(`Error getting tool history: ${error.message}`, 'error');
        }
    }

    async rollbackTool(name: string, version: string): Promise<boolean> {
        if (arguments.length < 2) {
            this.ui.updateOutput("Usage: .tool rollback <name> <version>", 'error');
            return false;
        }
        try {
            const rolledBack: any = await this.rollbackTool(name, version);
            if (rolledBack) {
                this.ui.updateOutput(`Tool '${name}' rolled back to version ${version} successfully.`, 'success');
            } else {
                this.ui.updateOutput(`Failed to rollback tool '${name}' to version ${version}.`, 'warning');
            }
            return rolledBack;
        } catch (error) {
            this.ui.updateOutput(`Error rolling back tool: ${error.message}`, 'error');
            return false;
        }
    }

    showToolHelp() {
        const toolHelp = `
Tool management commands:
.tool list\t\t\tList all available tools
.tool add <name> <file> [tags]\tAdd a new tool
.tool update <name> <file>\tUpdate an existing tool
.tool rollback <name> <version>\tRollback a tool to a specific version
.tool history <name>\t\tShow version history of a tool
`;
        this.ui.updateOutput(boxen(toolHelp, { padding: 1 }));
    }
}

class TerminalSession extends AssistantSession {

    constructor(sessionManager: TerminalSessionManager, chromaClient: any) {
        super(sessionManager, chromaClient);
        this.setupUIHandlers();
        this.on('beforeExecuteCommand', (data: any) => {
            log('info', `${data.command}`, 'TerminalSession');
        });
        this.on('afterExecuteCommand', (data: any) => {
            if (data.success) {
                log('info', `Result: ${data.data}`, 'TerminalSession');
            } else {
                log('error', `Error: ${data.error}`, 'TerminalSession');
            }
            (this.sessionManager as TerminalSessionManager).ui.readlineInterface.prompt();
        });
        this.on('taskComplete', (data) => {
            log('info', `Task completed: ${data.task.name}`, 'TerminalSession');
            log('info', `Result: ${data.result}`, 'TerminalSession');
        });

        this.on('toolUpdated', (data) => {
            log('info', `Tool updated: ${data.name}`, 'TerminalSession');
        });
    }

    async execute(command: string): Promise<{ success: boolean; data: any; error?: undefined; } | { success: boolean; error: Error; data?: undefined; }> {
        try {
            this.history.push(command);
            this.working = true;

            this.emit('beforeExecuteCommand', { command });

            const result = await this.callAgent(command);

            const workflowResult: WorkflowResult = result.success !== undefined
                ? result as WorkflowResult
                : { success: true, data: result };

            this.emit('afterExecuteCommand', workflowResult);

            return workflowResult as any;
        } catch (error) {
            console.error('Error in TerminalSession execute:', error);
            const errorResult: WorkflowResult = { success: false, error: error as Error };
            this.emit('afterExecuteCommand', errorResult);
            return errorResult as any;
        } finally {
            this.working = false;
            this.emit('show-prompt');
        }
    }

    async callAgent(input: string, model = 'claude', resultVar?: string) {
        const sm: any = this.sessionManager;
        try {
            const result = await super.callAgent(input, model, resultVar);
            return result;
        } catch (error) {
            throw error;
        }
    }

    setupHandlers() {
        super.setupHandlers();
        this.on('ready', (error: any) => {
            this.onPrompt();
        });
        this.on('interrupt', (error: any) => {
            this.onInterrupt();
        });
    }

    setupUIHandlers() {
        let sm = this.sessionManager as any;

        this.on('beforeExecuteCommand', (data: any) => {
            sm.ui.updateOutput(`Executing: ${data.command}`, 'userInput');
        });

        this.on('afterExecuteCommand', (data: any) => {
            if (data.success) {
                sm.ui.updateOutput(`Result:`, 'success');
                sm.ui.displayBoxedContent(JSON.stringify(data.data, null, 2), 'Command Result');
            } else {
                sm.ui.updateOutput(`Error: ${data.error}`, 'error');
            }
        });

        this.on('taskComplete', (data: any) => {
            sm.updateOutput(`Task completed: ${data.task.name}`, 'success');
            sm.displayBoxedContent(JSON.stringify(data.result, null, 2), 'Task Result');
        });

        this.on('toolUpdated', (data: any) => {
            sm.updateOutput(`Tool updated: ${data.name}`, 'success');
        });

        this.on('ready', (error: any) => {
            this.onPrompt();
        });

        this.on('codeOutput', (data: any) => {
            sm.updateOutput(data.code, 'code');
        });
    }

    log(level: string, message: string, service: string) {
        const formattedMessage = `[${service}] ${level.toUpperCase()}: ${message}`;
        (this.sessionManager as TerminalSessionManager).ui.updateOutput(formattedMessage);
    }

    onSessionComplete({ message }: any) {
        log('info', message, 'TerminalSession');
        (this.sessionManager as TerminalSessionManager).ui.readlineInterface.prompt();
    }

    async executeSpecialCommand(command: string) {
        super.executeSpecialCommand(command);
        switch (command) {
            case '.state':
                this.showState();
                break;
            case '.exit':
                this.exitSession();
                break;
            default:
                log('error', `Unknown command: ${command}`, 'TerminalSession');
        }
        (this.sessionManager as TerminalSessionManager).ui.readlineInterface.prompt();
    }

    onBeforeEvent(data: any) {
        if (this.debug) {
            log('debug', JSON.stringify(data, null, 2), 'TerminalSession');
        }
    }

    onPrompt() {
        (this.sessionManager as TerminalSessionManager).ui.readlineInterface.prompt();
    }

    onInterrupt() {
        if (!this.working) {
            log('info', 'Goodbye!', 'TerminalSession');
            process.exit(0);
        }
        this.removeAllListeners();
        this.sessionManager.sessions = this.sessionManager.sessions.filter((session) => session.id !== this.id);
        this.sessionManager.activeSessionIndex = 0;
        this.sessionManager.switchToSession(0);

        log('info', 'Session interrupted.', 'TerminalSession');
    }

    restoreSessionState() {
        // Restore the saved output and print it to the console
        process.stdout.write(this.savedOutput);
        this.printHistory();
    }

    showHelp() {
        const helpText = `
Commands:
.help\t\tShow this help message
.debug\tToggle debug mode on/off
.history\tShow command history for this session
.state\t\tShow current state of the session
.exit\t\tExit this session
Ctrl+A\t\tCreate a new session
Ctrl+C\t\tSwitch to the next session
.log level <level>\tSet the log level (error, warn, info, debug, verbose)
.log enable <service>\tEnable logging for a specific service
.log disable <service>\tDisable logging for a specific service
`;
        log('info', boxen(helpText, { padding: 1 }), 'TerminalSession');
        return helpText;
    }

    toggleDebug() {
        this.debug = !this.debug;
        log('info', `Debug mode is now ${this.debug ? 'on' : 'off'}`, 'TerminalSession');
    }

    printHistory() {
        if (this.history.length === 0) {
            log('info', 'This session has no history yet.', 'TerminalSession');
            return;
        }
        log('info', 'Session History:', 'TerminalSession');
        this.history.forEach((command, index) => {
            log('info', `${index + 1}. ${command}`, 'TerminalSession');
        });
    }

    showState() {
        const state = {
            id: this.id,
            debug: this.debug,
            history: this.history
        };
        log('info', boxen(JSON.stringify(state, null, 2), { padding: 1 }), 'TerminalSession');
    }

    exitSession() {
        this.removeAllListeners();
        this.sessionManager.sessions = this.sessionManager.sessions.filter((session) => session.id !== this.id);
        this.sessionManager.activeSessionIndex = 0;
        this.sessionManager.switchToSession(0);
    }

    async handleToolCommand(args: string[]) {
        const [subCmd, ...subArgs] = args;

        switch (subCmd) {
            case 'list':
                this.listTools();
                break;
            case 'add':
                await this.addTool(subArgs);
                break;
            case 'update':
                await this.updateTool(args[0], args[1]); // args[0] = name, args[1] = source file
                break;
            case 'rollback':
                await this.rollbackTool(args[0], args[1]); // args[0] = name, args[1] = version
                break;
            case 'history':
                await this.showToolHistory(subArgs);
                break;
            case 'help':
            default:
                this.showToolHelp();
        }
    }

    // Call a tool with error handling and fallback strategies
    async callTool(toolName: string, params: any) {
        return super.callTool(toolName, params);
    }

    async listTools() {
        const tools = await this.sessionManager.getToolList();
        log('info', chalk.bold("Available tools:"), 'TerminalSession');
        tools.forEach((tool: any) => {
            log('info', ` ${chalk.cyan(tool.name)} (v${tool.version})`, 'TerminalSession');
        });
        return tools.map((tool: any) => tool.name);
    }

    async addTool(args: string[]) {
        if (args.length < 2) {
            log('error', "Usage: .tool add <name> <source_file> <schema> [tag1,tag2,...]", 'TerminalSession');
            return;
        }

        const [name, sourceFile, schema, tagsString] = args;
        const tags = tagsString ? tagsString.split(',') : [];

        try {
            const source: any = fs.readFileSync(sourceFile, 'utf8');
            const added = await this.sessionManager.addTool(name, source, schema, tags);
            if (added) {
                log('info', chalk.green(`Tool '${name}' added successfully.`), 'TerminalSession');
            } else {
                log('warn', chalk.yellow(`Tool '${name}' already exists.`), 'TerminalSession');
            }
        } catch (error) {
            log('error', chalk.red(`Error adding tool: ${error.message}`), 'TerminalSession');
        }
    }

    async createToolSchema(source: string) {
        const schema = this.sessionManager.createToolSchema(source);
        return schema;
    }

    async updateTool(name: string, sourceFile: string): Promise<boolean> {
        if (arguments.length < 2) {
            log('error', "Usage: .tool update <name> <source_file>", 'TerminalSession');
            return false;
        }

        try {
            // get the current tool
            const tool = await this.sessionManager.getTool(name);

            const source: any = await fs.promises.readFile(sourceFile, 'utf8');
            const updated: any = await this.sessionManager.updateTool(name, source, tool.schema, tool.tags);
            if (updated) {
                log('info', chalk.green(`Tool '${name}' updated successfully.`), 'TerminalSession');
            } else {
                log('warn', chalk.yellow(`Tool '${name}' not found.`), 'TerminalSession');
            }
            return updated;
        } catch (error) {
            log('error', chalk.red(`Error updating tool: ${error.message}`), 'TerminalSession');
            return false;
        }
    }

    async rollbackTool(name: string, version: string): Promise<boolean> {
        if (arguments.length < 2) {
            log('error', "Usage: .tool rollback <name> <version>", 'TerminalSession');
            return false;
        }
        try {
            const rolledBack: any = await this.sessionManager.rollbackTool(name, version);
            if (rolledBack) {
                log('info', chalk.green(`Tool '${name}' rolled back to version ${version} successfully.`), 'TerminalSession');
            } else {
                log('warn', chalk.yellow(`Failed to rollback tool '${name}' to version ${version}.`), 'TerminalSession');
            }
            return rolledBack;
        } catch (error) {
            log('error', chalk.red(`Error rolling back tool: ${error.message}`), 'TerminalSession');
            return false;
        }
    }

    showToolHelp() {
        const toolHelp = `
        Tool management commands:
        .tool list\t\t\tList all available tools
        .tool add <name> <file> [tags]\tAdd a new tool
        .tool update <name> <file>\tUpdate an existing tool
        .tool rollback <name> <version>\tRollback a tool to a specific version
        .tool history <name>\t\tShow version history of a tool
        `;
        log('info', boxen(toolHelp, { padding: 1 }), 'TerminalSession');
        return toolHelp;
    }

    interrupt() {
        this.emit('interrupt');
    }

    // Execute a JavaScript script with retry and error handling using vm2
    async callScript(script: string, retryLimit: number = 10): Promise<any> {
        try {
            const result = await super.callScript(script, retryLimit);
            return result;
        } finally {
            // No spinner to stop in this version
        }
    }
}


const client = new ChromaClient({
    path: 'http://localhost:8000',
});

// Main execution
const sessionManager = new TerminalSessionManager(client);

// Handle command-line arguments
const args = process.argv.slice(2);

if (args.length === 0) {
    log('info', chalk.bold.yellow(`AI Assistant CLI Version ${packageJson.version}`), 'Main');
    log('info', chalk.yellow("Type '.help' for instructions."), 'Main');
    sessionManager.ui.readlineInterface.prompt();
} else {
    const assistant = new Assistant(sessionManager, sessionManager.chromaClient);
    const maintenanceManager = new MaintenanceManager(
        assistant,
        sessionManager,
        assistant.memoryStore
    );
    setInterval(() => {
        maintenanceManager.performMaintenance();
    }, 24 * 60 * 60 * 1000);
    const query = args.join(' ');
    assistant.callAgent(query).then((response) => {
        process.exit(0);
    }).catch((error) => {
        log('error', error, 'Main');
        process.exit(1);
    })
}
.//visualization_api.ts
import { UI } from "./ui";

export class VisualizationAPI {
    constructor(private ui: UI) {}
  
    createLineChart(title: string, data: {x: number[], y: number[], title: string}) {
      this.ui.createChart('line', title, data);
    }
  
    createBarChart(title: string, data: {titles: string[], data: number[]}) {
      this.ui.createChart('bar', title, data);
    }
  
    createPieChart(title: string, data: {percent: number, label: string}[]) {
      this.ui.createChart('pie', title, data);
    }
  
    updateChart(title: string, data: any) {
      this.ui.updateChart(title, data);
    }
  }
  .//themes.ts
export interface Theme {
    name: string;
    background: string;
    foreground: string;
    border: string;
    focus: {
      border: string;
    };
    scrollbar: {
      bg: string;
    };
  }
  
  
  export const themes: { [key: string]: Theme } = {
    default: {
      name: 'Default',
      background: 'black',
      foreground: 'white',
      border: 'gray',
      focus: {
        border: 'cyan',
      },
      scrollbar: {
        bg: 'gray',
      },
    },
    light: {
      name: 'Light',
      background: 'white',
      foreground: 'black',
      border: 'gray',
      focus: {
        border: 'blue',
      },
      scrollbar: {
        bg: 'lightgray',
      },
    },
    dark: {
      name: 'Dark',
      background: '#1e1e1e',
      foreground: '#d4d4d4',
      border: '#3c3c3c',
      focus: {
        border: '#0078d4',
      },
      scrollbar: {
        bg: '#3c3c3c',
      },
    },
    highContrast: {
      name: 'High Contrast',
      background: 'black',
      foreground: 'yellow',
      border: 'white',
      focus: {
        border: 'cyan',
      },
      scrollbar: {
        bg: 'white',
      },
    },
  };.//assistant/tools/news.ts
// assistant/tools/news.ts
import axios from 'axios';
import { debugLog } from '../errorLogger'; 
import { confirmExecution, displayCodeForEdit } from '../confirmation'; // Import confirmation functions

module.exports = {
  enabled: false,
  tools: {
    search_news_api: {
      schema:  {
        'name': 'search_news_api',
        'description': 'Performs a news search using the given query.',
        'input_schema': {
          'type': 'object',
          'properties': {
            'q': {
              'type': 'string',
              'description': 'The query to search for.',
              'required': true
            },
            'from': {
              'type': 'string',
              'description': 'The start date to search for.'
            },
            'to': {
              'type': 'string',
              'description': 'The end date to search for.'
            },
            'language': {
              'type': 'string',
              'description': 'The language to search for.'
            },
            'country': {
              'type': 'string',
              'description': 'The country to search for.'
            },
            'domains': {
              'type': 'string',
              'description': 'The domains to search for.'
            },
            'sources': {
              'type': 'string',
              'description': 'The sources to search for.'
            },
            'sortBy': {
              'type': 'string',
              'description': 'The sort order to search for.'
            },
            'num': {
              'type': 'number',
              'description': 'The number of results to return.'
            }
          }
        },
        'output_schema': {
          'type': 'array',
          'description': 'An array of news articles matching the search query.',
          'items': {
            'type': 'object',
            'properties': {
              'content': {
                'type': 'string',
                'description': 'The content of the news article, truncated to 100 characters.'
              },
              'title': {
                'type': 'string',
                'description': 'The title of the news article.'
              },
              'url': {
                'type': 'string',
                'description': 'The URL of the news article.'
              }
            }
          }
        }
      },
      action: async (values: any, api: any) => { // Add api parameter
        debugLog('search_news_api called with values:', values);

        // Display confirmation before execution
        const confirmed = await confirmExecution(api, `Execute news search with query: ${values.q}?`);
        if (!confirmed) {
          return "Execution cancelled.";
        }

        const trunc = (str: any, len: any) => {
          return str.length > len ? str.substring(0, len - 3) + '...' : str;
        }
        try {
          debugLog('Calling News API with query:', values.q);
          const response = await axios.get(`https://newsapi.org/v2/everything?q=${values.q}&apiKey=${process.env.NEWS_API_KEY}`);
          debugLog('News API response:', response.data);
          const results = response.data.articles.map((item: any) => ({
            content: trunc(item.content, 100),
            title: item.title,
            url: item.url,
          }));
          let num = values.num ? values.num : 10;
          const res = results.slice(0, num);
          debugLog('Returning search results:', res);
          return JSON.stringify(res);
        } catch (error: any) {
          debugLog('Error calling News API:', error);
          return `Error calling News API: ${error.message}`
        }
      }
    }
  }
}
export default module.exports;.//assistant/tools/puppeteer.ts


// assistant/tools/puppeteer.ts
const puppeteer = require('puppeteer');
import { debugLog } from '../errorLogger';

// Function to handle different form field types
const fillFormField = async (page, fieldSelector, value) => {
  const field = await page.$(fieldSelector);
  const fieldType = await field.evaluate(el => el.tagName.toLowerCase());

  switch (fieldType) {
    case 'input':
      const inputType = await field.evaluate(el => (el.type || 'text').toLowerCase());
      if (inputType === 'radio' || inputType === 'checkbox') {
        await field.evaluate((el, value) => { el.checked = value; }, value);
      } else {
        await field.type(value);
      }
      break;
    case 'select':
      await page.select(fieldSelector, value);
      break;
    default:
      console.warn(`Unsupported field type: ${fieldType}`);
  }
};

module.exports = {
  enabled: true,
  // Option to enable/disable headless mode
  headless: true,  
  tools: {
    take_screenshot: {
      schema: {
        "name": "take_screenshot",
        "description": "Capture a screenshot of a web page",
        "input_schema": {
          "type": "object",
          "properties": {
            "url": {
              "type": "string",
              "description": "URL of the web page to capture"
            },
            "filePath": {
              "type": "string",
              "description": "File path to save the screenshot"
            }
          },
          "required": ["url", "filePath"]
        },
        "output_schema": {
          "type": "string",
          "description": "The output of the function, typically a success message."
        }
      },
      action: async ({ url, filePath }, api: any) => {
        debugLog(`take_screenshot called with url: ${url}, filePath: ${filePath}`);

        // Display confirmation before execution
        const confirmed = await confirmExecution(api, `Take screenshot of ${url} and save to ${filePath}?`);
        if (!confirmed) {
          return "Execution cancelled.";
        }

        try {
          debugLog('Launching Puppeteer browser...');
          const browser = await puppeteer.launch({ headless: module.exports.headless }); // Use headless option
          const page = await browser.newPage();
          await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'); // Set custom user agent
          debugLog(`Navigating to ${url}...`);
          await page.goto(url, { waitUntil: 'networkidle2' });
          debugLog(`Capturing screenshot to ${filePath}...`);
          await page.screenshot({ path: filePath });
          debugLog('Closing Puppeteer browser...');
          await browser.close();
          return `Screenshot saved to ${filePath}`;
        } catch (err) {
          debugLog("Error taking screenshot:", err); // Log the entire error object
          return JSON.stringify(err.message);
        }
      }
    },
    get_page_content:{
      "name": "get_page_content",
      "description": "Get the HTML content of a web page",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "URL of the web page"
          },
          "resultVar": {
            "type": "string",
            "description": "Optional. The variable name to store the result in."
          }
        },
        "required": ["url"]
      },
      "output_schema": {
        "type": "string",
        "description": "The HTML content of the web page."
      }
    },
    action: async ({ url }, api: any) => {
      debugLog(`get_page_content called with url: ${url}`);
      try {
        debugLog('Launching Puppeteer browser...');
        const browser = await puppeteer.launch({ headless: module.exports.headless }); // Use headless option
        const page = await browser.newPage();
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'); // Set custom user agent
        debugLog(`Navigating to ${url}...`);
        await page.goto(url, { waitUntil: 'networkidle2' });
        debugLog('Retrieving page content...');
        const content = await page.content();
        debugLog('Closing Puppeteer browser...');
        await browser.close();
        return content;
      } catch (err) {
        debugLog("Error getting page content:", err); // Log the entire error object
        return JSON.stringify(err.message);
      }
    }
  },
  submit_form: {
    schema: {
      "name": "submit_form",
      "description": "Submit a form on a web page",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "description": "URL of the web page"
          },
          "formSelector": {
            "type": "string",
            "description": "Selector of the form to submit"
          },
          "formData": {
            "type": "object",
            "description": "Form data to submit"
          }
        },
        "required": ["url", "formSelector", "formData"]
      },
      "output_schema": {
        "type": "string",
        "description": "The output of the function, typically a success message or the response from the server."
      }
    },
    action: async ({ url, formSelector, formData }, api: any) => {
      debugLog(`submit_form called with url: ${url}, formSelector: ${formSelector}, formData: ${JSON.stringify(formData)}`);
      try {
        debugLog('Launching Puppeteer browser...');
        const browser = await puppeteer.launch({ headless: module.exports.headless }); // Use headless option
        const page = await browser.newPage();
        await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36'); // Set custom user agent
        debugLog(`Navigating to ${url}...`);
        await page.goto(url, { waitUntil: 'networkidle2' });

        // Populate form fields
        debugLog('Populating form fields...');
        for (const [key, value] of Object.entries(formData)) {
          const fieldSelector = `${formSelector} [name="${key}"]`;
          debugLog(`Filling field ${key} with value ${value}...`);
          await fillFormField(page, fieldSelector, value); // Use the helper function
        }

        // Submit the form
        debugLog('Submitting form...');
        await page.$eval(formSelector, form => form.submit());

        debugLog('Closing Puppeteer browser...');
        await browser.close();
        return `Form submitted`;
      } catch (err) {
        debugLog("Error submitting form:", err); // Log the entire error object
        return JSON.stringify(err.message);
      }
    }
  },
}


export default module.exports;.//assistant/tools/jira.ts

// assistant/tools/jira.ts
import axios from 'axios';
import 'dotenv/config';
import { debugLog } from '../errorLogger';

async function callJIRA({ methodPath, data }: any, api: any) { // Add api parameter
  debugLog(`callJIRA called with methodPath: ${methodPath}, data: ${JSON.stringify(data)}`);

  // Display confirmation before execution
  const confirmed = await confirmExecution(api, `Call JIRA API with method path: ${methodPath}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  const url = `${config.domain}/rest/api/3/${methodPath}`;
  const auth = {
    username: config.username,
    password: config.token
  };
  try {
    debugLog(`Making JIRA API request to ${url}...`);
    const response = await axios({
      method: 'post',
      url,
      auth,
      data
    } as any);
    debugLog('JIRA API response:', response.data);
    return response.data;
  } catch (error: any) {
    debugLog('Error calling JIRA API:', error.response.data);
    return error.response.data;
  }
}

module.exports = {
  enabled: false,
  tools: {
    "call_jira": {
      schema: {
        "name": "call_jira",
        "description": "Call JIRA API",
        "input_schema": {
          "type": "object",
          "properties": {
            "methodPath": {
              "type": "string",
              "description": "The JIRA API method path"
            },
            "data": {
              "type": "object",
              "description": "The data to send to the JIRA API"
            }
          },
          "required": [
            "methodPath"
          ]
        },
        "output_schema": {
          "type": "object",
          "description": "The response from the JIRA API"
        }
      },
      action: callJIRA
    }
  },
  callJIRA
};

// JIRA API configuration obtained from environment variables for enhanced security
const config = {
  domain: process.env.JIRA_DOMAIN,
  username: process.env.JIRA_USERNAME,
  token: process.env.JIRA_API_KEY
};
.//assistant/tools/jscodeshift.ts

// assistant/tools/jscodeshift.ts
import jscodeshift from 'jscodeshift';
import fs from 'fs';
import vm from 'vm';
import { debugLog } from '../errorLogger';

module.exports = {
  enabled: true,
  tools: {
    transform_file: {
      schema: {
        "name": "transform_file",
        "description": "Apply a custom transformation to a JavaScript or TypeScript file",
        "input_schema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The path to the source code file to transform"
            },
            "transformationFilePath": {
              "type": "string",
              "description": "The path to the file containing the transformation code"
            }
          }
        },
        "output_schema": {
          "type": "string",
          "description": "The transformed file content"
        }
      },
      action: async ({ filePath, transformationFilePath }: any, api: any) => {
        try {
          debugLog(`transform_file called with filePath: ${filePath}, transformationFilePath: ${transformationFilePath}`);

          // Display code for editing and get confirmation
          const confirmed = await displayCodeForEdit(api, 
            `Transform file ${filePath} using code from ${transformationFilePath}?`, 
            transformationFilePath
          );
          if (!confirmed) {
            return "Execution cancelled.";
          }

          debugLog('Reading source code...');
          const sourceCode = fs.readFileSync(filePath, 'utf8');
          debugLog('Reading transformation code...');
          const transformationCode = fs.readFileSync(transformationFilePath, 'utf8');

          debugLog('Parsing source code with jscodeshift...');
          const j = jscodeshift.withParser('babel'); // or 'tsx' for TypeScript
          const root = j(sourceCode);

          // Create a secure context for the transformation
          debugLog('Creating secure context for transformation...');
          const context = vm.createContext({
            j, // Provide jscodeshift instance
            root, // Provide the AST root
            console, // Optionally expose console for debugging
          });

          // Execute the transformation code in the sandboxed context
          debugLog('Executing transformation code...');
          vm.runInContext(transformationCode, context);

          // Write back to the file
          debugLog('Writing transformed code back to file...');
          fs.writeFileSync(filePath, root.toSource());

          return `Transformation applied successfully.`;
        } catch (err: any) {
          debugLog('Error applying transformation:', err);
          return JSON.stringify(err.message);
        }
      }
    },
    // Additional tools for specific file-based transformations can be defined here.
  }
};

export default module.exports;.//assistant/tools/fixJson.ts


// assistant/tools/fixJson.ts
import { confirmExecution } from '../confirmation';
import { debugLog } from '../errorLogger';

export default {
  tools: {
    codemod: {
      // given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array
      // given some text content without any JSON within it, it will attempt to structure the text content into a JSON object
      schema: {
          
      },
      action: async (text: string, api: any) => {
        debugLog(`fixJson called with text: ${text}`);
         async function extractJSON(text: string): Promise<any> {
         const schema = await api.chat([{
            role: 'system',
            content: `Given some content that contains a JSON object or array, you ignore EVERYTHING BEFORE OR AFTER what is obviously JSON data, ignoring funky keys and weird data, and you output a syntactically-valid version of the JSON on a single line. If the content contains no JSON data, you output a JSON object containing the input data, structured in the most appropriate manner for the data.`,
         },{
            content: JSON.stringify(text),
          }], {}, 'gemini-1.5-flash-001');
          return schema;
        }
        return extractJSON(text);
      }
    }
  }
};.//assistant/tools/google.ts

// assistant/tools/google.ts
import 'dotenv/config';
import axios from 'axios';
import { debugLog } from '../errorLogger';

module.exports = {
  enabled: true,
  tools: {
    search_google: {
      schema: {
        "name": "search_google",
        "description": "perform a google search using the given query",
        "input_schema": {
          "type": "object",
          "properties": {
            "query": {
              "type": "string",
              "description": "The query to search for"
            }
          },
          "required": [
            "query"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The search results from Google."
        }
      },
      action: async ({ query }: any, api) => {
        debugLog(`search_google called with query: ${query}`);

        // Display confirmation before execution
        const confirmed = await confirmExecution(api, `Perform Google search with query: ${query}?`);
        if (!confirmed) {
          return "Execution cancelled.";
        }

        const config = {
          GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,
          GOOGLE_CX_ID: process.env.GOOGLE_CX_ID
        }
        try {
          debugLog('Calling Google Custom Search API...');
          const response = await axios.get(`https://www.googleapis.com/customsearch/v1?key=${config.GOOGLE_API_KEY}&cx=${config.GOOGLE_CX_ID}&q=${query}`);
          debugLog('Google Custom Search API response:', response.data);
          const results = response.data.items.map((item: any) => ({
            title: item.title,
            link: item.link
          }));
          const res = JSON.stringify(results);
          debugLog('Returning search results:', res);
          return res;
        } catch (error: any) {
          debugLog('Error calling Google Custom Search API:', error);
          return error.message;
        }
      }
    }
  }
}
export default module.exports;.//assistant/tools/execute.ts

// assistant/tools/execute.ts
const path = require('path');
const fs = require('fs').promises;
const { exec } = require('child_process');
import { debugLog } from '../errorLogger';

// Function to execute a command and handle output/errors consistently
const executeCommand = async (command) => {
  debugLog(`Executing command: ${command}`);
  return new Promise((resolve, reject) => {
    exec(command, (error, stdout, stderr) => {
      if (error) {
        debugLog(`Error executing command: ${error}`);
        reject(error); // Reject with the error object
      } else {
        debugLog(`Command output (stdout): ${stdout}`);
        debugLog(`Command output (stderr): ${stderr}`);
        // Resolve with an object containing stdout and stderr
        resolve({ stdout, stderr });
      }
    });
  });
};

// Function to create a temporary file, execute code, and clean up
const executeCodeInTempFile = async (language, code, extension) => {
  try {
    const fileName = path.join(__dirname, `${Date.now()}.${extension}`);
    const shebang = language === 'python' ? '#!/usr/bin/env python3\n' : ''; // Add shebang for Python
    debugLog(`Creating temporary file: ${fileName}`);
    await fs.writeFile(fileName, shebang + code);

    try {
      debugLog(`Executing code in temporary file: ${fileName}`);
      const { stdout, stderr }: any = await executeCommand(`${language} ${fileName}`);
      return { stdout, stderr };
    } finally {
      debugLog(`Deleting temporary file: ${fileName}`);
      await fs.unlink(fileName); // Ensure file deletion
    }
  } catch (err) {
    debugLog(`Error executing code in temporary file: ${err}`);
    throw err; // Re-throw errors for consistent handling
  }
};

export const execute_bash = async ({ command }, api) => {
  debugLog(`execute_bash called with command: ${command}`);
  // Display confirmation before execution
  const confirmed = await confirmExecution(api, `Execute Bash command: ${command}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }

  try {
    const { stdout, stderr }: any = await executeCommand(command);
    if (stderr) {
      // Log stderr for debugging but don't treat it as an error
      console.error('Bash command stderr:', stderr);
    }
    return stdout;
  } catch (error) {
    throw new Error(`Bash command execution failed: ${error.message}`);
  }
};

export const execute_nodejs_code = async ({ js }, api: any) => {
  debugLog(`execute_nodejs_code called with js: ${js}`);
  // Display confirmation before execution
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const { stdout, stderr } = await executeCodeInTempFile('node', js, 'js');
    if (stderr) {
      console.error('Node.js code stderr:', stderr);
    }
    return stdout;  
  } catch (error) {
    throw new Error(`Node.js code execution failed: ${error.message}`);
  }
};

export const execute_tsnodejs_code = async ({ js }, api: any) => {
  debugLog(`execute_tsnodejs_code called with js: ${js}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const { stdout, stderr } = await executeCodeInTempFile('ts-node', js, 'ts');
    if (stderr) {
      console.error('TypeScript code stderr:', stderr);
    }
    return stdout;  
  } catch (error) {
    throw new Error(`TypeScript code execution failed: ${error.message}`);
  }
};

export const execute_python_code = async ({ python }, api: any) => {
  debugLog(`execute_python_code called with python: ${python}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const { stdout, stderr } = await executeCodeInTempFile('python', python, 'py');
    if (stderr) {
      console.error('Python code stderr:', stderr);
    }
    return stdout;  
  } catch (error) {
    throw new Error(`Python code execution failed: ${error.message}`);
  }
};

export const execute_nodejs_file = async ({ file }, api: any) => {
  debugLog(`execute_nodejs_file called with file: ${file}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const filePath = path.isAbsolute(file) ? file : path.join(__dirname, file);
    const { stdout, stderr }: any = await executeCommand(`node ${filePath}`);
    if (stderr) {
      console.error('Node.js file stderr:', stderr);
    }
    return stdout;
  } catch (error) {
    throw new Error(`Node.js file execution failed: ${error.message}`);
  }
};

export const execute_tsnodejs_file = async ({ file }, api: any) => {
  debugLog(`execute_tsnodejs_file called with file: ${file}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const filePath = path.isAbsolute(file) ? file : path.join(__dirname, file);
    const { stdout, stderr }: any = await executeCommand(`ts-node ${filePath}`);
    if (stderr) {
    console.error('TypeScript file stderr:', stderr);
    }
    return stdout;
  } catch (error) {
    throw new Error(`TypeScript file execution failed: ${error.message}`);
  }
}

export const execute_python_file = async ({ file }, api: any) => {
  debugLog(`execute_python_file called with file: ${file}`);
  const confirmed = await confirmExecution(api, `Execute Bash command: ${js}?`);
  if (!confirmed) {
    return "Execution cancelled.";
  }
  try {
    const filePath = path.isAbsolute(file) ? file : path.join(__dirname, file);
    const { stdout, stderr }: any= await executeCommand(`python ${filePath}`);
    if (stderr) {
      console.error('Python file stderr:', stderr);
    }
    return stdout;
  } catch (error) {
    throw new Error(`Python file execution failed: ${error.message}`);
  }
};

module.exports = {
  enabled: true,
  tools: {
    execute_bash: {
      // Updated Schema
      "name": "execute_bash",
      "description": "Execute an arbitrary Bash command.",
      "input_schema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "description": "The Bash command to execute."
          }
        },
        "required": ["command"]
      },
      "output_schema": {
        "type": "string",
        "description": "The standard output of the executed Bash command."
      },
      action: execute_bash,
    },
    execute_file: {
      // Updated Schema
      "name": "execute_file",
      "description": "Execute a file containing TypeScript, JavaScript, or Python code.",
      "input_schema": {
        "type": "object",
        "properties": {
          "file": {
            "type": "string",
            "description": "The path to the source code file to execute."
          }
        },
        "required": ["file"]
      },
      "output_schema": {
        "type": "string",
        "description": "The standard output of the executed code."
      },
      action: async ({ file }: any, api: any) => {
        const ext = path.extname(file).toLowerCase(); // Use path.extname for reliability
        if (['.js', '.cjs', '.mjs'].includes(ext)) {
          return execute_nodejs_file({ file }, api);
        } else if (ext === '.ts') {
          return execute_tsnodejs_file({ file }, api);
        } else if (ext === '.py') {
          return execute_python_file({ file }, api);
        } else {
          throw new Error('Unsupported file type');  
        }
      },
    },
    execute_code: {
      // Updated Schema
      "name": "execute_code",
      "description": "Execute a code snippet in a specific language.",
      "input_schema": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "The code snippet to execute."
          },
          "language": {
            "type": "string",
            "description": "The language of the code snippet (bash, python, javascript, or typescript)."
          }
        },
        "required": ["code", "language"]
      },
      "output_schema": {
        "type": "string",
        "description": "The standard output of the executed code snippet."
      },
      action: async ({ code, language }: any, api: any) => {
        const lowerCaseLanguage = language.toLowerCase();  
        if (lowerCaseLanguage === 'bash') {
          return execute_bash({ command: code }, api);
        } else if (lowerCaseLanguage === 'python') {
          return execute_python_code({ python: code }, api);
        } else if (lowerCaseLanguage === 'javascript') {
          return execute_nodejs_code({ js: code }, api);
        } else if (lowerCaseLanguage === 'typescript') {
          return execute_tsnodejs_code({ js: code }, api);
        } else {
          throw new Error('Unsupported language');  
        }
      },
    }
  }
};

export default module.exports;
.//assistant/tools/manage_registry.ts
// assistant/tools/manage_registry.ts
// File: ./src/tools/registry_management.ts

import Assistant from '../assistant';
import { Tool } from '../tool_registry';
import { debugLog } from '../errorLogger';
import { confirmExecution } from '../confirmation';

interface RegistryManagementParams {
  action: 'list' | 'add' | 'update' | 'rollback' | 'history';
  name?: string;
  source?: string;
  tags?: string[];
  version?: string;
}

export const registryManagementTool: Tool = {
  name: 'registry_management',
  version: '1.0.0',
  description: 'Manage the tool registry',
  schema: {
    "description": "Manage the tool registry",
    "input_schema": {
      "type": "object",
      "properties": {
        "action": {
          "type": "string",
          "description": "The action to perform on the tool registry.",
          "enum": ["list", "add", "update", "rollback", "history"]
        },
        "name": {
          "type": "string",
          "description": "The name of the tool to manage."
        },
        "source": {
          "type": "string",
          "description": "The source code of the tool to add or update."
        },
        "tags": {
          "type": "array",
          "description": "The tags to add to the tool.",
          "items": {
            "type": "string"
          }
        },
        "version": {
          "type": "string",
          "description": "The version to rollback the tool to."
        }
      },
      "required": ["action"]
    },
    "output_schema": {
      "type": "any"
    }
  },
  execute: async (assistant: Assistant, params: RegistryManagementParams) => {
  debugLog(`registryManagementTool called with params: ${JSON.stringify(params)}`);
      // Display confirmation before adding the tool
    const confirmed = await confirmExecution(assistant, `Add tool '${name}' with the provided source and tags?`);
    if (!confirmed) {
      return false;
    }


    const { action, name, source, tags, version } = params;

    switch (action) {
      case 'list':
        return listTools(assistant);
      case 'add':
        return addTool(assistant, name!, source!, tags);
      case 'update':
        return updateTool(assistant, name!, source!);
      case 'rollback':
        return rollbackTool(assistant, name!, version!);
      case 'history':
        return getToolHistory(assistant, name!);
      default:
        throw new Error(`Invalid action: ${action}`);
    }
  },
};

async function listTools(assistant: Assistant): Promise<Tool[]> {
  debugLog('Listing all tools...');
  return assistant.toolRegistry.getToolList();
}

async function addTool(assistant: Assistant, name: string, source: string, schema: any, tags: string[] = []): Promise<boolean> {
  debugLog(`Adding tool: ${name} with source: ${source} and tags: ${tags}`);
  return assistant.toolRegistry.addTool(name, source, schema, tags);
}

async function updateTool(assistant: Assistant, name: string, source: string): Promise<boolean> {
  debugLog(`Updating tool: ${name} with source: ${source}`);
  return assistant.updateTool(name, source);
}

async function rollbackTool(assistant: Assistant, name: string, version: string): Promise<boolean> {
  debugLog(`Rolling back tool: ${name} to version: ${version}`);
  return assistant.rollbackTool(name, version);
}

async function getToolHistory(assistant: Assistant, name: string): Promise<string[]> {
  debugLog(`Getting history for tool: ${name}`);
  return assistant.toolRegistry.getToolHistory(name);
}
.//assistant/tools/evm.ts
// assistant/tools/evm.ts
const ethers = require('ethers');
import { debugLog } from '../errorLogger';

// Helper function to validate address
function validateAddress(address: string): boolean {
  debugLog(`Validating address: ${address}`);
  return ethers.utils.isAddress(address);
}

// Helper function to validate private key
function validatePrivateKey(privateKey: string): boolean {
  debugLog(`Validating private key: ${privateKey}`);
  return ethers.utils.isHexString(privateKey, 32);
}

// Helper function to validate ABI
function validateABI(abi: any): boolean {
  debugLog(`Validating ABI: ${JSON.stringify(abi)}`);
  return Array.isArray(abi);
}

// Helper function to validate transaction
function validateTransaction(transaction: any): boolean {
  debugLog(`Validating transaction: ${JSON.stringify(transaction)}`);
  return transaction.to && transaction.value && typeof transaction.to === 'string' && typeof transaction.value === 'string';
}

module.exports = {
  enabled: true,
  tools: {
    wallet_create: {
      schema: {
        "name": "wallet_create",
        "description": "Create a new Ethereum wallet.",
        "input_schema": {
          "type": "object",
          "properties": {
            "resultVar": {
              "type": "string",
              "description": "Optional. The variable to store the patched content in."
            }
          },
          "required": []
        },
        "output_schema": {
          "type": "string",
          "description": "The private key of the newly created wallet."
        }
      },
      action: async ({resultVar}: any, api: any) => {
        debugLog('wallet_create called');
        const wallet = ethers.Wallet.createRandom();
        debugLog(`Created new wallet with private key: ${wallet.privateKey}`);
        if (resultVar) {
          api.store[resultVar] = wallet.privateKey;
          debugLog(`Stored private key in variable: ${resultVar}`);
        }
        return wallet.privateKey;
      },
    },
    wallet_import: {
      schema: {
        "name": "wallet_import",
        "description": "Import an Ethereum wallet from a private key.",
        "input_schema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "The private key of the wallet."
            },
            "resultVar": {
              "type": "string",
              "description": "Optional. The variable to store the patched content in."
            }
          },
          "required": [
            "privateKey"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The private key of the imported wallet."
        }
      },
      action: async ({ privateKey, resultVar }:any, api: any) => {
        debugLog(`wallet_import called with privateKey: ${privateKey}`);
        if (!validatePrivateKey(privateKey)) {
          throw new Error('Invalid private key');
        }
        const wallet = new ethers.Wallet(privateKey);
        debugLog(`Imported wallet with private key: ${wallet.privateKey}`);
        if (resultVar) {
          api.store[resultVar] = wallet.privateKey;
          debugLog(`Stored private key in variable: ${resultVar}`);
        }
        return wallet.privateKey;
      },
    },
    wallet_balance: {
      schema: {
        "name": "wallet_balance",
        "description": "Get the balance of an Ethereum wallet.",
        "input_schema": {
          "type": "object",
          "properties": {
            "address": {
              "type": "string",
              "description": "The address of the wallet."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            },
            "resultVar": {
              "type": "string",
              "description": "Optional. The variable to store the patched content in."
            }
          },
          "required": [
            "address",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The balance of the wallet in ether."
        }
      },
      action: async ({ address, provider, resultVar }: any, api: any) => {
        debugLog(`wallet_balance called with address: ${address}, provider: ${provider}`);
        if (!validateAddress(address)) {
          throw new Error('Invalid Ethereum address');
        }
        debugLog(`Getting balance for address: ${address} from provider: ${provider}`);
        const balance = await new ethers.providers.JsonRpcProvider(provider).getBalance(address);
        debugLog(`Balance: ${balance}`);
        if (resultVar) {
          api.store[resultVar] = ethers.utils.formatEther(balance);
          debugLog(`Stored balance in variable: ${resultVar}`);
        }
        return ethers.utils.formatEther(balance);
      },
    },
    wallet_sendTransaction: {
      schema: {
        "name": "wallet_sendTransaction",
        "description": "Send a transaction from an Ethereum wallet.",
        "input_schema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "The private key of the wallet."
            },
            "transaction": {
              "type": "object",
              "properties": {
                "to": {
                  "type": "string",
                  "description": "The address of the recipient."
                },
                "value": {
                  "type": "string",
                  "description": "The amount to send in wei."
                },
                "gasLimit": {
                  "type": "string",
                  "description": "Optional. The gas limit for the transaction."
                },
                "nonce": {
                  "type": "number",
                  "description": "Optional. The nonce for the transaction."
                },
              },
              "required": [
                "to",
                "value"
              ]
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "privateKey",
            "transaction",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The transaction hash."
        }
      },
      action: async ({ privateKey, transaction, provider }: { privateKey: string, transaction: any, provider: string }) => {
        debugLog(`wallet_sendTransaction called with privateKey: ${privateKey}, transaction: ${JSON.stringify(transaction)}, provider: ${provider}`);
        if (!validatePrivateKey(privateKey)) {
          throw new Error('Invalid private key');
        }
        if (!validateTransaction(transaction)) {
          throw new Error('Invalid transaction object');
        }
        debugLog(`Sending transaction from wallet with private key: ${privateKey} to provider: ${provider}`);
        const wallet = new ethers.Wallet(privateKey, new ethers.providers.JsonRpcProvider(provider));
        const tx = await wallet.sendTransaction(transaction);
        debugLog(`Transaction hash: ${tx.hash}`);
        return tx.hash;
      },
    },
    wallet_estimateGas: {
      schema: {
        "name": "wallet_estimateGas",
        "description": "Estimate the gas cost of an Ethereum transaction.",
        "input_schema": {
          "type": "object",
          "properties": {
            "transaction": {
              "type": "object",
              "properties": {
                "to": {
                  "type": "string",
                  "description": "The address of the recipient."
                },
                "value": {
                  "type": "string",
                  "description": "The amount to send in wei."
                },
                "data": {
                  "type": "string",
                  "description": "Optional. The data for the transaction."
                },
              },
              "required": [
                "to",
                "value"
              ]
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "transaction",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The estimated gas cost."
        }
      },
      action: async ({ transaction, provider }: { transaction: any, provider: string }) => {
        debugLog(`wallet_estimateGas called with transaction: ${JSON.stringify(transaction)}, provider: ${provider}`);
        if (!validateTransaction(transaction)) {
          throw new Error('Invalid transaction object');
        }
        debugLog(`Estimating gas for transaction: ${JSON.stringify(transaction)} on provider: ${provider}`);
        const gasEstimate = await new ethers.providers.JsonRpcProvider(provider).estimateGas(transaction);
        debugLog(`Gas estimate: ${gasEstimate.toString()}`);
        return gasEstimate.toString();
      },
    },
    contract_deploy: {
      schema: {
        "name": "contract_deploy",
        "description": "Deploy an Ethereum smart contract.",
        "input_schema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "The private key of the wallet."
            },
            "abi": {
              "type": "string",
              "description": "The ABI of the contract, as a JSON string."
            },
            "bytecode": {
              "type": "string",
              "description": "The bytecode of the contract."
            },
            "args": {
              "type": "array",
              "description": "The arguments for the contract constructor."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "privateKey",
            "abi",
            "bytecode",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The address of the deployed contract."
        }
      },
      action: async ({ privateKey, abi, bytecode, args, provider }: { privateKey: string, abi: string, bytecode: string, args: any[], provider: string }) => {
        debugLog(`contract_deploy called with privateKey: ${privateKey}, abi: ${abi}, bytecode: ${bytecode}, args: ${JSON.stringify(args)}, provider: ${provider}`);
        if (!validatePrivateKey(privateKey)) {
          throw new Error('Invalid private key');
        }
        const parsedAbi = JSON.parse(abi);
        if (!validateABI(parsedAbi)) {
          throw new Error('Invalid ABI format');
        }
        debugLog(`Deploying contract with ABI: ${JSON.stringify(parsedAbi)} and bytecode: ${bytecode} to provider: ${provider}`);
        const wallet = new ethers.Wallet(privateKey, new ethers.providers.JsonRpcProvider(provider));
        const factory = new ethers.ContractFactory(parsedAbi, bytecode, wallet);
        const contract = await factory.deploy(...(args || []));
        await contract.deployed();
        debugLog(`Contract deployed at address: ${contract.address}`);
        return contract.address;
      },
    },
    contract_interact: {
      schema: {
        "name": "contract_interact",
        "description": "Interact with an Ethereum smart contract.",
        "input_schema": {
          "type": "object",
          "properties": {
            "privateKey": {
              "type": "string",
              "description": "The private key of the wallet."
            },
            "contractAddress": {
              "type": "string",
              "description": "The address of the contract."
            },
            "abi": {
              "type": "string",
              "description": "The ABI of the contract, as a JSON string."
            },
            "methodName": {
              "type": "string",
              "description": "The name of the method to call."
            },
            "args": {
              "type": "array",
              "description": "The arguments for the method."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "privateKey",
            "contractAddress",
            "abi",
            "methodName",
            "args",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The result of the method call."
        }
      },
      action: async ({ privateKey, contractAddress, abi, methodName, args, provider }: { privateKey: string, contractAddress: string, abi: string, methodName: string, args: any[], provider: string }) => {
        debugLog(`contract_interact called with privateKey: ${privateKey}, contractAddress: ${contractAddress}, abi: ${abi}, methodName: ${methodName}, args: ${JSON.stringify(args)}, provider: ${provider}`);
        if (!validatePrivateKey(privateKey)) {
          throw new Error('Invalid private key');
        }
        if (!validateAddress(contractAddress)) {
          throw new Error('Invalid Ethereum address');
        }
        const parsedAbi = JSON.parse(abi);
        if (!validateABI(parsedAbi)) {
          throw new Error('Invalid ABI format');
        }
        debugLog(`Interacting with contract at address: ${contractAddress} with method: ${methodName} and args: ${JSON.stringify(args)} on provider: ${provider}`);
        const wallet = new ethers.Wallet(privateKey, new ethers.providers.JsonRpcProvider(provider));
        const contract = new ethers.Contract(contractAddress, parsedAbi, wallet);
        const result = await contract[methodName](...(args || []));
        debugLog(`Method call result: ${result.toString()}`);
        return result.toString();
      },
    },
    contract_call: {
      schema: {
        "name": "contract_call",
        "description": "Call a method of an Ethereum smart contract.",
        "input_schema": {
          "type": "object",
          "properties": {
            "contractAddress": {
              "type": "string",
              "description": "The address of the contract."
            },
            "abi": {
              "type": "string",
              "description": "The ABI of the contract, as a JSON string."
            },
            "methodName": {
              "type": "string",
              "description": "The name of the method to call."
            },
            "args": {
              "type": "array",
              "description": "The arguments for the method."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "contractAddress",
            "abi",
            "methodName",
            "args",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The result of the method call."
        }
      },
      action: async ({ contractAddress, abi, methodName, args, provider }: { contractAddress: string, abi: string, methodName: string, args: any[], provider: string }) => {
        debugLog(`contract_call called with contractAddress: ${contractAddress}, abi: ${abi}, methodName: ${methodName}, args: ${JSON.stringify(args)}, provider: ${provider}`);
        if (!validateAddress(contractAddress)) {
          throw new Error('Invalid Ethereum address');
        }
        const parsedAbi = JSON.parse(abi);
        if (!validateABI(parsedAbi)) {
          throw new Error('Invalid ABI format');
        }
        debugLog(`Calling contract method: ${methodName} with args: ${JSON.stringify(args)} on provider: ${provider}`);
        const contract = new ethers.Contract(contractAddress, parsedAbi, new ethers.providers.JsonRpcProvider(provider));
        const result = await contract[methodName](...(args || []));
        debugLog(`Method call result: ${result.toString()}`);
        return result.toString();
      },
    },
    contract_events: {
      schema: {
        "name": "contract_events",
        "description": "Get events emitted by an Ethereum smart contract.",
        "input_schema": {
          "type": "object",
          "properties": {
            "contractAddress": {
              "type": "string",
              "description": "The address of the contract."
            },
            "abi": {
              "type": "string",
              "description": "The ABI of the contract, as a JSON string."
            },
            "eventName": {
              "type": "string",
              "description": "The name of the event to listen for."
            },
            "filters": {
              "type": "object",
              "description": "The filters to apply to the event."
            },
            "provider": {
              "type": "string",
              "description": "The provider URL."
            }
          },
          "required": [
            "contractAddress",
            "abi",
            "eventName",
            "filters",
            "provider"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "A JSON stringified array of event data."
        }
      },
      action: async ({ contractAddress, abi, eventName, filters, provider }: { contractAddress: string, abi: string, eventName: string, filters: any, provider: string }) => {
        debugLog(`contract_events called with contractAddress: ${contractAddress}, abi: ${abi}, eventName: ${eventName}, filters: ${JSON.stringify(filters)}, provider: ${provider}`);
        if (!validateAddress(contractAddress)) {
          throw new Error('Invalid Ethereum address');
        }
        const parsedAbi = JSON.parse(abi);
        if (!validateABI(parsedAbi)) {
          throw new Error('Invalid ABI format');
        }
        debugLog(`Getting events for contract: ${contractAddress}, event: ${eventName}, filters: ${JSON.stringify(filters)} from provider: ${provider}`);
        const contract = new ethers.Contract(contractAddress, parsedAbi, new ethers.providers.JsonRpcProvider(provider));
        const events = await contract.queryFilter(contract.filters[eventName](), filters);
        debugLog(`Events: ${JSON.stringify(events)}`);
        return JSON.stringify(events.map((event: any) => event.args));
      },
    },
    utilities_formatEther: {
      schema: {
        "name": "utilities_formatEther",
        "description": "Convert a value from wei to ether.",
        "input_schema": {
          "type": "object",
          "properties": {
            "wei": {
              "type": "string",
              "description": "The value in wei."
            }
          },
          "required": [
            "wei"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The value in ether."
        }
      },
      action: async ({ wei }: { wei: string }) => {
        debugLog(`utilities_formatEther called with wei: ${wei}`);
        const etherValue = ethers.utils.formatEther(wei);
        debugLog(`Ether value: ${etherValue}`);
        return etherValue;
      },
    },
    utilities_parseEther: {
      schema: {
        "name": "utilities_parseEther",
        "description": "Convert a value from ether to wei.",
        "input_schema": {
          "type": "object",
          "properties": {
            "ether": {
              "type": "string",
              "description": "The value in ether."
            }
          },
          "required": [
            "ether"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The value in wei."
        }
      },
      action: async ({ ether }: { ether: string }) => {
        debugLog(`utilities_parseEther called with ether: ${ether}`);
        const weiValue = ethers.utils.parseEther(ether).toString();
        debugLog(`Wei value: ${weiValue}`);
        return weiValue;
      },
    },
    utilities_hash: {
      schema: {
        "name": "utilities_hash",
        "description": "Compute the hash of a value.",
        "input_schema": {
          "type": "object",
          "properties": {
            "input": {
              "type": "string",
              "description": "The input value."
            }
          },
          "required": [
            "input"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The hash of the input value."
        }
      },
      action: async ({ input }: { input: string }) => {
        debugLog(`utilities_hash called with input: ${input}`);
        const hash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(input));
        debugLog(`Hash: ${hash}`);
        return hash;
      },
    },
    utilities_computeAddress: {
      schema: {
        "name": "utilities_computeAddress",
        "description": "Compute the address of a public key.",
        "input_schema": {
          "type": "object",
          "properties": {
            "publicKey": {
              "type": "string",
              "description": "The public key."
            }
          },
          "required": [
            "publicKey"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The address corresponding to the public key."
        }
      },
      action: async ({ publicKey }: { publicKey: string }) => {
        debugLog(`utilities_computeAddress called with publicKey: ${publicKey}`);
        const address = ethers.utils.computeAddress(publicKey);
        debugLog(`Address: ${address}`);
        return address;
      },
    },
  },
};
.//assistant/tools/codemod.ts

// assistant/tools/codemod.ts
import * as ts from 'typescript';
import * as fs from 'fs';
import { parse, tsquery } from '@phenomnomnominal/tsquery';
import { debugLog } from '../errorLogger';

import {confirmExecution} from '../confirmation';

// Define custom error types for better error handling
class FileNotFoundError extends Error {
  constructor(filePath: string) {
    super(`File not found: ${filePath}`);
    this.name = 'FileNotFoundError';
  }
}

class InvalidSelectorError extends Error {
  constructor(selector: string) {
    super(`Invalid selector: ${selector}`);
    this.name = 'InvalidSelectorError';
  }
}

class CodeSnippetError extends Error {
  constructor(message: string) {
    super(`Code snippet error: ${message}`);
    this.name = 'CodeSnippetError';
  }
}

// Interface for codemod options
interface CodemodOptions {
  codeSnippet?: string;
  newName?: string;
}

// Interface for codemod function parameters
interface CodemodParams {
  filePath: string;
  operation: string;
  selector?: string; // Use 'selector' instead of 'selectors'
  resultVar?: string;
  options?: CodemodOptions;
}

// Type guard for TypeScript nodes
const isNode = (node: any): node is ts.Node => !!node && !!node.kind;

// Function to validate and parse a code snippet
function parseCodeSnippet(codeSnippet: string, expectedNodeType?: string): ts.Statement[] {
  debugLog(`parseCodeSnippet called with codeSnippet: ${codeSnippet}, expectedNodeType: ${expectedNodeType}`);
  // Use a more descriptive temporary file name
  const snippetSourceFile = ts.createSourceFile(
    'temporarySnippet.ts',
    codeSnippet,
    ts.ScriptTarget.Latest,
    true,
  );

  const diagnostics = snippetSourceFile.statements.flatMap((statement) => {
    if (expectedNodeType && !ts[`is${expectedNodeType}`](statement)) {
      return [
        new CodeSnippetError(
          `Expected a ${expectedNodeType} but found a ${ts.SyntaxKind[statement.kind]}.`,
        ),
      ];
    }
    return [];
  });

  if (diagnostics.length > 0) {
    debugLog(`Code snippet error: ${diagnostics[0].message}`);
    throw diagnostics[0];
  }

  debugLog(`Parsed code snippet: ${JSON.stringify(snippetSourceFile.statements)}`);
  return snippetSourceFile.statements as any
}

// Function to safely update a source file with modified statements
function safelyUpdateSourceFile(
  sourceFile: ts.SourceFile,
  modifiedStatements: ts.Statement[],
): ts.SourceFile {
  debugLog(`safelyUpdateSourceFile called with modifiedStatements: ${JSON.stringify(modifiedStatements)}`);
  if (!modifiedStatements.every(isNode)) {
    throw new Error('Modified statements array contains invalid or undefined nodes.');
  }
  // function updateSourceFile(sourceFile: SourceFile, newText: string, textChangeRange: TextChangeRange, aggressiveChecks?: boolean): SourceFile;
  const updatedSourceFile = ts.factory.updateSourceFile(
    sourceFile,
    ts.factory.createNodeArray(modifiedStatements),
    sourceFile.isDeclarationFile
  );
  debugLog(`Updated source file: ${JSON.stringify(updatedSourceFile)}`);
  return updatedSourceFile;
}

// Function to append code to a source file
function appendCode(sourceFile: ts.SourceFile, codeSnippet: string): string {
  debugLog(`appendCode called with codeSnippet: ${codeSnippet}`);
  const newNodes = parseCodeSnippet(codeSnippet);
  const modifiedStatements = [...sourceFile.statements, ...newNodes];
  const updatedSourceFile = safelyUpdateSourceFile(sourceFile, modifiedStatements);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const result = printer.printFile(updatedSourceFile);
  debugLog(`Appended code to source file: ${result}`);
  return result;
}

// Function to remove a node from a source file based on a selector
function removeNode(sourceFile: ts.SourceFile, selector: string): string {
  debugLog(`removeNode called with selector: ${selector}`);
  const ast = parse(sourceFile.toString());
  const nodes = tsquery(ast as any, selector);

  if (nodes.length === 0) {
    throw new InvalidSelectorError(`No node found matching selector '${selector}' for removal.`);
  }

  const modifiedStatements = sourceFile.statements.filter(
    (statement) => !nodes.some((node) => node === statement),
  );

  const updatedSourceFile = safelyUpdateSourceFile(sourceFile, modifiedStatements);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const result = printer.printFile(updatedSourceFile);
  debugLog(`Removed node from source file: ${result}`);
  return result;
}

// Function to replace a node in a source file based on a selector
function replaceNode(sourceFile: ts.SourceFile, selector: string, codeSnippet: string): string {
  debugLog(`replaceNode called with selector: ${selector}, codeSnippet: ${codeSnippet}`);
  const parsedNodes = parseCodeSnippet(codeSnippet);
  if (parsedNodes.length !== 1) {
    throw new CodeSnippetError(
      'The code snippet must contain exactly one top-level statement for replacement.',
    );
  }

  const ast = parse(sourceFile.toString());
  const nodes = tsquery(ast as any, selector);

  if (nodes.length === 0) {
    throw new InvalidSelectorError(`No node found matching selector '${selector}' for replacement.`);
  }

  const replacementNode = parsedNodes[0];
  const modifiedStatements = sourceFile.statements.map((statement) =>
    nodes.some((node) => node === statement) ? replacementNode : statement,
  );

  const updatedSourceFile = safelyUpdateSourceFile(sourceFile, modifiedStatements);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const result = printer.printFile(updatedSourceFile);
  debugLog(`Replaced node in source file: ${result}`);
  return result;
}

// Function to find nodes in a source file based on a selector
function findNodesBySelector(sourceFile: ts.SourceFile, selector: string): ts.Node[] {
  debugLog(`findNodesBySelector called with selector: ${selector}`);
  const ast = parse(sourceFile.toString());
  const nodes = tsquery(ast as any, selector);
  debugLog(`Found nodes: ${JSON.stringify(nodes)}`);
  return nodes;
}

// Function to set information about a node based on a selector
function setNodeInfo(sourceFile: ts.SourceFile, selector: string, newName: string): string {
  debugLog(`setNodeInfo called with selector: ${selector}, newName: ${newName}`);
  const nodes = findNodesBySelector(sourceFile, selector);

  if (nodes.length === 0) {
    throw new InvalidSelectorError(`No nodes found for selector '${selector}'`);
  }
  if (nodes.length > 1) {
    throw new InvalidSelectorError(`Multiple nodes found for selector '${selector}'`);
  }

  const node = nodes[0];
  const modifiedStatements = sourceFile.statements.map((statement) => {
    if (statement === node) {
      // Use ts.factory to create a new node with the updated name
      if (ts.isFunctionDeclaration(node)) {
        return ts.factory.updateFunctionDeclaration(
          node,
          node.modifiers,
          node.asteriskToken,
          ts.factory.createIdentifier(newName),
          node.typeParameters,
          node.parameters,
          node.type,
          node.body,
        );
      } else if (ts.isClassDeclaration(node)) {
        return ts.factory.updateClassDeclaration(
          node,
          node.modifiers,
          ts.factory.createIdentifier(newName),
          node.typeParameters,
          node.heritageClauses,
          node.members,
        );
      } else if (ts.isVariableDeclaration(node)) {
        return ts.factory.updateVariableDeclaration(
          node,
          ts.factory.createIdentifier(newName),
          node.exclamationToken,
          node.type,
          node.initializer,
        );
      } else {
        throw new InvalidSelectorError(`Unsupported node type for selector '${selector}'`);
      }
    }
    return statement;
  });

  const updatedSourceFile = safelyUpdateSourceFile(sourceFile, modifiedStatements as any);
  const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });
  const result = printer.printFile(updatedSourceFile);
  debugLog(`Set node info in source file: ${result}`);
  return result;
}

// Main codemod function
const codemod = async function ({
  filePath,
  operation,
  selector,
  resultVar,
  options = {},
}: CodemodParams,
api: any): Promise<string> {
  debugLog(`codemod called with filePath: ${filePath}, operation: ${operation}, selector: ${selector}, resultVar: ${resultVar}, options: ${JSON.stringify(options)}`);
  return new Promise((resolve) => {
    try {
      if (!fs.existsSync(filePath)) {
        throw new FileNotFoundError(filePath);
      }

      debugLog(`Reading file content from: ${filePath}`);
      const fileContent = fs.readFileSync(filePath, { encoding: 'utf8' });
      const sourceFile = ts.createSourceFile(filePath, fileContent, ts.ScriptTarget.Latest, true);

      let result: string;

      // Display confirmation message based on the operation
      let confirmationMessage = "";
      switch (operation) {
        case 'append':
          confirmationMessage = `Append code to ${filePath}?`;
          break;
        case 'remove':
          confirmationMessage = `Remove code matching selector '${selector}' from ${filePath}?`;
          break;
        case 'replace':
          confirmationMessage = `Replace code matching selector '${selector}' in ${filePath} with the provided snippet?`;
          break;
        case 'get_info':
          confirmationMessage = `Get information about nodes matching selector '${selector}' in ${filePath}?`;
          break;
        case 'set_info':
          confirmationMessage = `Set information for nodes matching selector '${selector}' in ${filePath}?`;
          break;
        default:
          throw new Error(`Operation '${operation}' is not supported.`);
      }
      // Display confirmation before execution
      const confirmed = await confirmExecution(api, confirmationMessage);
      if (!confirmed) {
        return "Execution cancelled.";
      }
      if (resultVar) {
        api.store[resultVar] = fileContent;
        debugLog(`Stored result in variable: ${resultVar}`);
      }
      debugLog(`Writing result to file: ${filePath}`);
      fs.writeFileSync(filePath, fileContent, { encoding: 'utf8' });
      resolve(`Operation '${operation}' completed successfully on ${filePath}.`);
    } catch (error: any) {
      debugLog(`Error performing codemod operation: ${error.message}`);
      resolve(`Error performing operation '${operation}' on ${filePath}: ${error.message}`);
    }
  });
};

// Export the codemod function and its schema
export default {
  tools: {
    codemod: {
      schema: {
        "name": "codemod",
        "description": "Automates TypeScript/JavaScript code edits via AST.\nOperations: append, remove, replace, get_info, set_info.\nUsage: codemod <file> <operation> [selector] [--options]\nSelectors: Target functions, classes, variables using tsquery syntax (https://tsquery.github.io/).\nOptions: Code snippets, new names. \nFeatures: CLI-based, supports file and snippet manipulation, customizable through selectors and options, designed for efficient source code management.\nExecution: Node.js environment, leverages TypeScript Compiler API and tsquery.",
        "input_schema": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "The path to the TypeScript or JavaScript file to modify"
            },
            "operation": {
              "type": "string",
              "description": "The operation to perform (e.g., 'append', 'remove', 'replace', 'get_info', 'set_info')"
            },
            "selector": {
              "type": "string",
              "description": "Selector for identifying code parts using tsquery syntax (https://tsquery.github.io/)"
            },
            "resultVar": {
              "type": "string",
              "description": "Optional. The variable to store the patched content in."
            },
            "options": {
              "type": "object",
              "properties": {
                "codeSnippet": {
                  "type": "string",
                  "description": "Code snippet for append/replace operations"
                },
                "newName": {
                  "type": "string",
                  "description": "New name for the set_info operation"
                }
              },
              "description": "Additional options specific to the operation"
            }
          },
          "required": [
            "filePath",
            "operation"
          ]
        },
        "output_schema": {
          "type": "string",
          "description": "The output of the codemod operation."  
        }
      },
      action: codemod,
    },
  },
};.//assistant/types/index.d.ts
import { EventEmitter } from "eventemitter3";

export interface ToolMetrics {
  versions: string[];
  totalUpdates: number;
  lastUpdated: string;
  testResults: {
    totalRuns: number;
    passed: number;
    failed: number;
    lastRun: string | null;
  };
  executionStats: {
    totalExecutions: number;
    averageExecutionTime: number;
    lastExecutionTime: number | null;
    fastestExecutionTime: number;
    slowestExecutionTime: number;
  };
  errorRate: number;
  usageCount: number;
}

export interface Assistant extends EventEmitter {
  apiKey: string;
  vscode: any;
  tools: { [key: string]: Tool }; // Use Tool interface
  store: any;
  callAgent(input: string, onUpdate: (update: any) => void): Promise<any>;
  extractJson(content: string): any[];
  getSchemas(): {
    name: string;
    schema: any;
  }[];
  callTool: (toolName: string, params: any) => Promise<any>;
}

// Define the structure of the tool repository
export interface ToolRepo {
  [toolName: string]: {
    versions: {
      [version: string]: string; // source code for the version
    };
  };
}

export interface RegistryData {
  tools: Tool[];
}.//assistant/memory/pruner.ts
import { MemoryStore, Memory } from './store';

export class MemoryPruner {
  async pruneMemories(memoryStore: MemoryStore): Promise<void> {
    const memories = await memoryStore.listMemories();
    const memoriesToPrune = this.identifyMemoriesToPrune(memories);
    await this.removeMemories(memoryStore, memoriesToPrune);
  }

  private identifyMemoriesToPrune(memories: Memory[]): string[] {
    const LOW_CONFIDENCE_THRESHOLD = 0.3;
    const MAX_MEMORIES = 1000; // Arbitrary limit

    let memoriesToPrune: string[] = [];

    // Prune low confidence memories
    memoriesToPrune = memoriesToPrune.concat(
      memories
        .filter(memory => memory.confidence < LOW_CONFIDENCE_THRESHOLD)
        .map(memory => memory.input)
    );

    // If we're still over the limit, remove oldest memories
    if (memories.length - memoriesToPrune.length > MAX_MEMORIES) {
      const sortedMemories = memories.sort((a, b) => b.confidence - a.confidence);
      memoriesToPrune = memoriesToPrune.concat(
        sortedMemories
          .slice(MAX_MEMORIES)
          .map(memory => memory.input)
      );
    }

    return memoriesToPrune;
  }

  private async removeMemories(memoryStore: MemoryStore, memoryInputs: string[]): Promise<void> {
    for (const input of memoryInputs) {
      // Assuming MemoryStore has a removeMemory method
      await memoryStore.removeMemory(input);
    }
  }
}.//assistant/memory/confidence.ts
export class ConfidenceCalculator {
  calculateInitialConfidence(chromaConfidence: number, response: string): number {
    const lengthScore = this.calculateLengthScore(response);
    const complexityScore = this.calculateComplexityScore(response);

    // Weighted average of factors
    const confidence = (
      chromaConfidence * 0.6 +
      lengthScore * 0.2 +
      complexityScore * 0.2
    );

    return Math.min(Math.max(confidence, 0), 1); // Ensure confidence is between 0 and 1
  }

  calculateRetrievalConfidence(storedConfidence: number, chromaConfidence: number): number {
    // Combine stored confidence with Chroma's similarity score
    const combinedConfidence = (storedConfidence + chromaConfidence) / 2;
    return Math.min(Math.max(combinedConfidence, 0), 1);
  }

  updateConfidence(oldConfidence: number, chromaConfidence: number): number {
    // Exponential moving average to smooth confidence updates
    const alpha = 0.3; // Smoothing factor
    const updatedConfidence = alpha * chromaConfidence + (1 - alpha) * oldConfidence;

    return Math.min(Math.max(updatedConfidence, 0), 1); // Ensure confidence is between 0 and 1
  }

  private calculateLengthScore(response: string): number {
    const words = this.simpleTokenize(response);
    const optimalLength = 50; // Adjust based on your use case
    const lengthDifference = Math.abs(words.length - optimalLength);
    return Math.exp(-lengthDifference / optimalLength);
  }

  private calculateComplexityScore(response: string): number {
    const words = this.simpleTokenize(response);
    const uniqueWords = new Set(words);
    const lexicalDiversity = uniqueWords.size / words.length;

    // Assuming a good lexical diversity is around 0.6-0.7
    return Math.min(lexicalDiversity / 0.7, 1);
  }

  private simpleTokenize(text: string): string[] {
    // Simple word-splitting function
    return text.toLowerCase().match(/\b(\w+)\b/g) || [];
  }
}.//assistant/memory/store.ts
// MemoryStore.ts
import { ChromaClient, Collection } from 'chromadb';

export interface Memory {
  input: string;
  response: string;
  confidence: number;
}

export class MemoryStore {
  private collection: Collection;

  constructor(private chromaClient: ChromaClient) {
    this.initializeCollection();
  }

  private async initializeCollection() {
    this.collection = await this.chromaClient.getOrCreateCollection({
      name: "agent_memories",
      metadata: { "hnsw:space": "cosine" }
    });
  }

  async storeMemory(input: string, response: string, confidence: number): Promise<void> {
    const id = this.generateId();
    await this.collection.add({
      ids: [id],
      documents: [response],
      metadatas: [{ input, confidence }],
    });
  }

  async findSimilarMemories(input: string, threshold: number): Promise<Array<Memory & { similarity: number }>> {
    await this.initializeCollection();
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 5,
    });

    return results.metadatas[0].map((metadata, index) => ({
      input: metadata.input,
      response: results.documents[0][index],
      confidence: metadata.confidence,
      similarity: 1 - (results.distances[0][index] || 0)
    })).filter(memory => memory.similarity > threshold) as any;
  }

  async updateMemory(input: string, response: string, newConfidence: number): Promise<void> {
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 1,
    });

    if (results.ids[0] && results.ids[0][0]) {
      const id = results.ids[0][0];
      await this.collection.update({
        ids: [id],
        documents: [response],
        metadatas: [{ input, confidence: newConfidence }],
      });
    }
  }

  async listMemories(): Promise<Memory[]> {
    const results = await this.collection.get();
    return results.metadatas.map((metadata, index) => ({
      input: metadata.input,
      response: results.documents[index],
      confidence: metadata.confidence,
    })) as any;
  }

  async removeMemory(input: string): Promise<void> {
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 1,
    });

    if (results.ids[0] && results.ids[0][0]) {
      const id = results.ids[0][0];
      await this.collection.delete({ ids: [id] });
    }
  }

  private generateId(): string {
    return Math.random().toString(36).substring(2, 15);
  }
}.//assistant/memory/consolidator.ts
import { MemoryStore, Memory } from './store';
import { ChromaClient } from 'chromadb';
import { ConfidenceCalculator } from './confidence';
import natural from 'natural';

export class MemoryConsolidator {
  private chromaClient: ChromaClient;
  private confidenceCalculator: ConfidenceCalculator;
  private tfidf: natural.TfIdf;

  constructor(chromaClient: ChromaClient) {
    this.chromaClient = chromaClient;
    this.confidenceCalculator = new ConfidenceCalculator();
    this.tfidf = new natural.TfIdf();
  }

  async consolidateMemories(memoryStore: MemoryStore): Promise<void> {
    const memories = await memoryStore.listMemories();
    this.buildTfidfModel(memories);
    const clusters = await this.clusterSimilarMemories(memories);
    
    for (const cluster of clusters) {
      if (cluster.length > 1) {
        const consolidatedMemory = await this.mergeMemories(cluster);
        await this.updateConsolidatedMemory(memoryStore, consolidatedMemory, cluster);
      }
    }
  }

  private buildTfidfModel(memories: Memory[]): void {
    memories.forEach(memory => {
      this.tfidf.addDocument(memory.input + ' ' + memory.response);
    });
  }

  private async clusterSimilarMemories(memories: Memory[]): Promise<Memory[][]> {
    const SIMILARITY_THRESHOLD = 0.8;
    const clusters: Memory[][] = [];
    const embeddingCache: { [key: string]: number[] } = {};

    for (const memory of memories) {
      let added = false;
      const memoryEmbedding = await this.getEmbedding(memory.input + ' ' + memory.response, embeddingCache);

      for (const cluster of clusters) {
        const clusterEmbedding = await this.getEmbedding(
          cluster[0].input + ' ' + cluster[0].response,
          embeddingCache
        );
        
        if (this.cosineSimilarity(memoryEmbedding, clusterEmbedding) > SIMILARITY_THRESHOLD) {
          cluster.push(memory);
          added = true;
          break;
        }
      }

      if (!added) {
        clusters.push([memory]);
      }
    }

    return clusters;
  }

  private async getEmbedding(text: string, cache: { [key: string]: number[] }): Promise<number[]> {
    if (!cache[text]) {
     const coll = await this.chromaClient.getOrCreateCollection({
      name: "agent_memories",
      metadata: { "hnsw:space": "cosine" }
     });
     cache[text] = await coll.embeddingFunction.generate([text])[0]
    }
    return cache[text];
  }

  private cosineSimilarity(vec1: number[], vec2: number[]): number {
    const dotProduct = vec1.reduce((sum, val, i) => sum + val * vec2[i], 0);
    const mag1 = Math.sqrt(vec1.reduce((sum, val) => sum + val * val, 0));
    const mag2 = Math.sqrt(vec2.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (mag1 * mag2);
  }

  private async mergeMemories(cluster: Memory[]): Promise<Memory> {
    const combinedInput = this.combineTexts(cluster.map(m => m.input));
    const combinedResponse = this.combineTexts(cluster.map(m => m.response));
    
    const newConfidence = await this.calculateMergedConfidence(cluster, combinedInput, combinedResponse);

    return {
      input: combinedInput,
      response: combinedResponse,
      confidence: newConfidence,
    };
  }

  private combineTexts(texts: string[]): string {
    const sentences = texts.flatMap(text => text.split(/[.!?]+/).filter(s => s.trim().length > 0));
    const uniqueSentences = Array.from(new Set(sentences));
    
    uniqueSentences.sort((a, b) => {
      const scoreA = this.tfidf.tfidf(a.split(' '), 0);
      const scoreB = this.tfidf.tfidf(b.split(' '), 0);
      return scoreB - scoreA;
    });

    return uniqueSentences.join('. ') + '.';
  }

  private async calculateMergedConfidence(cluster: Memory[], combinedInput: string, combinedResponse: string): Promise<number> {
    const individualConfidences = cluster.map(m => m.confidence);
    const averageConfidence = individualConfidences.reduce((sum, conf) => sum + conf, 0) / cluster.length;
    
    const newInitialConfidence = await this.confidenceCalculator.calculateInitialConfidence(1.0, combinedResponse);
    
    return (averageConfidence + newInitialConfidence) / 2;
  }

  private async updateConsolidatedMemory(
    memoryStore: MemoryStore,
    consolidatedMemory: Memory,
    originalMemories: Memory[]
  ): Promise<void> {
    await memoryStore.storeMemory(
      consolidatedMemory.input,
      consolidatedMemory.response,
      consolidatedMemory.confidence
    );

    for (const memory of originalMemories) {
      await memoryStore.removeMemory(memory.input);
    }
  }
}.//assistant/memory/refiner.ts
import { MemoryStore, Memory } from './store';
import { ConfidenceCalculator } from './confidence';
import Conversation from '../conversation';

export class MemoryRefiner {
  private confidenceCalculator: ConfidenceCalculator;

  constructor() {
    this.confidenceCalculator = new ConfidenceCalculator();
  }

  async refineMemories(memoryStore: MemoryStore, model: string = 'claude'): Promise<void> {
    const memories = await memoryStore.listMemories();
    for (const memory of memories) {
      if (memory.confidence < 0.8) {
        const refinedResponse = await this.getRefinedResponse(memory.input, memory.response, model);
        const newConfidence = this.confidenceCalculator.updateConfidence(
          memory.confidence,
          memory.confidence // TODO: replace with Chroma's similarity score
        );
      await memoryStore.updateMemory(memory.input, refinedResponse, newConfidence);
    }
  }
}

// TODO: not gonna work, becuse it has no context of the conversation
private async getRefinedResponse(input: string, previousResponse: string, model: string): Promise<string> {
  const convo = new Conversation(model);
  const prompt = `Given the following input and previous response, please provide an improved response:
  
Input: ${input}

Previous Response: ${previousResponse}

Improved Response:`;

  const response = await convo.chat([
    { role: 'system', content: 'You are an AI assistant tasked with improving responses.' },
    { role: 'user', content: prompt }
  ]);

  return response.content[0].text;
}
}.//assistant/workflow.ts

import chalk from 'chalk';

import Assistant from './assistant';
import { MemoryRefiner } from './memory/refiner';
import { MemoryConsolidator } from './memory/consolidator';
import { MemoryPruner } from './memory/pruner';

export interface WorkflowResult {
  success: boolean;
  data?: any;
  error?: Error;
}

export class CoreWorkflow extends Assistant {

  private memoryRefiner: MemoryRefiner;
  private memoryConsolidator: MemoryConsolidator;
  private memoryPruner: MemoryPruner;
  private lastMemoryMaintenanceTime: number;

  constructor(public toolRegistry: any, chromaClient: any) {
    super(toolRegistry, chromaClient);
    this.memoryRefiner = new MemoryRefiner();
    this.memoryConsolidator = new MemoryConsolidator(chromaClient);
    this.memoryPruner = new MemoryPruner();
    this.lastMemoryMaintenanceTime = Date.now();
  }

  async execute(input: string): Promise<WorkflowResult> {
    try {
      if (input.startsWith('.')) {
        await this.executeSpecialCommand(input);
        return { success: true };
      }
      //this.setupHandlers();
      this.history.push(input);
      this.working = true;

      // Existing execute logic
      const result = await this.callAgent(input);

      // Periodically perform memory maintenance
      if (this.shouldPerformMemoryMaintenance()) {
        await this.performMemoryMaintenance();
      }

      // if result is already a WorkflowResult, return it
      if (result.success !== undefined) {
        return result;
      }

      return { success: true, data: result };
    } catch (error) {
      console.log(chalk.bold.red(error.message));
      return await this.handleError(error, input);
    } finally {
      this.removeAllListeners();
      this.working = false;
      this.emit('show-prompt');
    }
  }

  private shouldPerformMemoryMaintenance(): boolean {
    const MAINTENANCE_INTERVAL = 24 * 60 * 60 * 1000; // 24 hours
    return Date.now() - this.lastMemoryMaintenanceTime > MAINTENANCE_INTERVAL;
  }

  private async performMemoryMaintenance(): Promise<void> {
    await this.memoryRefiner.refineMemories(this.memoryStore);
    await this.memoryConsolidator.consolidateMemories(this.memoryStore);
    await this.memoryPruner.pruneMemories(this.memoryStore);
    this.lastMemoryMaintenanceTime = Date.now();
  }

  setupHandlers() {
    this.on('taskId', (taskid: any) => {
      this.on(`${taskid}_task`, (chat: any) => {
        console.log(chalk.bold.yellow('Task: ' + chat.chat));
        this.removeListener(`${taskid}_task`);
      });
      this.on(`${taskid}_chat`, (chat: any) => {
        console.log(chalk.bold.green(chat));
        this.removeListener(`${taskid}_chat`);
      });
      this.on(`${taskid}_script`, (script: any) => {
        console.log(chalk.bold.blue('Script: ' + script));
        this.removeListener(`${taskid}_script`);
      });
      this.on(`${taskid}_results`, async (result: any) => {
        this.removeListener(`${taskid}_results`);
        console.log(chalk.bold.magenta(JSON.stringify(result, null, 2)) + '\n')
        
      });
      this.on('tool_update', (data: any) => {
        console.log(chalk.bold.cyan(`Tool '${data.name}' updated to version ${data.version}`));
      });

      this.on('tool_rollback', (data: any) => {
        console.log(chalk.bold.cyan(`Tool '${data.name}' rolled back to version ${data.version}`));
      });
    });
    this.on('text', (error: any) => {
      this.debug && console.log(chalk.italic.gray(error));
    });
    this.on('error', (error: any) => {
      console.log(chalk.bold.red(error));
    });
  }

  async executeSpecialCommand(command: string) {
    switch (command) {
      case '.help':
        this.showHelp();
        break;
      case '.debug':
        this.toggleDebug();
        break;
      case '.history':
        this.printHistory();
        break;
      default:
        console.log(`Unknown command: ${command}`);
    }
  }

  restoreSessionState() {
    // Restore the saved output and print it to the console
    process.stdout.write(this.savedOutput);
    this.printHistory();
  }

  showHelp() {
    console.log("Commands:");
    console.log("  .help\t\tShow this help message");
    console.log("  .debug\t\tToggle debug mode on/off");
    console.log("  .history\tShow command history for this session");
    console.log("  .state\t\tShow current state of the session");
    console.log("  .exit\t\tExit this session");
    console.log("  Ctrl+A\t\tCreate a new session");
    console.log("  Ctrl+C\t\tSwitch to the next session");
  }

  toggleDebug() {
    this.debug = !this.debug;
    console.log(`Debug mode is now ${this.debug ? 'on' : 'off'}`);
  }

  printHistory() {
    if (this.history.length === 0) {
      console.log('This session has no history yet.');
      return;
    }
    console.log(`Session History:`);
    this.history.forEach((command, index) => {
      console.log(`${index + 1}. ${command}`);
    });
  }

  private async handleError(error: Error, context: string): Promise<WorkflowResult> {
    const errorPrompt = `An error occurred during execution. Analyze the error and context, then respond with either:
1. A modified script to retry the operation, or
2. Instructions to update a tool if it's a tooling problem.

Error: ${error.message}
Context: ${context}

Respond in JSON format:
{
  "action": "retry" | "update_tool",
  "data": "<modified script>" | { "toolName": "<name>", "updatedSource": "<source>" }
}`;

    let response = await this.conversation.chat([
      { role: 'system', content: errorPrompt },
      { role: 'user', content: JSON.stringify({ error: error.message, context }) }
    ]);
    response = response.replace(/.*```json/g, '');
    response = response.replace(/.*```/g, '');
    response = response.replace(/[\r\n]+/g, '');
    let resolution = JSON.parse(response);
    if (resolution.action === 'retry') {
      return await this.execute(resolution.data);
    } else if (resolution.action === 'update_tool') {
      await this.updateTool(resolution.data.toolName, resolution.data.updatedSource);
      return await this.execute(context);
    } else {
      return { success: false, error: new Error('Unable to resolve the error') };
    }
  }

  async updateTool(name: string, source: string): Promise<boolean> {
    const updated = await this.toolRegistry.updateTool(name, source);
    if (updated) {
      super.emit('toolUpdated', { name, source });
    } else {
      throw new Error(`Failed to update tool: ${name}`);
    }
    return updated;
  }

}.//assistant/errorLogger.ts
import fs from 'fs';

export class ErrorLogger {
  private logFilePath: string;

  constructor(logFilePath: string) {
    this.logFilePath = logFilePath;
  }

  public logError(errorDetails: any): void {
    const errorLog = {
      timestamp: new Date().toISOString(),
      ...errorDetails
    };

    const logEntry = JSON.stringify(errorLog) + '\n';
    fs.appendFileSync(this.logFilePath, logEntry);
  }

  public getErrors(): any[] {
    const logContent = fs.readFileSync(this.logFilePath, 'utf-8');
    return logContent.split('\n')
      .filter(line => line.trim() !== '')
      .map(line => JSON.parse(line));
  }

  public analyzeErrors(): any {
    const errors = this.getErrors();
    // Implement error analysis logic here
    // For example, count occurrences of each error type
    const errorCounts: { [key: string]: number } = {};
    errors.forEach(error => {
      const errorType = error.error || 'Unknown';
      errorCounts[errorType] = (errorCounts[errorType] || 0) + 1;
    });
    return errorCounts;
  }
}

export const debugLog = (message: string, data?: any) => {
  console.log(message, data);
};
.//assistant/confirmation.ts

// confirmation.ts
import blessed from 'blessed';
import contrib from 'blessed-contrib';
import fs from 'fs';

// Function to display a confirmation prompt to the user
export async function confirmExecution(api: any, message: string): Promise<boolean> {
  return new Promise((resolve) => {
    const screen = blessed.screen({
      smartCSR: true
    });

    const questionBox = blessed.question({
      parent: screen,
      border: 'line',
      height: 'shrink',
      width: 'half',
      top: 'center',
      left: 'center',
      label: ' {blue-fg}Confirmation{/blue-fg} ',
      tags: true,
      keys: true,
      vi: true,
      content: message + '\n\n{green-fg}[Y]{/green-fg}es / {red-fg}[N]{/red-fg}o',
    });

    questionBox.on('submit', (answer: any) => {
      screen.destroy();
      resolve(answer.toLowerCase() === 'y');
    });

    questionBox.key(['escape', 'n'], () => {
      screen.destroy();
      resolve(false);
    });

    questionBox.focus();
    screen.render();
  });
}

// Function to display code for editing and get confirmation
export async function displayCodeForEdit(api: any, message: string, filePath: string): Promise<boolean> {
  return new Promise((resolve) => {
    const screen = blessed.screen({
      smartCSR: true
    });

    const grid = new contrib.grid({ rows: 12, cols: 12, screen: screen });

    const editor = grid.set(0, 0, 10, 12, contrib.markdown, {
      label: ` ${filePath} `,
      keys: true,
      vi: true,
      content: fs.readFileSync(filePath, 'utf8'),
    });

    const confirmBox = grid.set(10, 0, 2, 12, blessed.box, {
      content: message + '\n\n{green-fg}[S]{/green-fg}ave & Execute / {red-fg}[C]{/red-fg}ancel',
      tags: true,
      style: {
        fg: 'white',
        bg: 'black',
        border: {
          fg: '#f0f0f0'
        },
        hover: {
          bg: 'green'
        }
      }
    });

    confirmBox.key(['escape', 'c'], () => {
      screen.destroy();
      resolve(false);
    });

    confirmBox.key(['s'], () => {
      fs.writeFileSync(filePath, editor.getText());
      screen.destroy();
      resolve(true);
    });

    screen.render();
  });
}.//assistant/tool-base.ts
export default interface ToolBase {
    execute(params, api);
}.//assistant/script/cleanupManager.ts
import ToolRegistry, { Tool } from '../tool_registry';
import { ScriptPerformanceMonitor } from './performanceMonitor';

export class ScriptCleanupManager {
  private static readonly CLEANUP_THRESHOLD = 30 * 24 * 60 * 60 * 1000; // 30 days in milliseconds

  static async cleanupUnusedScripts(toolRegistry: ToolRegistry): Promise<void> {
    const allScripts = await toolRegistry.getToolList();
    const currentDate = new Date();

    for (const script of allScripts) {
      const metrics = ScriptPerformanceMonitor.getMetrics(script.name);
      if (metrics) {
        const daysSinceLastExecution = (currentDate.getTime() - metrics.lastExecutionTime.getTime()) / (24 * 60 * 60 * 1000);
        if (daysSinceLastExecution > 30 && metrics.executionCount < 5) {
          await this.archiveScript(toolRegistry, script);
        }
      }
    }
  }

  private static async archiveScript(toolRegistry: ToolRegistry, script: Tool): Promise<void> {
    await toolRegistry.updateTool(script.name, script.source, { ...script.schema, archived: true }, script.tags);
  }
}.//assistant/script/metadataManager.ts
import ToolRegistry from '../tool_registry';

export interface ScriptMetadata {
  originalQuery: string;
  creationDate: Date;
  lastModifiedDate: Date;
  author: string;
  version: string;
  tags: string[];
  dependencies: string[];
}

export class MetadataManager {
  static async addMetadata(toolRegistry: ToolRegistry, scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    const script = await toolRegistry.getTool(scriptName);
    if (script) {
      const updatedScript = {
        ...script,
        metadata: {
          ...script.metadata,
          ...metadata,
          lastModifiedDate: new Date()
        }
      };
      await toolRegistry.updateTool(scriptName, updatedScript.source, updatedScript.schema, updatedScript.metadata);
    }
  }

  static async getMetadata(toolRegistry: ToolRegistry, scriptName: string): Promise<ScriptMetadata | null> {
    const script = await toolRegistry.getTool(scriptName);
    return script ? script.metadata : null;
  }

  static async updateMetadata(toolRegistry: ToolRegistry, scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    const script = await toolRegistry.getTool(scriptName);
    if (script) {
      const updatedScript = {
        ...script,
        metadata: {
          ...script.metadata,
          ...metadata,
          lastModifiedDate: new Date()
        }
      };
      await toolRegistry.updateTool(scriptName, updatedScript.source, updatedScript.schema, updatedScript.metadata);
    }
  }

  static async removeMetadata(toolRegistry: ToolRegistry, scriptName: string): Promise<void> {
    const script = await toolRegistry.getTool(scriptName);
    if (script) {
      const updatedScript = {
        ...script,
        metadata: {
          originalQuery: '',
          creationDate: new Date(),
          lastModifiedDate: new Date(),
        }
      };
      await toolRegistry.updateTool(scriptName, updatedScript.source, updatedScript.schema, updatedScript.metadata);
    }
  }
}.//assistant/script/performanceMonitor.ts
export class ScriptPerformanceMonitor {
    private static metrics: Map<string, {
      executionCount: number,
      totalExecutionTime: number,
      averageExecutionTime: number,
      lastExecutionTime: Date
    }> = new Map();
  
    static recordExecution(scriptName: string, executionTime: number): void {
      const metric = this.metrics.get(scriptName) || {
        executionCount: 0,
        totalExecutionTime: 0,
        averageExecutionTime: 0,
        lastExecutionTime: new Date()
      };
  
      metric.executionCount++;
      metric.totalExecutionTime += executionTime;
      metric.averageExecutionTime = metric.totalExecutionTime / metric.executionCount;
      metric.lastExecutionTime = new Date();
  
      this.metrics.set(scriptName, metric);
    }
  
    static getMetrics(scriptName: string): any {
      return this.metrics.get(scriptName);
    }
  
    static getAllMetrics(): Map<string, any> {
      return this.metrics;
    }
  }.//assistant/script/validator.ts
import * as vm from 'vm2';

export class ScriptValidator {
  static async validate(script: string): Promise<boolean> {
    const staticAnalysisResult = await this.performStaticAnalysis(script);
    if (!staticAnalysisResult.valid) return false;

    const sandboxResult = await this.runInSandbox(script);
    if (!sandboxResult.valid) return false;

    return true;
  }

  private static async performStaticAnalysis(script: string): Promise<{valid: boolean, issues?: string[]}> {
    // Implement static code analysis here
    // This could use tools like ESLint or custom rules
    return { valid: true };
  }

  private static async runInSandbox(script: string): Promise<{valid: boolean, output?: any}> {
    const sandbox = new vm.VM({
      timeout: 5000,
      sandbox: {}
    });

    try {
      sandbox.run(script);
      return { valid: true };
    } catch (error) {
      console.error('Script execution in sandbox failed:', error);
      return { valid: false, output: error.message };
    }
  }
}.//assistant/assistant.ts
import "dotenv/config";
import { EventEmitter } from "eventemitter3";
import { ErrorLogger } from './errorLogger';
import Conversation from './conversation';
import { VM, VMScript } from 'vm2';
import { tools as importedTools } from './tools';

import { MemoryStore } from './memory/store';
import { ConfidenceCalculator } from './memory/confidence';
import { ChromaClient } from 'chromadb';
import fs from "fs";
import path from "path";
import { Tool } from "./tool_registry";
import { log, setLogLevel, toggleService } from '../logger';

interface Memory {
  input: string;
  response: string;
  confidence: number;
  adjustedConfidence?: number;
  usedTools: string[];
}

const errorLogger = new ErrorLogger('error.log');

export default class Assistant extends EventEmitter {

  public memoryStore: MemoryStore;
  public confidenceCalculator: ConfidenceCalculator;

  public chatWindow: any;
  public apiKey: string = process.env.ANTHROPIC_API_KEY || '';
  public vscode: any;

  store: any;

  private globalRetryCount: number = 0;
  private globalRetryLimit: number = 100;

  protected conversation: Conversation;
  protected errorLogger: ErrorLogger = errorLogger;

  public working = false;
  public debug = false;
  public history: string[] = [];
  public savedOutput = '';

  constructor(public toolRegistry: any, public chromaClient: ChromaClient) {
    super();
    this.store = {};
    this.conversation = new Conversation('claude');
    this.memoryStore = new MemoryStore(chromaClient);
    this.confidenceCalculator = new ConfidenceCalculator();

    this.ensureToolsDirectory();

    setLogLevel('info');
    toggleService('Assistant', true);
  }

  private ensureToolsDirectory() {
    const toolsDir = path.join(__dirname, 'tools');
    if (!fs.existsSync(toolsDir)) {
      fs.mkdirSync(toolsDir, { recursive: true });
    }
  }

  private logError(message: string) {
    log('error', message, 'Assistant');
  }

  private logInfo(message: string) {
    log('info', message, 'Assistant');
  }

  private logWarn(message: string) {
    log('warn', message, 'Assistant');
  }

  private logDebug(message: string) {
    log('debug', message, 'Assistant');
  }

  async getToolRegistryReport(): Promise<string> {
    return await this.toolRegistry.generateReport();
  }

  async improveToolManually(toolName: string, newSource: string): Promise<boolean> {
    return await this.toolRegistry.updateTool(toolName, newSource);
  }

  getToolSource(toolName: string) {
    const tool = this.toolRegistry.tools[toolName];
    return tool ? tool.source : null;
  }

  get tools(): { [key: string]: Tool } {
    return this.toolRegistry.tools;
  }

  async pause(duration: number) {
    return await new Promise(resolve => setTimeout(resolve, duration));
  }

  private isRetryableError(error: any): boolean {
    const retryableErrorMessages = [
      'network timeout',
      'connection refused',
      'server unavailable',
    ];
    return retryableErrorMessages.some(message =>
      error.message.toLowerCase().includes(message)
    );
  }

  protected async retryOperation<T>(operation: () => Promise<T>, maxRetries: number, delay: number, toolName?: string): Promise<T> {
    let retries = 0;
    while (true) {
      try {
        this.globalRetryCount++;
        if (this.globalRetryCount > this.globalRetryLimit) {
          throw new Error("Global retry limit exceeded.");
        }
        await this.pause(1000);
        return await operation();
      } catch (error: any) {
        if (retries >= maxRetries || !this.isRetryableError(error)) {
          throw error;
        }

        retries++;
        const retryDelay = delay * Math.pow(2, retries);
        const message = toolName ? `Error calling tool '${toolName}': ${error.message}` : `Error: ${error.message}`;
        this.logWarn(`${message}. Retrying in ${retryDelay}ms...`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
      }
    }
  }

  async callTool(toolName: string, params: any) {
    this.logDebug(`Calling tool: ${toolName}`);
    if (Array.isArray(params)) params = params[0];

    return this.retryOperation(async () => {
      try {
        const tool = await this.toolRegistry.loadTool(toolName);
        if (!tool) {
          throw new Error(`Tool '${toolName}' not found.`);
        }

        return await this.toolRegistry.callTool(toolName, params);

      } catch (error: any) {
        if (toolName === 'ask' && error.message.includes('No response received')) {
          return "I'm sorry, but I didn't receive a response. Could you please try again?";
        } else if (toolName === 'busybox' && error.message.includes('No such file or directory')) {
          const alternativeLocation = await this.promptUser("The specified file or directory was not found. Please provide an alternative location:");
          if (alternativeLocation) {
            params.args[0] = alternativeLocation;
            return await this.callTool(toolName, params);
          }
        }
        throw error;
      }
    }, 3, 1000, toolName);
  }

  async showToolHistory(args: string[]) {
    if (args.length < 1) {
      this.logInfo("Usage: .tool history <name>");
      return;
    }

    const [name] = args;

    try {
      const history = await this.toolRegistry.getToolHistory(name);
      this.logInfo(name);
      history.forEach((entry: any) => {
        this.logInfo(`  ${entry}`);
      });
    } catch (error) {
      this.logError(`Error fetching tool history: ${error.message}`);
    }
  }

  async loadTool(name: string): Promise<Tool | undefined> {
    return await this.toolRegistry.loadTool(name);
  }

  async updateTool(name: string, source: string): Promise<boolean> {
    return await this.toolRegistry.updateTool(name, source);
  }

  async rollbackTool(name: string, version: string): Promise<boolean> {
    return await this.toolRegistry.rollbackTool(name, version);
  }

  private selectBestMemory(memories: Array<Memory & { similarity: number }>): Memory & { similarity: number } {
    return memories.reduce((best, current) =>
      (current.confidence * current.similarity > best.confidence * best.similarity) ? current : best
    );
  }

  private async adaptMemoryToInput(memory: Memory & { similarity: number }, newInput: string, model: string): Promise<string> {
    const convo = new Conversation(model);
    const prompt = `Given a new input and a similar previous experience, please adapt the previous response to fit the new input:

Previous Input: ${memory.input}
Previous Response: ${memory.response}
Tools Used: ${memory.usedTools.join(', ')}
New Input: ${newInput}

Adapted Response:`;

    const response = await convo.chat([
      { role: 'system', content: 'You are an AI assistant tasked with adapting previous responses to new inputs.' },
      { role: 'user', content: prompt }
    ]);

    return response.content[0].text;
  }

  async executeRegistryManagement(params: any): Promise<any> {
    return this.toolRegistry.tools['registry_management'].execute(this, params);
  }

  async callAgent(input: string, model = 'claude', resultVar?: string): Promise<{ success: boolean; data?: any; error?: Error; }> {
    console.log(`[callAgent] Start - input: "${input}", model: ${model}, resultVar: ${resultVar}`);
    const CONFIDENCE_THRESHOLD = 0.8;
    const SIMILARITY_THRESHOLD = 0.9;
  
    try {
      console.log(`[callAgent] Predicting likely tools`);
      const relevantTools = await this.toolRegistry.predictLikelyTools(input);
      console.log(`[callAgent] Relevant tools:`, relevantTools);
  
      console.log(`[callAgent] Finding similar memories`);
      const similarMemories = await this.memoryStore.findSimilarMemories(input, SIMILARITY_THRESHOLD);
      console.log(`[callAgent] Similar memories found:`, similarMemories.length);
  
      if (similarMemories.length > 0) {
        console.log(`[callAgent] Adjusting memory confidences`);
        const adjustedMemories = similarMemories.map(memory => ({
          ...memory,
          adjustedConfidence: this.confidenceCalculator.calculateRetrievalConfidence(memory.confidence, memory.similarity)
        }));
        const bestMemory = this.selectBestMemory(adjustedMemories as any);
        console.log(`[callAgent] Best memory confidence:`, bestMemory.adjustedConfidence);
  
        if (bestMemory.adjustedConfidence > CONFIDENCE_THRESHOLD) {
          console.log(`[callAgent] Using best memory`);
          const adaptedResponse = await this.adaptMemoryToInput(bestMemory, input, model);
          await this.updateMemoryConfidence(bestMemory);
          console.log(`[callAgent] Returning adapted response`);
          return { success: true, data: adaptedResponse };
        }
      }
  
      console.log(`[callAgent] Preparing prompt`);
      const toolsRepresentation = this.toolRegistry.getCompactRepresentation(relevantTools);
      const memoriesRepresentation = this.prepareMemoriesRepresentation(similarMemories as any);
  
      console.log(`[callAgent] Calling conversation.chat`);
      const convo = new Conversation(model);
      const response = await convo.chat([
        {
          role: 'system',
          content: jsonPrompt(toolsRepresentation, memoriesRepresentation)
        },
        {
          role: 'user',
          content: this.escapeTemplateLiteral(JSON.stringify({
            task: input,
          })),
        },
      ]);
  
      console.log(`[callAgent] Parsing response`);
      let tasks = response.content[0].text;
      tasks = tasks.replace(/```json/g, '').replace(/```/g, '');
      tasks = tasks.replace(/\n/g, '');
  
      let message = '';
      try {
        tasks = this.extractJson(tasks);
      } catch (error: any) {
        message = error.message;
      }
      if (!Array.isArray(tasks) || tasks.length === 0) {
        this.logError(message);
        throw new Error('The task must be an array of subtasks. Check the format and try again. RETURN ONLY JSON RESPONSES' + message);
      }
  
      console.log(`[callAgent] Parsed tasks:`, JSON.stringify(tasks, null, 2));
  
      const results: any = [];
      const usedTools: Set<string> = new Set();
  
      this.store[input] = tasks;
  
      if (Array.isArray(tasks) && Array.isArray(tasks[0])) {
        tasks = tasks[0];
      }
  
      if (resultVar) {
        this.store[resultVar] = results;
      }
  
      for (const task of tasks) {
        console.log(`[callAgent] Processing task:`, JSON.stringify(task, null, 2));
        let { task: taskName, script, chat } = task;
        const splitTask = taskName.split(':');
        let taskId = taskName;
        if (splitTask.length > 1) {
          taskId = splitTask[0];
          taskName = splitTask[1];
        }
        this.store['currentTaskId'] = taskId;
        this.emit('taskId', taskId);
  
        this.store[`${taskId}_task`] = task;
        this.emit(`${taskId}_task`, task);
  
        this.store[`${taskId}_chat`] = chat;
        this.emit(`${taskId}_chat`, chat);
  
        this.store[`${taskId}_script`] = script;
        this.emit(`${taskId}_script`, script);
  
        console.log(`[callAgent] Calling script:`, script);
        const sr = await this.callScript(script);
        console.log(`[callAgent] Script result:`, sr);
        task.scriptResult = sr;
  
        const toolsUsedInScript = this.extractUsedTools(script);
        toolsUsedInScript.forEach(tool => usedTools.add(tool));
  
        this.store[`${taskId}_result`] = sr;
        this.store[`${taskId}_results`] = sr;
        const rout = { id: taskId, task: taskName, script, result: sr };
        this.emit(`${taskId}_results`, rout);
  
        results.push(rout as any);
      }
  
      console.log(`[callAgent] Storing new memory`);
      const newMemory = JSON.stringify(tasks);
      const initialConfidence = this.confidenceCalculator.calculateInitialConfidence(1.0, newMemory);
      await this.memoryStore.storeMemory(input, newMemory, initialConfidence);
  
      for (const memory of similarMemories) {
        await this.updateMemoryConfidence(memory as any);
      }
  
      if (resultVar) {
        this.store[resultVar] = results;
      }
  
      console.log(`[callAgent] Optimizing scripts`);
      this.optimizeScripts(tasks);
  
      console.log(`[callAgent] End - Returning results`);
      return { success: true, data: results };
    } catch (error: any) {
      console.error(`[callAgent] Error:`, error);
      return { success: false, error: error };
    }
  }
  
  private prepareMemoriesRepresentation(memories: Array<Memory & { similarity: number }>): string {
    return memories.map(memory => `
Input: ${memory.input}
Response: ${memory.response}
Tools Used: ${memory.usedTools.join(', ')}
Confidence: ${memory.confidence}
Similarity: ${memory.similarity}
`).join('\n');
  }

  private extractUsedTools(script: string): string[] {
    const toolRegex = /tools\.(\w+)/g;
    const matches = script.match(toolRegex);
    return matches ? [...new Set(matches.map(match => match.split('.')[1]))] : [];
  }

  private async updateMemoryConfidence(memory: Memory & { similarity: number }) {
    const newConfidence = this.confidenceCalculator.updateConfidence(memory.confidence, memory.similarity);
    await this.memoryStore.updateMemory(memory.input, memory.response, newConfidence);
  }

  // async callScript(script: string, retryLimit: number = 10): Promise<any> {
  //   let retryCount = 0;

  //   while (retryCount < retryLimit) {
  //     try {
  //       // Check if this script already exists as a tool
  //       const existingTool = await this.toolRegistry.getTool(script);
  //       if (existingTool) {
  //         await this.toolRegistry.callTool(existingTool.name, {});
  //         }

  //         // If not, execute the script as before
  //         const context = this.prepareContext();
  //         const result = await this.executeScript(script, context);

  //         // After successful execution, consider adding this script as a new tool
  //         this.considerAddingAsTool(script);

  //         return result;
  //       } catch (error: any) {
  //         this.logError(`Error calling script: ${error}`);

  //         retryCount++;

  //         if (retryCount >= retryLimit) {
  //           this.errorLogger.logError({
  //             error: error.message,
  //             stackTrace: error.stack,
  //             script: script,
  //             retryAttempts: retryCount
  //           });
  //           throw new Error(`Script execution failed after ${retryLimit} attempts.`);
  //         }

  //         const errorMessage = error.message;
  //         const stackTrace: any = error.stack;
  //         const errorLine = this.extractErrorLine(stackTrace);

  //         this.errorLogger.logError({
  //           error: errorMessage,
  //           stackTrace: stackTrace,
  //           script: script,
  //           errorLine: errorLine,
  //           retryAttempts: retryCount
  //         });

  //         try {
  //           let llmResponse = await this.callTool('callLLM', {
  //             system_prompt: 'Analyze the provided script, script error, and context, generate a fixed version of the script, and output it and an explanation of your work *in a JSON object*. Output the modified script and explanation *in JSON format* { modifiedScript, explanation }. ***OUTPUT RAW JSON ONLY***.',
  //             prompt: JSON.stringify({
  //               error: errorMessage,
  //               stackTrace: stackTrace,
  //               script: this.escapeTemplateLiteral(script),
  //               errorLine: errorLine,
  //             })
  //           });

  //           if (typeof llmResponse === 'string') {
  //             llmResponse = JSON.parse(llmResponse);
  //           }

  //           const { modifiedScript, explanation } = llmResponse as any;

  //           this.logInfo(explanation);

  //           script = this.unescapeTemplateLiteral(modifiedScript);

  //         } catch (fixError) {
  //           this.logError(`Error attempting to fix the script: ${fixError}`);
  //         }

  //         await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
  //       }
  //     }

  //     throw new Error("Reached end of callScript function. This should not happen.");
  //   }
  async callScript(script: string, retryLimit: number = 10): Promise<any> {
    console.log(`[callScript] Start - script: ${script}`);
    let retryCount = 0;
  
    while (retryCount < retryLimit) {
      try {
        console.log(`[callScript] Checking if script exists as a tool`);
        const existingTool = await this.toolRegistry.getTool(script);
        if (existingTool) {
          console.log(`[callScript] Script exists as tool: ${existingTool.name}`);
          const result = await this.toolRegistry.callTool(existingTool.name, {});
          console.log(`[callScript] Tool execution result:`, result);
          return result;
        }
  
        console.log(`[callScript] Preparing context for script execution`);
        const context = this.prepareContext();
        console.log('Executing script with context keys:', Object.keys(context));
        console.log('Tools available:', Object.keys(context.tools));
        console.log('Script to execute:', script);
  
        console.log(`[callScript] Executing script`);
        const result = await this.executeScript(script, context);
        console.log(`[callScript] Script execution result:`, result);
  
        console.log(`[callScript] Considering adding script as a new tool`);
        await this.considerAddingAsTool(script);
  
        console.log(`[callScript] End - Returning result`);
        return result;
      } catch (error) {
        console.error(`[callScript] Error calling script (attempt ${retryCount + 1}/${retryLimit}):`, error);
        console.error('[callScript] Script:', script);
  
        retryCount++;
  
        if (retryCount >= retryLimit) {
          console.error(`[callScript] Retry limit reached. Throwing error.`);
          throw new Error(`Script execution failed after ${retryLimit} attempts. Last error: ${error.message}`);
        }
  
        console.log(`[callScript] Waiting ${1000 * retryCount}ms before retrying`);
        await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
      }
    }
  }
  
  private prepareContext(): any {
    const context: any = {
      tools: {},
      taskResults: {},
      console: { log: console.log, error: console.error },
      require: require,
      fs: require('fs'),
      path: require('path'),
      axios: require('axios'),
      _: require('lodash'),
    };
  
    // Add tools from the ToolRegistry
    for (const toolName in this.toolRegistry.tools) {
      const toolFunction = async (...args: any[]) => {
        return await this.toolRegistry.callTool(toolName, args);
      };
      context.tools[toolName] = toolFunction;
      context[toolName] = toolFunction;
    }
  
    // Add tools from the imported tools.ts
    for (const [toolName, tool] of Object.entries(importedTools)) {
      const toolFunction = async (...args: any[]) => {
        return await tool.execute(...args, this);
      };
      context.tools[toolName] = toolFunction;
      context[toolName] = toolFunction;
    }
  
    // Add task results to the context
    for (const task in this.store) {
      context.taskResults[task] = this.store[task];
      context[task] = this.store[task];
    }
  
    return context;
  }


  private async executeScript(script: string, context: any): Promise<any> {
    const vm = new VM({
      timeout: 5000,
      sandbox: context,
    });
  
    const wrappedScript = `
      (async function() {
        ${script}
      })();
    `;
  
    return vm.run(wrappedScript);
  }



  // private async executeScript(script: string, context: any): Promise<any> {
  //   const escapedScript = this.escapeTemplateLiteral(script);
  //   const llmResponse = await this.conversation.chat([
  //     { role: 'system', content: `You are a NON-VERBAL, CODE-OUTPUTTING agent. Refactor the provided script to ES5 to integrate it with the below template then output the Javascript VERBATIM with NO COMMENTS.` },
  //     { role: 'user', content: `with (context) { return (async function() { return (${escapedScript})({ operations }, run); })(); }` }
  //   ]);
  //   const scriptFunction = new Function('context', 'api', `
  //     return async function() {
  //       return (async function() {
  //         return (${llmResponse.content[0].text})(context, api);
  //       })();
  //     };
  //   `);

  //   const result = await scriptFunction(context, this);

  //   // Update the store with new task results
  //   for (const task in context.taskResults) {
  //     this.store[task] = context.taskResults[task];
  //   }

  //   return result;
  // }

  private async considerAddingAsTool(script: string): Promise<void> {
    // This method would analyze the script and potentially add it as a new tool
    // You can implement the logic based on your specific requirements
    await this.toolRegistry.analyzeAndCreateToolFromScript(script, "Auto-generated from successful script execution");
  }

  private async optimizeScripts(tasks: any[]): Promise<void> {
    for (const task of tasks) {
      await this.toolRegistry.improveTools();
    }
  }

  getSchemas() {
    return this.toolRegistry.schemas;
  }

  private extractErrorLine(stackTrace: string) {
    const lineRegex = /at .*? \(.*?:(\d+):\d+\)/;
    const match = stackTrace.match(lineRegex);
    return match && match[1] ? parseInt(match[1], 10) : null;
  }

  async promptUser(question: string): Promise<string> {
    return new Promise((resolve) => {
      this.logInfo(question);
      this.chatWindow = (response: string) => {
        resolve(response);
      };
    });
  }

  extractJson(content: string) {
    return extractJson(content);
  }

  private escapeTemplateLiteral(str: string): string {
    return str;
  }

  private unescapeTemplateLiteral(str: string): string {
    return str.replace(/\\`/g, '`').replace(/\\\$\{/g, '${');
  }
}

export function extractJson(content: string): any[] {
  const jsonObjects: any[] = [];
  let depth = 0;
  let currentJson = '';
  let inString = false;
  let escapeNext = false;

  for (let i = 0; i < content.length; i++) {
    const char = content[i];

    if (escapeNext) {
      currentJson += char;
      escapeNext = false;
      continue;
    }

    if (char === '\\') {
      currentJson += char;
      escapeNext = true;
      continue;
    }

    if (char === '"' && !inString) {
      inString = true;
      currentJson += char;
      continue;
    }

    if (char === '"' && inString) {
      inString = false;
      currentJson += char;
      continue;
    }

    if (!inString) {
      if (char === '{' || char === '[') {
        if (depth === 0) {
          currentJson = '';
        }
        depth++;
      } else if (char === '}' || char === ']') {
        depth--;
        if (depth === 0) {
          currentJson += char;
          try {
            const parsed = JSON.parse(currentJson);
            jsonObjects.push(parsed);
          } catch (error) {
            // If parsing fails, we don't attempt to fix it
            // as it might be intentionally escaped JSON within a string
          }
          currentJson = '';
          continue;
        }
      }
    }

    currentJson += char;
  }

  return jsonObjects;
}.//assistant/tool_registry.ts
import * as fs from 'fs';
import * as path from 'path';
import { EventEmitter } from 'events';
import Conversation from './conversation';
import { Assistant } from './types';
import { ScriptValidator } from './script/validator';
import { ScriptPerformanceMonitor } from './script/performanceMonitor';
import { ScriptCleanupManager } from './script/cleanupManager';
import { MetadataManager, ScriptMetadata } from './script/metadataManager';
import {tools} from './tools';

interface RegistryData {
  tools: Tool[];
}

export class Tool extends EventEmitter {
  public name: string;
  public description: string
  public version: string;
  public source: string;
  public tags: string[];
  public schema: any;
  public active: boolean;
  public testHarness: string;
  private _path: string;
  public lastTestResult: {
    success: boolean;
    message: string;
  } | null;
  public metrics: {
    versions: string[];
    totalUpdates: number;
    lastUpdated: string;
    testResults: {
      totalRuns: number;
      passed: number;
      failed: number;
      lastRun: string | null;
    };
    executionStats: {
      totalExecutions: number;
      averageExecutionTime: number;
      lastExecutionTime: number | null;
      fastestExecutionTime: number;
      slowestExecutionTime: number;
    };
    errorRate: number;
    usageCount: number;
  };
  public metadata: ScriptMetadata;
  get path (): string {
    return this._path;
  }

  constructor(
    private registry: ToolRegistry,
    name: string,
    version: string,
    description: string,
    source: string,
    tags: string[],
    schema: any,
    metadata?: ScriptMetadata
  ) {
    
    super();
    this.name = name;
    this.version = version;
    this.description = description;
    this.source = source;
    this.tags = tags;
    this.schema = schema;
    this.testHarness = '';
    this.lastTestResult = null;
    this.initializeMetrics();
    this._path = path.join(__dirname, `../../tool_repo/${this.name}`);
    this.metadata = metadata || {
      originalQuery: '',
      creationDate: new Date(),
      lastModifiedDate: new Date(),
      author: 'Unknown',
      version: '1.0.0',
      tags: [],
      dependencies: []
    };
  }

  private initializeMetrics(): void {
    this.metrics = {
      versions: [this.version],
      totalUpdates: 0,
      lastUpdated: new Date().toISOString(),
      testResults: {
        totalRuns: 0,
        passed: 0,
        failed: 0,
        lastRun: null,
      },
      executionStats: {
        totalExecutions: 0,
        averageExecutionTime: 0,
        lastExecutionTime: null,
        fastestExecutionTime: Infinity,
        slowestExecutionTime: 0,
      },
      errorRate: 0,
      usageCount: 0,
    };
  }

  executor(): (params: any, api: Assistant) => Promise<any> {
    return async (params: any, api: Assistant) => {
      const toolModule = await import(this.source);
      return await toolModule.default.execute(params, api);
    };
  }

  public saveMetrics(): void {
    this.registry.updateMetrics(this.name, 'version', this.version);
  }

  public async generateTestHarness(): Promise<void> {
    try {
      const messages = [
        {
          role: 'system',
          content: `You are a test coverage generator for javascript functions. Given a javascript function and its schema and description, you generate a test harness which thoroughly tests the function. You write your test harnesses in the following format:
\`\`\`javascript
const testHarness = {
    beforeAll: (context) => {
        context.log('beforeAll');
    },
    test1: (context) => {
        context.log('test1');
        context.assert(true, 'Test 1 passed');
    },
    test2: (context) => {
        context.log('test2');
    },
};
\`\`\`

You output RAW Javascript CODE ONLY. Do not include any comments or explanations in the code.`,
        },
        {
          role: 'user',
          content: `Tool Source:\n\n${JSON.stringify(this.source)}\n\nSchema:\n\n${JSON.stringify(this.schema)}\n\n`,
        },
      ];
      const response = await this.registry.conversation.chat(messages);
      this.testHarness = response.content[0].text;
      this.saveTool();
      this.emit('info', `Test harness generated for tool ${this.name}`);
    } catch (error) {
      this.emit('error', `Error generating test harness for tool ${this.name}:`, error);
    }
  }

  public async hardenToolCode(): Promise<void> {
    try {
      const messages = [
        {
          role: 'system',
          content: `You are a tool hardener. You take the given Javascript and you harden it if you see any security or execution vulnerabilities. You harden code by:
        - removing any awaiters and other intermediate-output code
        - adding any missing import statements
        - fixing any broken code. 
        - You output only RAW JAVASCRIPT, WITHOUT ANY COMMENTARY, EXPLANATION or FORMATTING.`,
        },
        {
          role: 'user',
          content: this.source,
        },
      ];
      const response = await this.registry.conversation.chat(messages);
      this.source = response.content[0].text;
      this.saveTool();
      this.emit('info', `Tool ${this.name} hardened successfully.`);
    } catch (error) {
      this.emit('error', `Error hardening tool ${this.name}:`, error);
    }
  }

  public async enhanceToolCode(): Promise<void> {
    try {
      const messages = [
        {
          role: 'system',
          content: `You are a tool enhancer. You take the given Javascript and you enhance it by:
        - enhancing options and settings
        - adding functionality which will make the tool more useful
        - adding more logging and error handling
        - You output only RAW JAVASCRIPT, WITH COMMENTARY, EXPLANATION and FORMATTING.`,
        },
        {
          role: 'user',
          content: this.source,
        },
      ];
      const response = await this.registry.conversation.chat(messages);
      this.source = response.content[0].text;
      this.saveTool();
      this.emit('info', `Tool ${this.name} enhanced successfully.`);
    } catch (error) {
      this.emit('error', `Error enhancing tool ${this.name}:`, error);
    }
  }

  public async prepareFunction(): Promise<string> {
    try {
      const messages = [
        {
          role: 'system',
          content: `You prepare javascript code for execution. You take the given Javascript and you:
        - fix any broken code
        - remove any awaiters and other intermediate-output code
        - add any missing import statements
        - Do NOT export the function, just return it as a string
        - You output only RAW JAVASCRIPT, WITH COMMENTARY, EXPLANATION and FORMATTING.`,
        },
        {
          role: 'user',
          content: this.source,
        },
      ];
      const response = await this.registry.conversation.chat(messages);
      return response.content[0].text;
    } catch (error) {
      this.emit('error', `Error preparing function for tool ${this.name}:`, error);
      throw error;
    }
  }

  public async runTests(): Promise<void> {
    if (!this.testHarness) {
      this.emit('error', `No test harness found for tool ${this.name}`);
      return;
    }
    try {
      const context = {
        log: (message: string) => this.emit('info', `[${this.name} Test] ${message}`),
        assert: (condition: boolean, message: string) => {
          this.emit('info', `[${this.name} Test] ${message}`);
          if (!condition) {
            throw new Error(message);
          }
        },
      };
      const testHarness = new Function('context', `return ${this.testHarness}`)();
      await testHarness.beforeAll(context);
      for (const key in testHarness) {
        if (key !== 'beforeAll') {
          await testHarness[key](context);
        }
      }

      this.lastTestResult = {
        success: true,
        message: 'All tests passed successfully',
      };

      this.saveTool();
      this.updateMetrics('test', { success: true });
    } catch (error) {
      this.emit('error', `Error running tests for tool ${this.name}:`, error);
      this.lastTestResult = {
        success: false,
        message: `Test failed: ${error.message}`,
      };
      this.updateMetrics('test', { success: false });
    }
  }

  public async saveTool(): Promise<void> {
    try {
      const toolIndex = this.registry.registryData.tools.findIndex(t => t.name === this.name);
      if (toolIndex === -1) {
        this.emit('error', `Tool not found: ${this.name}`);
        return;
      }
      this.registry.registryData.tools[toolIndex] = this;
      this.registry.saveRegistry();
      this.emit('info', `Tool ${this.name} saved successfully.`);
    } catch (error) {
      this.emit('error', `Error saving tool ${this.name}:`, error);
    }
  }

  public async call(params: any, parent: any): Promise<any> {
    try {
      this.updateMetrics('usage', null);
      const startTime = Date.now();
      const result = await this.executor()(params, parent);
      const endTime = Date.now();
      this.updateMetrics('execution', endTime - startTime);
      return result;
    } catch (error) {
      this.updateMetrics('error', true);
      this.emit('error', `Error executing tool ${this.name}:`, error);
      throw error;
    }
  }

  public updateMetrics(updateType: 'version' | 'test' | 'execution' | 'error' | 'usage', data: any): void {
    switch (updateType) {
      case 'version':
        this.metrics.versions.push(data);
        this.metrics.totalUpdates++;
        this.metrics.lastUpdated = new Date().toISOString();
        break;
      case 'test':
        this.metrics.testResults.totalRuns++;
        if (data.success) {
          this.metrics.testResults.passed++;
        } else {
          this.metrics.testResults.failed++;
        }
        this.metrics.testResults.lastRun = new Date().toISOString();
        break;
      case 'execution':
        const executionTime = data;
        this.metrics.executionStats.totalExecutions++;
        this.metrics.executionStats.averageExecutionTime =
          (this.metrics.executionStats.averageExecutionTime * (this.metrics.executionStats.totalExecutions - 1) + executionTime) /
          this.metrics.executionStats.totalExecutions;
        this.metrics.executionStats.lastExecutionTime = executionTime;
        this.metrics.executionStats.fastestExecutionTime = Math.min(this.metrics.executionStats.fastestExecutionTime, executionTime);
        this.metrics.executionStats.slowestExecutionTime = Math.max(this.metrics.executionStats.slowestExecutionTime, executionTime);
        break;
      case 'error':
        this.metrics.errorRate = (this.metrics.errorRate * this.metrics.usageCount + (data ? 1 : 0)) / (this.metrics.usageCount + 1);
        break;
      case 'usage':
        this.metrics.usageCount++;
        break;
    }
    this.saveMetrics();
  }
}

class ToolRegistry extends EventEmitter {
  public registryData: RegistryData;
  private registryFile: string;
  private loadedTools: Set<string>;
  private repoPath: string;
  private metricsFile: string;
  private metrics: { [key: string]: any };
  private testInterval: NodeJS.Timeout;
  public conversation: Conversation;

  constructor(registryFile: string = './.registry', repoPath: string = '../../tool_repo', metricsFile: string = './.metrics') {
    super();
    const registryFileP = path.join(__dirname, repoPath, registryFile);

    if (!fs.existsSync(registryFileP)) {
      fs.mkdirSync(path.dirname(registryFileP), { recursive: true });
      fs.writeFileSync(registryFileP, JSON.stringify({ tools: [] }), 'utf8');
    }

    this.registryFile = path.join(__dirname, repoPath, registryFile);
    this.repoPath = path.join(__dirname, repoPath);
    this.metricsFile = path.join(__dirname, repoPath, metricsFile);

    this.loadedTools = new Set();
    this.registryData = { tools: [] };
    this.conversation = new Conversation('claude');
    this.metrics = {};
    this.initializeRegistry();
    this.startContinuousTesting();
  }

  async addScriptAsTool(name: string, source: string, originalQuery: string): Promise<boolean> {
    const isValid = await ScriptValidator.validate(source);
    if (!isValid) {
      console.error(`Script ${name} failed validation`);
      return false;
    }

    const success = await this.addTool(name, source, {}, ['ai-generated']);
    if (success) {
      await MetadataManager.addMetadata(this, name, {
        originalQuery,
        creationDate: new Date(),
        author: 'AI Assistant',
        version: '1.0.0',
        tags: ['ai-generated'],
        dependencies: []
      });
    }
    return success;
  }

  async executeTool(name: string, params: any): Promise<any> {
    const startTime = Date.now();
    const result = await this.call(name, params);
    const executionTime = Date.now() - startTime;
    ScriptPerformanceMonitor.recordExecution(name, executionTime);
    return result;
  }

  async call(name: string, params: any): Promise<any> {
    const tool = this.registryData.tools.find(t => t.name === name);
    if (!tool) {
      throw new Error(`Tool not found: ${name}`);
    }
    return await tool.call(params, this as any);
  }

  async performMaintenance(): Promise<void> {
    await ScriptCleanupManager.cleanupUnusedScripts(this);
    // Other maintenance tasks...
  }

  private startContinuousTesting() {
    this.testInterval = setInterval(() => {
      this.testAndImproveTools();
    }, 3600000); // Run every hour
  }

  private async testAndImproveTools() {
    for (const tool of this.registryData.tools) {
      const testResult = await this.testTool(tool);
      if (!testResult.success) {
        await this.improveTool(tool);
      }
    }
  }

  private async testTool(tool: Tool): Promise<{ success: boolean; error?: string }> {
    if (!tool.testHarness) {
      await tool.generateTestHarness();
    }
    try {
      await tool.runTests();
      return { success: tool.lastTestResult?.success || false, error: tool.lastTestResult?.message };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }

  async improveTools(): Promise<void> {
    for (const tool of this.registryData.tools) {
      if (tool.lastTestResult && !tool.lastTestResult.success) {
        await this.improveTool(tool);
      }
    }
  }

  private async improveTool(tool: Tool): Promise<void> {
    try {
      const improvedCode = await this.conversation.chat([{
        role: 'system',
        content:
          'You are javascript developer working to improve javascript functions. Given the function\'s source code, schema, and any existing test results, <important>output an improved version of the function. If you cannot improve the function, output the original source code.</important><critical>output NO commentary, explanation or formatting</critical>',
      }, {
        role: 'user',
        content: `Tool Source: ${tool.source}\nSchema: ${JSON.stringify(tool.schema)}\nTest Results: ${JSON.stringify(tool.lastTestResult)}`,
      }], {} as any, 'gemini-1.5-flash-001');
      await this.updateTool(tool.name, improvedCode, tool.schema, tool.tags);
      this.emit('text', `Tool ${tool.name} improved based on test results`);
    } catch (error) {
      this.emit('error', `Error improving tool ${tool.name}:`, error);
    }
  }

  async updateMetrics(toolName: string, updateType: 'version' | 'test' | 'execution' | 'error' | 'usage', data: any): Promise<void> {
    if (!this.metrics[toolName]) {
      this.metrics[toolName] = {
        versions: [],
        totalUpdates: 0,
        lastUpdated: null,
        testResults: {
          totalRuns: 0,
          passed: 0,
          failed: 0,
          lastRun: null,
        },
        executionStats: {
          totalExecutions: 0,
          averageExecutionTime: 0,
          lastExecutionTime: null,
          fastestExecutionTime: Infinity,
          slowestExecutionTime: 0,
        },
        errorRate: 0,
        usageCount: 0,
      };
    }

    const metrics = this.metrics[toolName];

    switch (updateType) {
      case 'version':
        metrics.versions.push(data);
        metrics.totalUpdates++;
        metrics.lastUpdated = new Date().toISOString();
        break;
      case 'test':
        metrics.testResults.totalRuns++;
        if (data.success) {
          metrics.testResults.passed++;
        } else {
          metrics.testResults.failed++;
        }
        metrics.testResults.lastRun = new Date().toISOString();
        break;
      case 'execution':
        const executionTime = data;
        metrics.executionStats.totalExecutions++;
        metrics.executionStats.averageExecutionTime =
          (metrics.executionStats.averageExecutionTime * (metrics.executionStats.totalExecutions - 1) + executionTime) /
          metrics.executionStats.totalExecutions;
        metrics.executionStats.lastExecutionTime = executionTime;
        metrics.executionStats.fastestExecutionTime = Math.min(metrics.executionStats.fastestExecutionTime, executionTime);
        metrics.executionStats.slowestExecutionTime = Math.max(metrics.executionStats.slowestExecutionTime, executionTime);
        break;
      case 'error':
        metrics.errorRate = (metrics.errorRate * metrics.usageCount + (data ? 1 : 0)) / (metrics.usageCount + 1);
        break;
      case 'usage':
        metrics.usageCount++;
        break;
    }

    this.saveMetrics();
  }

  async generateReport(format: 'text' | 'json' = 'text'): Promise<string | object> {
    if (format === 'json') {
      return this.metrics;
    }

    let report = "Tool Registry Report\n=====================\n\n";

    for (const [toolName, toolMetrics] of Object.entries(this.metrics)) {
      report += `Tool: ${toolName}\n`;
      report += `------------------\n`;
      report += `Current Version: ${toolMetrics.versions[toolMetrics.versions.length - 1]}\n`;
      report += `Total Updates: ${toolMetrics.totalUpdates}\n`;
      report += `Last Updated: ${toolMetrics.lastUpdated}\n`;
      report += `Test Results:\n`;
      report += `  Total Runs: ${toolMetrics.testResults.totalRuns}\n`;
      report += `  Passed: ${toolMetrics.testResults.passed}\n`;
      report += `  Failed: ${toolMetrics.testResults.failed}\n`;
      report += `  Last Run: ${toolMetrics.testResults.lastRun}\n`;
      report += `Execution Stats:\n`;
      report += `  Total Executions: ${toolMetrics.executionStats.totalExecutions}\n`;
      report += `  Average Execution Time: ${toolMetrics.executionStats.averageExecutionTime.toFixed(2)}ms\n`;
      report += `  Fastest Execution Time: ${toolMetrics.executionStats.fastestExecutionTime.toFixed(2)}ms\n`;
      report += `  Slowest Execution Time: ${toolMetrics.executionStats.slowestExecutionTime.toFixed(2)}ms\n`;
      report += `  Last Execution Time: ${toolMetrics.executionStats.lastExecutionTime?.toFixed(2)}ms\n`;
      report += `Error Rate: ${(toolMetrics.errorRate * 100).toFixed(2)}%\n`;
      report += `Usage Count: ${toolMetrics.usageCount}\n\n`;
    }

    return report;
  }

  get tools(): { [key: string]: Tool } {
    return this.registryData.tools.reduce((tools, tool) => {
      tools[tool.name] = tool;
      return tools;
    }, {} as { [key: string]: Tool });
  }

  get schemas(): any {
    return this.registryData.tools.reduce((schemas, tool) => {
      schemas[tool.name] = tool.schema;
      return schemas;
    }, {} as any);
  }

  private async initializeRegistry(): Promise<void> {
    try {
      if (!fs.existsSync(this.registryFile)) {
        await this.importToolsFromFile();
      } else {
        console.log('Loading registry from file...');
        this.loadRegistry();
      }
    } catch (error) {
      console.error('Error initializing registry:', error);
      this.registryData = { tools: [] };
    }
  }

  async getToolHistory(name: string): Promise<string[]> {
    const tool = this.registryData.tools.find(t => t.name === name);
    if (!tool) {
      throw new Error(`Tool not found: ${name}`);
    }
    return this.metrics[name]?.versions || [];
  }

  private loadRegistry(): void {
    try {
      if (fs.existsSync(this.registryFile)) {
        const data = fs.readFileSync(this.registryFile, 'utf8');
        this.registryData = JSON.parse(data);
        console.log('Registry loaded successfully.');
      } else {
        this.registryData = { tools: [] };
        this.importToolsFromFile();
      }
    } catch (error) {
      console.error('Error loading registry:', error);
      this.registryData = { tools: [] };
    }
  }

  public saveRegistry(): void {
    try {
      const registryDataWithoutCircular = JSON.parse(JSON.stringify(this.registryData, (key, value) =>
        key === 'registry' || key === '_client' ? undefined : value
      ));
      const data = JSON.stringify(registryDataWithoutCircular, null, 2);
      fs.writeFileSync(this.registryFile, data, 'utf8');
      console.log('Registry saved successfully.');
    } catch (error) {
      console.error('Error saving registry:', error);
    }
  }

  private async importToolsFromFile(): Promise<void> {
    try {
      const toolsModule = await import('./tools');
      for (const [name, tool] of Object.entries(toolsModule.tools)) {
        await this.addTool(name, tool.execute.toString(), tool.schema || {}, tool.tags || []);
      }
      console.log('Tools imported from tools.ts file.');
    } catch (error) {
      console.error('Error importing tools from file:', error);
    }
  }

  public async getToolList(): Promise<Tool[]> {
    return this.registryData.tools;
  }

  public async createToolSchema(tool: string): Promise<any> {
    try {
      const messages = [{
        role: 'system',
        content: "Given the source code of a tool, you generate a schema for it. Example schema 1: { 'name': 'file', 'description': 'Performs file operations like read, write, append, prepend, replace, insert, remove, delete, copy', 'input_schema': { 'type': 'object', 'properties': { 'operation': { 'type': 'string', 'description': 'The operation to perform on the file. Supported operations: read, write, append, prepend, replace, insert_at, remove, delete, copy', 'enum': ['read', 'write', 'append', 'prepend', 'replace', 'insert_at', 'remove', 'delete', 'copy'], }, 'path': { 'type': 'string', 'description': 'The path to the file. Required for all operations except 'list_attached'.', }, 'match': { 'type': 'string', 'description': 'The string or regex pattern to match. Required for 'replace' and 'remove' operations.', }, 'data': { 'type': 'string', 'description': 'The data to write, append, prepend, replace, or insert. Required for 'write', 'append', 'prepend', 'replace', and 'insert_at' operations.', }, 'position': { 'type': 'number', 'description': 'The position to insert the data at. Required for 'insert_at' operation.', }, 'target': { 'type': 'string', 'description': 'The target path for the 'copy' operation.', }, }, 'required': ['operation'], }, 'output_schema': { 'type': 'string', 'description': 'A message indicating the result of the file operation.', }, }\n\nExample Schema 2: {'name': 'files', 'description': 'Performs batch file operations.', 'input_schema': {'type': 'object', 'properties': {'operations': {'type': 'array', 'description': 'An array of file operations to perform.', 'items': {'type': 'object', 'properties': {'operation': {'type': 'string', 'description': 'The operation to perform on the file.', 'enum': ['read', 'append', 'prepend', 'replace', 'insert_at', 'remove', 'delete', 'copy', 'attach', 'list_attached', 'detach']}, 'path': {'type': 'string', 'description': 'The path to the file. Required for all operations except 'list_attached'.', }, 'match': {'type': 'string', 'description': 'The string or regex pattern to match. Required for 'replace' and 'remove' operations.', }, 'data': {'type': 'string', 'description': 'The data to write, append, prepend, replace, or insert. Required for 'write', 'append', 'prepend', 'replace', and 'insert_at' operations.', }, 'position': {'type': 'number', 'description': 'The position to insert the data at. Required for 'insert_at' operation.', }, 'target': {'type': 'string', 'description': 'The target path for the 'copy' operation.', }, }, 'required': ['operation']}}}, 'required': ['operations']}, 'output_schema': {'type': 'string', 'description': 'A message indicating the result of the batch file operations.'}},",
      }, {
        role: 'user',
        content: 'Examine the source code of the tool and generate a schema for it: ' + JSON.stringify(tool)
      }];
      const response = await this.conversation.chat(messages);
      return JSON.parse(response.content[0].text);
    } catch (error) {
      console.error(`Error creating schema for tool ${tool}:`, error);
      throw error;
    }
  }

  public async cleanupToolCode(tool: string): Promise<string> {
    try {
      const messages = [{
        role: 'system',
        content: `You take the given Javascript and you:

1. fix any broken code, 
2. rewrite the function to remove awaiters and other intermediate-output code 
3. add any missing import statements - for example use \`const fs = await import('fs');\` for file system operations
4. Do NOT export the function, just return it as a string
5. FORMAT THE FUNCTION NICELY OVER MULTIPLE LINES

You output only RAW JAVASCRIPT, WITHOUT ANY COMMENTARY, EXPLANATION or FORMATTING`
      }, {
        role: 'user',
        content: tool
      }];
      let response = await this.conversation.chat(messages);
      response = response.content[0].text;
      response = response.replace(/.*```javascript/g, '');
      response = response.replace(/.*```/g, '');
      response = response.replace(/[\r\n]+/g, '');
      return response;
    } catch (error) {
      console.error(`Error cleaning up tool code for ${tool}:`, error);
      throw error;
    }
  }

  public async addToolSchema(tool: string, schema: any): Promise<boolean> {
    try {
      const toolIndex = this.registryData.tools.findIndex(t => t.name === tool);
      if (toolIndex === -1) {
        console.error(`Tool not found: ${tool}`);
        return false;
      }
      this.registryData.tools[toolIndex].schema = schema;
      this.saveRegistry();
      console.log(`Schema added for tool ${tool}`);
      return true;
    } catch (error) {
      console.error(`Error adding schema to tool ${tool}:`, error);
      return false;
    }
  }

  async loadTool(name: string): Promise<any | null> {
    try {
      if (this.loadedTools.has(name)) {
        console.log(`Tool ${name} already loaded.`);
        return null;
      }

      const tool = this.registryData.tools.find(t => t.name === name);
      if (!tool) {
        console.error(`Tool not found: ${name}`);
        return null;
      }

      const toolModule = await import(`${this.repoPath}/${name}.js`);
      this.loadedTools.add(name);
      console.log(`Tool ${name} loaded successfully.`);
      return toolModule.default;
    } catch (error) {
      console.error(`Error loading tool ${name}:`, error);
      return null;
    }
  }

  async updateTool(name: string, source: string, schema: any, tags: any): Promise<boolean> {
    try {
      const toolIndex = this.registryData.tools.findIndex(t => t.name === name);
      if (toolIndex === -1) {
        console.error(`Tool not found: ${name}`);
        return false;
      }

      const tool: Tool = this.registryData.tools[toolIndex];
      const newVersion = this.incrementVersion(tool.version);

      tool.version = newVersion;
      tool.tags = tags;
      tool.active = true;
      this.saveRegistry();

      if ((schema && schema !== tool.schema) || source) {
        source && (tool.source = source);
        schema && (tool.schema = schema);

        if (schema) {
          // Save schema to metadata
          const metadata: any = await MetadataManager.getMetadata(this, name);
          metadata.schema = schema;

          await MetadataManager.updateMetadata(this, name, metadata);
        }

        // re-run tests
        await tool.generateTestHarness();

        // Update metrics
        this.updateMetrics(name, 'version', newVersion);
      }

      await this.saveToolToRepo(name, source, newVersion);
      console.log(`Tool ${name} updated to version ${newVersion}.`);
      this.updateMetrics(name, 'version', newVersion);
      return true;
    } catch (error) {
      console.error(`Error updating tool ${name}:`, error);
      return false;
    }
  }

  validateToolInput(toolName: string, params: any): { valid: boolean; errors: any[] } {
    const tool = this.tools[toolName];
    if (!tool || !tool.schema) {
      return { valid: true, errors: [] };
    }
    // Implement input validation logic here
    return { valid: true, errors: [] };
  }

  private async saveToolToRepo(name: string, source: string, version: string): Promise<void> {
    try {
      const filePath = path.join(this.repoPath, `${name}.js`);
      fs.mkdirSync(path.dirname(filePath), { recursive: true });
      fs.writeFileSync(filePath, source);
      console.log(`Tool ${name} v${version} saved to repository successfully.`);
    } catch (error) {
      console.error(`Error saving tool ${name} to repository:`, error);
    }
  }

  async callTool(name: string, params: any): Promise<any> {
    const tool = this.tools[name];
    if (!tool) throw new Error(`Tool not found: ${name}`);
  
    try {
      const startTime = Date.now();
      const toolModule = await import(tool.path);
      const result = await toolModule.default(params, this);
      const endTime = Date.now();
      const executionTime = endTime - startTime;
      this.updateMetrics(name, 'execution', executionTime);
    } catch (error) {
      console.error(`Error executing tool ${name}:`, error);
      throw error;
    }
  }

  // async callTool(name: string, params: any): Promise<any> {
  //   try {
  //     const tool = this.registryData.tools.find(t => t.name === name);
  //     if (!tool) {
  //       throw new Error(`Tool not found: ${name}`);
  //     }

  //     const startTime = Date.now();
  //     const toolModule = await import(tool.path);
  //     const result = await toolModule.default.execute(params, this);
  //     const endTime = Date.now();
  //     const executionTime = endTime - startTime;
  //     this.updateMetrics(name, 'execution', executionTime);
  //     return result;
  //   } catch (error) {
  //     console.error(`Error executing tool ${name}:`, error);
  //     throw error;
  //   }
  // }

  async getTool(scriptOrName: string): Promise<Tool | null> {
    // First, try to find the tool by name
    const tool = this.tools[scriptOrName];
    if (tool) return tool;
  
    // If not found by name, check if any tool's source matches the script
    for (const t of Object.values(this.tools)) {
      if (t.source === scriptOrName) return t;
    }
  
    return null;
  }

  async rollbackTool(name: string, version: string): Promise<boolean> {
    try {
      const toolIndex = this.registryData.tools.findIndex(t => t.name === name);
      if (toolIndex === -1) {
        this.emit('error', `Tool not found: ${name}`);
        return false;
      }

      const source = await this.getTool(name);
      if (!source) {
        this.emit('error', `Source code not found for tool ${name} version ${version}`);
        return false;
      }

      const tool = this.registryData.tools[toolIndex];
      tool.version = version;
      tool.source = tool.source
      tool.active = true;
      this.saveRegistry();

      this.emit('text', `Tool ${name} rolled back to version ${version} successfully.`);
      this.updateMetrics(name, 'version', version);
      return true;
    } catch (error) {
      this.emit('error', `Error rolling back tool ${name}:`, error);
      return false;
    }
  }

  private incrementVersion(version: string): string {
    const [major, minor, patch] = version.split('.').map(Number);
    return `${major}.${minor}.${patch + 1}`;
  }

  async getToolTags(name: string): Promise<string[]> {
    const tool = this.registryData.tools.find(t => t.name === name);
    return tool ? tool.tags || [] : [];
  }

  async initialize(): Promise<void> {
    await this.initializeRegistry();
    this.loadMetrics();
    for (const tool of this.registryData.tools) {
      await this.loadTool(tool.name);
    }
    await this.generateAndRunTests();
  }

  getCompactRepresentation(): any {
    // schema.methodSignature - description
    return this.registryData.tools.map(tool => `${tool.schema.methodSignature} - ${tool.schema.description}`).join('\n');
  }

  async createNewToolWithLLM(
    description: string,
    schema: any,
    constraints: string[]
  ): Promise<Tool | null> {
    try {
      let toolCode = await this.conversation.chat([{
        role: 'system',
        content: `You create Javascript functions given a set of instructions. 
You will be given a description, a schema, and a set of constraints. 
Generate the JavaScript code for a tool that fulfills the requirements while observing the constraints..
Return a JSON object with the following format: { "name": "function_name", "description": "Brief description", "methodSignature": "function_name(param1: type, param2: type): returnType", "source": "function function_name(param1, param2) { ... }" }
You output only RAW JAVASCRIPT, WITHOUT ANY COMMENTARY, EXPLANATION or FORMATTING`
      }, {
        role: 'user',
        content: `Description: ${description}\nSchema: ${JSON.stringify(
          schema
        )}\nConstraints: ${constraints.join(', ')}`
      }], {} as any, 'gemini-1.5-flash-001');
      toolCode = toolCode.content[0].text;
      const { name, methodSignature } = JSON.parse(toolCode);

      await this.addTool(name, toolCode, schema, []);

      const toolName = schema.name;
      const success = await this.addTool(
        toolName,
        toolCode,
        schema,
        []
      );
      if (success) {
        this.emit('text', `Tool ${toolName} created successfully.`);
        return this.tools[toolName];
      } else {
        this.emit('error', 'Failed to add the generated tool to the registry.');
        return null;
      }
    } catch (error) {
      this.emit('error', 'Error creating tool with LLM:', error);
      return null;
    }
  }

  async generateAndRunTests(): Promise<void> {
    for (const tool of this.registryData.tools) {
      // load a real Tool instance
      const ttool = new Tool(this, tool.name, tool.version, tool.description, tool.source, tool.tags, tool.schema);
      await ttool.generateTestHarness();
      try {
        await ttool.runTests();
      } catch (error) {
        this.emit('text', `Error running tests for tool ${tool.name}:`, error);
      }
    }
  }

  async analyzeAndCreateToolFromScript(script: string, taskDescription: string): Promise<void> {
    const existingTools = await this.getToolList();
    const existingToolNames = existingTools.map(tool => tool.name);

    const analysisPrompt = `
        Given the following script and task description, determine if this script represents a unique and reusable functionality not adequately covered by existing tools.
  
        Existing tools: ${existingToolNames.join(', ')}
  
        Script:
        ${script}
  
        Task Description:
        ${taskDescription}
  
        If this script represents a unique and reusable functionality, provide the following in JSON format:
        1. A semantically-meaningful function name
        2. A brief description of the tool's functionality
        3. A method signature
        4. Any necessary modifications to make the script more generalized and reusable
  
        If the functionality is already adequately represented by existing tools, return null.
  
        Response format:
        {
          "name": "function_name",
          "description": "Brief description",
          "methodSignature": "function_name(param1: type, param2: type): returnType",
          "modifiedScript": "// Modified script code"
        }
      `;

    const analysisResult = await this.conversation.chat([{
      role: 'system',
      content: 'You are an AI assistant tasked with analyzing scripts and creating reusable tools.',
    }, {
      role: 'user',
      content: analysisPrompt,

    }]);

    if (analysisResult) {
      const { name, description, methodSignature, modifiedScript } = analysisResult;
      const schema = {
        name,
        description,
        methodSignature
      };

      await this.addAutoGeneratedTool(name, modifiedScript, schema);
    }
  }

  async addAutoGeneratedTool(name: string, source: string, schema: any): Promise<boolean> {
    const similarTool = this.registryData.tools.find(tool =>
      tool.name.toLowerCase().includes(name.toLowerCase()) ||
      name.toLowerCase().includes(tool.name.toLowerCase())
    );

    if (similarTool) {
      console.log(`Similar tool '${similarTool.name}' already exists. Skipping addition.`);
      return false;
    }

    return this.addTool(name, source, schema, ['auto-generated']);
  }

  async reviewAutoGeneratedTools(): Promise<void> {
    const autoGeneratedTools = this.registryData.tools.filter(tool => tool.tags.includes('auto-generated'));

    for (const tool of autoGeneratedTools) {
      const reviewPrompt = `
  Review the following auto-generated tool and determine if it should be kept, modified, or removed:
  
  Name: ${tool.name}
  Description: ${tool.schema.description}
  Method Signature: ${tool.schema.methodSignature}
  Source:
  ${tool.source}
  
  Provide your recommendation in JSON format:
  {
    "action": "keep" | "modify" | "remove",
    "reason": "Brief explanation",
    "modifications": "If action is 'modify', provide the modified source code here"
  }
  `;

      const reviewResult = await this.conversation.chat([{
        role: 'system',
        content: 'You are an AI assistant tasked with reviewing and maintaining the tool registry within which you operate.',
      }, {
        role: 'user',
        content: reviewPrompt
      }], {
        responseFormat: '{ "action": "string", "reason": "string", "modifications": "string" }[]'
      } as any);

      switch (reviewResult.action) {
        case 'keep':
          console.log(`Tool '${tool.name}' kept. Reason: ${reviewResult.reason}`);
          break;
        case 'modify':
          await this.updateTool(tool.name, reviewResult.modifications, tool.schema, tool.tags);
          console.log(`Tool '${tool.name}' modified. Reason: ${reviewResult.reason}`);
          break;
        case 'remove':
          await this.removeTool(tool.name);
          console.log(`Tool '${tool.name}' removed. Reason: ${reviewResult.reason}`);
          break;
      }
    }
  }

  async removeTool(name: string): Promise<boolean> {
    const initialLength = this.registryData.tools.length;
    this.registryData.tools = this.registryData.tools.filter(tool => tool.name !== name);
    const removed = this.registryData.tools.length < initialLength;
    if (removed) {
      this.saveRegistry();
      console.log(`Tool '${name}' removed successfully.`);
    }
    return removed;
  }

  async addTool(name: string, source: string, schema: any, tags: string[]): Promise<boolean> {
    try {
      if (this.registryData.tools.some(t => t.name === name)) {
        return false;
      }

      let standardizedSource = source;
      try {
        standardizedSource = await this.standardizeTool(name, source, schema);
      } catch (error) {
        console.warn(`Failed to standardize tool ${name}. Using original source.`, error);
      }

      const version = '1.0.0';
      const newTool = new Tool(this, name, version, schema.description, standardizedSource, tags, schema);

      this.registryData.tools.push(newTool);
      this.saveRegistry();

      await this.saveToolToRepo(name, standardizedSource, version);
      console.log(`Tool ${name} added successfully.`);
      return true;
    } catch (error) {
      console.error(`Error adding tool ${name}:`, error);
      return false;
    }
  }

  async performPeriodicMaintenance(): Promise<void> {
    await this.reviewAutoGeneratedTools();
    await this.improveTools();
    // Add any other maintenance tasks here
  }

  private loadMetrics(): void {
    try {
      if (fs.existsSync(this.metricsFile)) {
        const data = fs.readFileSync(this.metricsFile, 'utf8');
        this.metrics = JSON.parse(data);
        console.log('Metrics loaded successfully.');
      } else {
        this.metrics = {};
      }
    } catch (error) {
      console.error('Error loading metrics:', error);
      this.metrics = {};
    }
  }

  private saveMetrics(): void {
    try {
      const data = JSON.stringify(this.metrics, null, 2);
      fs.writeFileSync(this.metricsFile, data, 'utf8');
      console.log('Metrics saved successfully.');
    } catch (error) {
      console.error('Error saving metrics:', error);
    }
  }

  private initializeMetrics(toolName: string): void {
    if (!this.metrics[toolName]) {
      this.metrics[toolName] = {
        versions: [],
        totalUpdates: 0,
        lastUpdated: new Date().toISOString(),
        testResults: {
          totalRuns: 0,
          passed: 0,
          failed: 0,
          lastRun: null,
        },
        executionStats: {
          totalExecutions: 0,
          averageExecutionTime: 0,
          lastExecutionTime: null,
          fastestExecutionTime: Infinity,
          slowestExecutionTime: 0,
        },
        errorRate: 0,
        usageCount: 0,
      };
    }
  }

  async standardizeTool(name: string, source: string, schema: any): Promise<string> {
    const systemMessage = {
      role: 'system',
      content: `You are an AI assistant tasked with standardizing tool code into a specific module format. Use the template below, incorporating the given code into the execute function. Fix any obvious issues and ensure the code is properly formatted and exported.
Template:

import { Tool } from '../src/assistant/tool-base';

class ${name}Tool extends BaseTool {
  constructor() {
    super('${name}', '${schema.description}');
  }

  async execute(params, api) {
    // Tool implementation goes here
  }
}

export default new ${name}Tool();`
    };
    const userMessage = {
      role: 'user',
      content: `Original Tool Code:
${source}

Schema:
${JSON.stringify(schema, null, 2)}
  
Please provide the complete standardized tool module code, including the class definition and export.
<critical>DO NOT include any commentary, explanation, or formatting. YOUR OUTPUT SHOULD BE RAW Javascript Code</critical>`,
    }
    let response = await this.conversation.chat([systemMessage, userMessage]);
    return response.content[0].text;
  }

  async predictLikelyTools(userRequest: string): Promise<string[]> {
    const existingTools = await this.getToolList();
    const existingToolNames = existingTools.map(tool => tool.name);

    const prompt = `Given the following user request and list of existing tools, predict the most likely tools to be used and suggest new tools that need to be created to service the task.
  
User Request: ${userRequest}

Existing Tools: ${existingToolNames.join(', ')}

Provide your response in the following JSON format:
{
  "likelyTools": ["tool1", "tool2", ...],
  "newTools": ["newTool1", "newTool2", ...]
}
      `;

    const response = await this.conversation.chat([{
      role: 'system',
      content: 'You are an AI assistant tasked with predicting and suggesting tools for a given task.',
    }, {
      role: 'user',
      content: prompt
    }], {
      responseFormat: '{ "likelyTools": string[], "newTools": string[] }'
    } as any);

    return [...response.likelyTools, ...response.newTools];
  }
}

export default ToolRegistry;

export const toolRegistryTools = {
  list_tools: {
    name: 'list_tools',
    version: '1.1.0',
    description: 'List all tools in the registry, optionally filtered by tags',
    schema: {
      type: 'object',
      properties: {
        tags: { type: 'array', items: { type: 'string' }, description: 'Optional tags to filter tools' }
      }
    },
    execute: async (params: { tags?: string[] }, api: ToolRegistry) => {
      const allTools = await api.getToolList();
      if (params.tags && params.tags.length > 0) {
        return allTools.filter(tool => params.tags!.every(tag => tool.tags.includes(tag)));
      }
      return allTools;
    }
  },

  add_tool: {
    name: 'add_tool',
    version: '1.2.0',
    description: 'Add a new tool to the registry',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' },
        source: { type: 'string', description: 'Source code of the tool' },
        description: { type: 'string', description: 'Description of the tool' },
        tags: { type: 'array', items: { type: 'string' }, description: 'Tags for the tool' },
        schema: { type: 'object', description: 'Schema for the tool' },
        originalQuery: { type: 'string', description: 'Original query that led to the creation of this tool' }
      },
      required: ['name', 'source', 'description']
    },
    execute: async (params: any, api: ToolRegistry) => {
      const isValid = await ScriptValidator.validate(params.source);
      if (!isValid) {
        throw new Error('Tool validation failed');
      }
      const success = await api.addTool(params.name, params.source, params.schema || {}, params.tags || []);
      if (success) {
        await MetadataManager.addMetadata(api, params.name, {
          originalQuery: params.originalQuery || '',
          creationDate: new Date(),
          author: 'User',
          version: '1.0.0',
          tags: params.tags || [],
          dependencies: []
        });
      }
      return success;
    }
  },

  update_tool: {
    name: 'update_tool',
    version: '1.1.0',
    description: 'Update an existing tool in the registry',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool to update' },
        source: { type: 'string', description: 'New source code of the tool' },
        description: { type: 'string', description: 'New description of the tool' },
        tags: { type: 'array', items: { type: 'string' }, description: 'New tags for the tool' },
        schema: { type: 'object', description: 'New schema for the tool' }
      },
      required: ['name', 'source']
    },
    execute: async (params: any, api: ToolRegistry) => {
      const isValid = await ScriptValidator.validate(params.source);
      if (!isValid) {
        throw new Error('Tool validation failed');
      }
      return api.updateTool(params.name, params.source, params.schema, params.tags);
    }
  },

  delete_tool: {
    name: 'delete_tool',
    version: '1.0.0',
    description: 'Delete a tool from the registry',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool to delete' }
      },
      required: ['name']
    },
    execute: async (params: { name: string }, api: ToolRegistry) => {
      return api.removeTool(params.name);
    }
  },

  get_tool_metadata: {
    name: 'get_tool_metadata',
    version: '1.0.0',
    description: 'Get metadata for a specific tool',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' }
      },
      required: ['name']
    },
    execute: async (params: { name: string }, api: ToolRegistry) => {
      return MetadataManager.getMetadata(api, params.name);
    }
  },

  update_tool_metadata: {
    name: 'update_tool_metadata',
    version: '1.0.0',
    description: 'Update metadata for a specific tool',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' },
        metadata: { type: 'object', description: 'New metadata for the tool' }
      },
      required: ['name', 'metadata']
    },
    execute: async (params: { name: string, metadata: Partial<ScriptMetadata> }, api: ToolRegistry) => {
      await MetadataManager.addMetadata(api, params.name, params.metadata);
      return true;
    }
  },

  get_tool_performance: {
    name: 'get_tool_performance',
    version: '1.0.0',
    description: 'Get performance metrics for a specific tool',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' }
      },
      required: ['name']
    },
    execute: async (params: { name: string }, api: ToolRegistry) => {
      return ScriptPerformanceMonitor.getMetrics(params.name);
    }
  },

  get_all_performance_metrics: {
    name: 'get_all_performance_metrics',
    version: '1.0.0',
    description: 'Get performance metrics for all tools',
    schema: {},
    execute: async (params: {}, api: ToolRegistry) => {
      return ScriptPerformanceMonitor.getAllMetrics();
    }
  },

  run_maintenance: {
    name: 'run_maintenance',
    version: '1.0.0',
    description: 'Run maintenance tasks on the tool registry',
    schema: {},
    execute: async (params: {}, api: ToolRegistry) => {
      await api.performMaintenance();
      return 'Maintenance tasks completed';
    }
  },

  analyze_and_create_tool: {
    name: 'analyze_and_create_tool',
    version: '1.1.0',
    description: 'Analyze a script and create a new tool if it represents unique functionality',
    schema: {
      type: 'object',
      properties: {
        script: { type: 'string', description: 'The script to analyze' },
        taskDescription: { type: 'string', description: 'Description of the task the script performs' }
      },
      required: ['script', 'taskDescription']
    },
    execute: async (params: { script: string, taskDescription: string }, api: ToolRegistry) => {
      await api.analyzeAndCreateToolFromScript(params.script, params.taskDescription);
      return 'Analysis and tool creation completed';
    }
  },

  predict_likely_tools: {
    name: 'predict_likely_tools',
    version: '1.0.0',
    description: 'Predict likely tools to be used for a given task',
    schema: {
      type: 'object',
      properties: {
        userRequest: { type: 'string', description: 'The user request to analyze' }
      },
      required: ['userRequest']
    },
    execute: async (params: { userRequest: string }, api: ToolRegistry) => {
      return api.predictLikelyTools(params.userRequest);
    }
  },

  get_tool_history: {
    name: 'get_tool_history',
    version: '1.0.0',
    description: 'Get the version history of a specific tool',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' }
      },
      required: ['name']
    },
    execute: async (params: { name: string }, api: ToolRegistry) => {
      return api.getToolHistory(params.name);
    }
  },

  rollback_tool: {
    name: 'rollback_tool',
    version: '1.0.0',
    description: 'Rollback a tool to a previous version',
    schema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'Name of the tool' },
        version: { type: 'string', description: 'Version to rollback to' }
      },
      required: ['name', 'version']
    },
    execute: async (params: { name: string, version: string }, api: ToolRegistry) => {
      return api.rollbackTool(params.name, params.version);
    }
  },

  generate_tool_report: {
    name: 'generate_tool_report',
    version: '1.0.0',
    description: 'Generate a comprehensive report about the tool registry',
    schema: {
      type: 'object',
      properties: {
        format: { type: 'string', enum: ['text', 'json'], description: 'Output format of the report' }
      }
    },
    execute: async (params: { format?: 'text' | 'json' }, api: ToolRegistry) => {
      return api.generateReport(params.format || 'text');
    }
  }
};
.//assistant/tools.ts

// tools.ts
// tools.ts
import 'dotenv/config';
import shell from 'shelljs';
import Conversation from './conversation';
import validator from 'validator';
import * as fs from 'fs/promises'; // Use fs.promises for async/await
import ajv from 'ajv';
import { text } from 'blessed';

const jsonSchemaValidator = new ajv();

async function jsonValidator(
  jsonSchema: string,
  jsonData: string,
): Promise<boolean> {
  try {
    const schema = JSON.parse(jsonSchema);
    const data = JSON.parse(jsonData);
    const validate = jsonSchemaValidator.compile(schema);
    const valid = validate(data);
    return valid;
  } catch (error) {
    return false;
  }
}


// Generic error handling function for file system operations
async function handleFileError(context: any, api: any) {
  const logError = (message: string, level: string = 'error') => {
   api.emit('error', `[${level.toUpperCase()}] ${message} `);
  };

  logError(`File operation error: ${JSON.stringify(context)} `);

  const llmResponse = await api.callTool('callLLM', {
   system_prompt: 'Analyze the file operation error and suggest a fix.',
   prompt: JSON.stringify(context),
  });

  if (llmResponse.fix) {
   logError(`Attempting LLM fix: ${llmResponse.fix} `, 'debug');
   try {
    // Attempt to apply the LLM's fix (make sure it's safe!)
    // ... (Implement safe fix application logic here)
   } catch (fixError: any) {
    logError(`LLM fix attempt failed: ${fixError.message} `, 'error');
   }
  }

  // Safe Fallback:
  if (context.errorCode === 'ENOENT') {
   logError('File not found. Suggest creating the file or checking the path.', 'info');
   // ... (Implement logic to suggest file creation or path correction)
  } else {
   logError(`Unhandled file error code: ${context.errorCode} `, 'error');
   // ... (Handle other error codes with appropriate fallbacks)
  }
}

export const tools: { [key: string]: any } = {
'files': {
   'name': 'files',
   'version': '1.0.0',
   'description': 'Performs batch file operations.',
   'schema': {
    'name': 'files',
    'description': 'Performs batch file operations.',
    'input_schema': {
     'type': 'object',
     'properties': {
      'operations': {
       'type': 'array',
       'description': 'An array of file operations to perform.',
       'items': {
        'type': 'object',
        'properties': {
         'operation': {
          'type': 'string',
          'description': 'The operation to perform on the file.',
          'enum': ['read', 'append', 'prepend', 'replace', 'insert_at', 'remove', 'delete', 'copy', 'attach', 'list_attached', 'detach'],
         },
         'path': {
          'type': 'string',
          'description': "The path to the file. Required for all operations except 'list_attached'.",
         },
         'match': {
          'type': 'string',
          'description': "The string or regex pattern to match. Required for 'replace' and 'remove' operations.",
         },
         'data': {
          'type': 'string',
          'description': "The data to write, append, prepend, replace, or insert. Required for 'write', 'append', 'prepend', 'replace', and 'insert_at' operations.",
         },
         'position': {
          'type': 'number',
          'description': "The position to insert the data at. Required for 'insert_at' operation.",
         },
         'target': {
          'type': 'string',
          'description': "The target path for the 'copy' operation.",
         },
        },
        'required': ['operation'],
       },
      },
     },
     'required': ['operations'],
    },
    'output_schema': {
     'type': 'string',
     'description': 'A message indicating the result of the batch file operations.',
    },
   },
   execute: async function ({ operations }: any, run: any) {
    try {
     const fs = require('fs');
     const pathModule = require('path');
     const cwd = process.cwd();
     for (const { operation, path, match, data, position, target } of operations) {
      const p = pathModule.join(cwd, path || '');
      const t = pathModule.join(cwd, target || '');
      if (!fs.existsSync(p || t)) {
       return `Error: File not found at path ${p || t} `;
      }
      let text = fs.readFileSync(p, 'utf8');
      switch (operation) {
       case 'read':
        return text;
       case 'append':
        text += data;
        break;
       case 'prepend':
        text = data + text;
        break;
       case 'replace':
        text = text.replace(match, data);
        break;
       case 'insert_at':
        text = text.slice(0, position) + data + text.slice(position);
        break;
       case 'remove':
        text = text.replace(match, '');
        break;
       case 'delete':
        fs.unlinkSync(p);
        break;
       case 'copy':
        fs.copyFileSync(p, t);
        break;
       default:
        return `Error: Unsupported operation ${operation} `;
      }
      fs.writeFileSync(p, text);
     }
     return `Successfully executed batch operations on files`;
    } catch (error: any) {
     const context = {
      errorCode: error.code,
      operations: operations,
      // ... other details
     };
     await handleFileError(context, run);
     return `File operation '${operations}' failed. Check logs for details.`;
    }
   },
  }, 
  'get_file_tree': {
    'name': 'get_file_tree',
    'version': '1.0.0',
    'description': 'Retrieves the file tree structure from the given path.',
    'schema': {
      'name': 'get_file_tree',
      'description': 'Retrieves the file tree structure from the given path.',
      'methodSignature': 'get_file_tree(value: string, n: number): object',
    },
    execute: async ({ value, n }: any, state: any) => {
      const fs = require('fs');
      const pathModule = require('path');
      const cwd = process.cwd();
      const explore = (dir: any, depth: any) => {
        dir = pathModule.join(cwd, dir || '');
        if (depth < 0) return null;
        const directoryTree: any = { path: dir, children: [] };
        try {
          const fsd = fs.readdirSync(dir, { withFileTypes: true });
          fsd.forEach((dirent: any) => {
            const fullPath = pathModule.join(dir, dirent.name); // Use pathModule instead of path
            // ignore node_modules and .git directories
            if (dirent.isDirectory() && (dirent.name === 'node_modules' || dirent.name === '.git')) return;
            if (dirent.isDirectory()) {
              directoryTree.children.push(explore(fullPath, depth - 1));
            } else {
              directoryTree.children.push({ path: fullPath });
            }
          });
        } catch (e: any) {
          return e.message;
        }
        return directoryTree;
      };
      return explore(value, n);
    },
  },
  'say_aloud': {
    'name': 'say_aloud',
    'version': '1.0.0',
    'description': 'Speaks the given text aloud using PlayHT. PASS IN A text and voice PARAMETERS TO SPEAK ALOUD.',
    'schema': {
      'name': 'say_aloud',
      'description': 'Speaks the given text aloud using PlayHT. PASS IN A text and voice PARAMETERS TO SPEAK ALOUD. voice can be either \'male\' or \'female\'.',
      'methodSignature': 'say_aloud({text, voice}:{string, string}): string',
    },
    execute: async (params: any, api: any) => {
      const PlayHT = require('playht');
      const fs = require('fs');
      var player = require('play-sound')({});

      const apiKey = process.env.PLAYHT_AUTHORIZATION;
      const userId = process.env.PLAYHT_USER_ID;
      const maleVoice = process.env.PLAYHT_MALE_VOICE;
      const femaleVoice = process.env.PLAYHT_FEMALE_VOICE;

      // Initialize PlayHT API
      PlayHT.init({
        apiKey: apiKey,
        userId: userId,
      });
      function getNonce() {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      }

      async function speakSentence(sentence: string, voice: string) {
        if (!sentence) return;
        const stream = await PlayHT.stream(sentence, {
          voiceEngine: 'PlayHT2.0-turbo',
          voiceId: voice === 'male' ? maleVoice : femaleVoice,
        });
        const chunks: any = [];
        stream.on('data', (chunk: any) => chunks.push(chunk));

        return new Promise((resolve, reject) => {
          stream.on('end', () => {
            const buf = Buffer.concat(chunks);
            // save the audio to a file
            const filename = `${getNonce()}.mp3`;
            fs.writeFileSync(filename, buf);
            player.play(
              filename,
              function (err: any) {
                fs.unlinkSync(filename);
                resolve('done');
              },
            );
          });
        });
      }

      if (!Array.isArray(params)) params = [params];
      for (const param of params) {
        // if params is a string, convert it to an object
        let { text, voice } = param;
        voice = voice || 'female';
        if (!text) throw new Error('Text is required to speak aloud');
        if (!voice) throw new Error('Voice is required to speak aloud');

        let sentences = await api.callTool('callLLM', {
          system_prompt:
            'convert the following text into a number of sentences meant to be spoken aloud. This means breaking the text into sentences that are easy to read and understand as well as phonetically pronouncing any difficult words, urls, or acronyms. *** Return your response as a RAW JSON ARRAY of strings. ***',
          prompt: text,
          responseFormat: `string[]`,
        });
        sentences = sentences instanceof Array ? sentences : JSON.parse(sentences);
        const consumeSentence = async () => {
          return new Promise((resolve, reject) => {
            const loop: any = async () => {
              const sentence = sentences.shift();
              if (!sentence) return resolve('done');
              await speakSentence(sentence, voice);
              return await loop();
            };
            return loop();
          });
        };
        await consumeSentence();
  
      }

      return '(aloud) ' + text;
    },
  },
  pause: {
    'name': 'pause',
    'version': '1.0.0',
    'description': 'Pause execution for the specified duration.',
    'schema': {
      'name': 'pause',
      'description': 'Pause execution for the specified duration.',
      "methodSignature": "pause(duration: number): void",
    },
    execute: async ({ duration }: any) => {
      return await new Promise((resolve) => setTimeout(resolve, duration));
    },
  },  
  echo: {
    'name': 'echo',
    'version': '1.0.0',
    'description': 'Print the given text to the console',
    'schema': {
      'name': 'echo',
      'description': 'Print the given text to the console',
      'input_schema': {
        'type': 'object',
        'properties': {
          'text': {
            'type': 'string',
            'description': 'The text to print',
          },
        },
        'required': ['text'],
      },
    },
    execute: async ({ text }: any, api: any) => {
      api.emit('text', text);
      return text;
    },
  },
  callLLM: {
    'name': 'callLLM',
    'version': '1.0.0',
    'description': 'Call the LLM with the given system prompt and prompt, optionally specifying the model and response format and setting a result variable.',
    'schema': {
      'name': 'callLLM',
      "methodSignature": "callLLM(params: { prompt: string, system_prompt?: string, model?: string, responseFormat?: string, resultVar?: string }[]): any",
      'description': 'Call the LLM with the given system prompt and prompt, optionally specifying the model and response format and setting a result variable.',
    },
    execute: async (params: any, api: any) => {
      if (!Array.isArray(params)) params = [params];
      for (const param of params) {
        let { prompt, system_prompt, model, responseFormat, resultVar } = param;
        try {
          if (!prompt) {
            throw new Error("Both 'prompt' and 'system_prompt' are required parameters for the 'callLLM' tool.");
          }
          if (!system_prompt) system_prompt = prompt;
          model = model || 'claude';
          if (model !== 'claude' && model !== 'gemini') {
            throw new Error("Invalid model specified. Choose either 'claude' or 'gemini'.");
          }
          if (responseFormat) {
            system_prompt = `${system_prompt}. Response Format: You MUST respond with a JSON - encoded string in the following format: \n\`\`\`typescript\n${responseFormat}\n\`\`\`\n`;
          }
          const convo = new Conversation(model);
          const response = await convo.chat([
            {
              role: 'system',
              content: system_prompt,
            },
            {
              role: 'user',
              content: prompt,
            },
          ]);

          const data = response.content[0].text.trim();

          // Validate JSON structure before parsing
          if (responseFormat) {
            try {
              const isValidJson = jsonValidator(responseFormat, data);
              if (!isValidJson) {
                throw new Error('Invalid JSON structure in LLM response. Actual response: ' + data) + ' Expected response format: ' + responseFormat;
              }

              const rr = JSON.parse(data);
              if (resultVar) {
                api.store[resultVar] = rr;
              }
              return rr;
            } catch (error: any) {
              api.emit('error', `JSON parsing failed for LLM response: ${data}`);
              if (resultVar) {
                api.store[resultVar] = data;
              }
              return data;
            }
          } else {
            if (resultVar) {
              api.store[resultVar] = data;
            }
            return data;
          }
        } catch (error: any) {
          const llmResponse = await api.callTool('callLLM', {
            system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
            prompt: JSON.stringify({
              error: error.message,
              stackTrace: error.stack,
              context: { prompt, system_prompt, model, responseFormat, resultVar },
            }),
          });
          if (llmResponse.fix) {
            return llmResponse.fix;
          }
          throw error;
        }
      }
    },
  },
  'call_agent': {
    'name': 'call_agent',
    'version': '1.0.0',
    'description': 'Call the agent with the given task to perform.',
    'schema': {
      'name': 'call_agent',
      "methodSignature": "call_agent(params: { prompt: string, model?: string, resultVar?: string }): any",
      'description': 'Call the agent with the given task to perform.'
    },
    execute: async ({ prompt, model = 'claude', resultVar }: any, api: any) => {
      try {
        if (!prompt) {
          throw new Error("The 'prompt' parameter is required for the 'call_agent' tool.");
        }
        if (model !== 'claude' && model !== 'gemini') {
          throw new Error("Invalid model specified. Choose either 'claude' or 'gemini'.");
        }
        const compactRepresentation = () => {
          return JSON.stringify(api.getSchemas());
        };
        const convo = new Conversation(model);
        const jsonPrompt = `Transform the given task into a sequence of subtasks, each with a JavaScript script that uses the provided tools to achieve the subtask objective.

Available Tools:

${compactRepresentation()}

Additional tools can be explored using 'list_all_tools', 'get_tool_details', and 'load_tool'.

Process:

1. Analyze the task and identify necessary steps
2. Decompose into subtasks with clear objectives and input/output
3. For each subtask, write a JavaScript script using the tools
  a. Access previous subtask results with taskResults.<taskName>_results: \`const lastResult = taskResults.firstTask_results; ...\`
  b. Store subtask results in a variable for future use: \`const result = { key: 'value' }; taskResults.subtask_results = result; ...\`
  b. End the script with a return statement for the subtask deliverable: \`return result;\`
4. Test each script and verify the output
5. Provide a concise explanation of the subtask's purpose and approach

Data Management:

- Store subtask results in resultVar (JSON/array format): \`taskResults.subtask_results = result;\`
Access previous subtask data with taskResults.<resultVar>: \`const lastResult = taskResults.subtask_results; ...\`
Include only resultVar instructions in responses, not the actual data.

Output Format:
\`\`\`json
[
  {
  "task": "<taskName>:<description>",
  "script": "<JavaScript script>",
  "chat": "<subtask explanation>",
  "resultVar": "<optional result variable>"
  },
  // ... additional subtasks
]
\`\`\`

CRITICAL: Verify the JSON output for accuracy and completeness before submission. *** OUTPUT ONLY JSON ***`;
        const response = await convo.chat([
          {
            role: 'system',
            content: jsonPrompt,
          },
          {
            role: 'user',
            content: JSON.stringify({
              task: 'First off: OUTPUTTING ONLY *VALID*, RAW JSON IS CRITICAL! Now read and handle this: ' + prompt,
            }),
          },
        ]);
        let tasks = response.content[0].text;

        // crop anything outside the ````json and ``` to get only the json response
        tasks = tasks.replace(/.*```json/g, '');
        tasks = tasks.replace(/.*```/g, '');
        tasks = tasks.replace(/[\r\n]+/g, '');
        let message = '';
        try {
          tasks = JSON.parse(tasks);
        } catch (error: any) {
          tasks = api.extractJson(response.content[0].text);
          message = error.message;
        }
        if (!Array.isArray(tasks) || tasks.length === 0) {
          api.emit('error', message);
          throw new Error('The task must be an array of subtasks. Check the format and try again. RETURN ONLY JSON RESPONSES' + message);
        }

        const results = [];

        api.store[prompt] = tasks;

        if (resultVar) {
          api.store[resultVar] = results;
        }

        for (const task of tasks) {
          let { task: taskName, script, chat } = task;
          const splitTask = taskName.split(':');
          let taskId = taskName;
          if (splitTask.length > 1) {
            taskId = splitTask[0];
            taskName = splitTask[1];
          }
          api.store['currentTaskId'] = taskId;
          api.emit('taskId', taskId);

          api.store[`${taskId}_task`] = task;
          api.emit(`${taskId}_task`, task);

          api.store[`${taskId}_chat`] = chat;
          api.emit(`${taskId}_chat`, chat);

          api.store[`${taskId}_script`] = script;
          api.emit(`${taskId}_script`, script);

          const sr = await api.callScript(script);
          task.scriptResult = sr;

          api.store[`${taskId}_result`] = sr;
          api.store[`${taskId}_results`] = sr;
          const rout = { id: taskId, task: taskName, script, result: sr };
          api.emit(`${taskId}_results`, rout);

          results.push(rout);
        }

        if (resultVar) {
          api.store[resultVar] = results;
        }

        return results;
      } catch (error: any) {
        const llmResponse = await api.callTool('callLLM', {
          system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          prompt: JSON.stringify({
            error: error.message,
            stackTrace: error.stack,
            context: { prompt, model, resultVar },
          }),
        });
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
      }
    },
  },
  'call_agents': {
    'name': 'call_agents',
    'version': '1.0.0',
    'description': 'Call multiple agents with the given tasks to perform.',
    'schema': {
      'name': 'call_agents',
      "methodSignature": "call_agents(params: { prompts: string[], resultVar?: string }): any",
      'description': 'Call multiple agents with the given tasks to perform.',
    },
    execute: async ({ prompts, resultVar }: any, api: any) => {
      try {
        if (!prompts || !Array.isArray(prompts)) {
          throw new Error("The 'prompts' parameter must be an array for the 'call_agents' tool.");
        }
        const results = await Promise.all(
          prompts.map(async (prompt: string) => {
            return await api.callTool('call_agent', { prompt, model: 'claude' });
          }),
        );
        if (resultVar) {
          api.store[resultVar] = results;
        }
        return results;
      } catch (error: any) {
        const llmResponse = await api.callTool('callLLM', {
          system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          prompt: JSON.stringify({
            error: error.message,
            stackTrace: error.stack,
            context: { prompts, resultVar },
          }),
        });
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
        throw error;
      }
    },
  },
  callLLMs: {
    'name': 'callLLMs',
    'version': '1.0.0',
    'description': 'Call the LLM with the given system prompt and prompts concurrently.',
    'schema': {
      'name': 'callLLMs',
      "methodSignature": "callLLMs(params: { prompts: string[], system_prompt: string, resultVar?: string }): any",
      'description': 'Call the LLM with the given system prompt and prompts concurrently.',
    },
    execute: async ({ prompts, system_prompt, resultVar }: any, api: any) => {
      try {
        if (!prompts || !Array.isArray(prompts) || !system_prompt) {
          throw new Error("The 'prompts' parameter must be an array and 'system_prompt' is required for the 'callLLMs' tool.");
        }
        const results = await Promise.all(
          prompts.map(async (prompt: string) => {
            return await api.callTool('callLLM', { prompt, system_prompt });
          }),
        );
        if (resultVar) {
          api.store[resultVar] = results;
        }
        return results;
      } catch (error: any) {
        const llmResponse = await api.callTool('callLLM', {
          system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          prompt: JSON.stringify({
            error: error.message,
            stackTrace: error.stack,
            context: { prompts, system_prompt, resultVar },
          }),
        });
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
        throw error;
      }
    },
  },
  // apply a universal patch to a file
  'apply_patch': {
    'name': 'apply_patch',
    'version': '1.0.0',
    'description': 'Apply a universal patch to a file. Pass a file path, a patch string, and an optional resultVar to save the patched file contents.',
    'schema': {
      'name': 'apply_patch',
      "methodSignature": "apply_patch({ file: string, patch: string, resultVar?: string }): string",
      'description': 'Apply a universal patch to a file. Pass a file path, a patch string, and an optional resultVar to save the patched file contents.',
      "required": ["file", "patch"],
    },
    execute: async (params: any, api: any) => {
      if(!Array.isArray(params)) params = [params];
      for (const { file, patch, resultVar } of params) {
        try {
          if (!file || !patch) {
            throw new Error("Both 'file' and 'patch' are required parameters for the 'apply_patch' tool.");
          }
          const existsSync = require('fs').existsSync;
          const filePath =  require('path').resolve(file);
          if (!(await existsSync(filePath))) {
            throw new Error(`The file '${file}' does not exist.`);
          }
          try {
            const result = await api.callTool('busybox', {
              command: 'patch',
              args: [file],
              options: { input: patch },
              resultVar,
            });
            if (resultVar) {
              api.store[resultVar] = result;
            }
            return result;
          } catch (error: any) {
            try {
              const fileContent = await fs.readFile(file, 'utf8');
              return await api.callTool('callLLM', {
                system_prompt:
                  'Given one or more universal patches and file content, analyze the patches and the file content to determine the best way to apply the patch to the content, then apply the patch to the file. Return ONLY the patched file contents IN ITS ENTIRETY.',
                prompt: `File content: ${fileContent}\n\nPatch: ${patch}`,
              });
            } catch (error: any) {
              throw new Error(`Failed to apply patch: ${error.message} Tool source: ${error.stack}`);
            }
          }
        } catch (error: any) {
          const llmResponse = await api.callTool('callLLM', {
            system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
            prompt: JSON.stringify({
              error: error.message,
              stackTrace: error.stack,
              context: { file, patch, resultVar },
            }),
          });
          if (llmResponse.fix) {
            return llmResponse.fix;
          }
          throw error;
        }
      }
    },
  },
  'generate_patches': {
    'name': 'generate_patches',
    'version': '1.0.0',
    'description':
      'Generate a number of patches for a number of files given a list of file paths and instructions for what to generate. Use this tool to make changes to one or more files given a set of instructions.',
    'schema': {
      'name': 'generate_patches',
      "methodSignature": "generate_patches(params: { files: string[], instructions: string, resultVar?: string }): string",
      'description':
        'Generate a number of patches for a number of files given a list of file paths and instructions for what to generate. Use this tool to make changes to one or more files given a set of instructions.',
    },
    execute: async ({ files, instructions, resultVar }: any, api: any) => {
      try {
        const content = files
          .map((file: string) => {
            return [file, api.fs.readFileSync(file).toString()].join('\n');
          })
          .join('\n\n');
        const prompt = `INSTRUCTIONS: ${instructions}\n\nFILES:\n\n${content}\n\nRemember to provide a JSON array of objects with the following format: [{ file: <file>, patch: <patch> }].`;
        const llmResponse = await api.callTool('callLLM', {
          system_prompt:
            'Analyze the provided files, then analyse the instructions. Then, generate one or more patches for the files based on the given instructions. Return your patches as a JSON array of objects with the following format: [{ file: <file>, patch: <patch> }]. OUTPUT ONLY RAW JSON!',
          prompt,
        });
        if (resultVar) {
          api.store[resultVar] = llmResponse;
        }
        return llmResponse;
      } catch (error: any) {
        const llmResponse = await api.callTool('callLLM', {
          system_prompt: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          prompt: JSON.stringify({
            error: error.message,
            stackTrace: error.stack,
            context: { files, instructions },
          }),
        });
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
        throw error;
      }
    },
  },
  'get_tools_home': {
    'name': 'get_tools_home',
    'version': '1.0.0',
    'description': 'Get the path to the tools home directory.',
    'schema': {
      'name': 'get_tools_home',
      "methodSignature": "get_tools_home(): string",
      'description': 'Get the path to the tools home directory.',
    },
    execute: async (params: any, api: any) => {
      const thisFolder = __dirname;
      const toolsHome = thisFolder + '/tools';
      return toolsHome;
    },
  },
  'list_all_tools': {
    'name': 'list_all_tools',
    'version': '1.0.0',
    'description': 'List all the tools available in the tools home directory.',
    'schema': {
      'name': 'list_all_tools',
      "methodSignature": "list_all_tools(): { type: 'array', items: { name: 'string' } }",
      'description': 'List all the tools available in the tools home directory.',
    },
    execute: async (params: any, api: any) => {
      const toolsHome = await api.callTool('get_tools_home', {});
      //const tools = fs.readdirSync(toolsHome).filter((file: string) => file.endsWith('.ts')).map((file: string) => file.replace('.ts', ''));
      const tools = await fs.readdir(toolsHome);
      return tools;
    },
  },
  'get_tool_details': {
    'name': 'get_tool_details',
    'version': '1.0.0',
    'description': 'Get the details of a tool.',
    'schema': {
      'name': 'get_tool_details',
      "methodSignature": "get_tool_details(tool: string): { name: 'string', description: 'string', input_schema: 'object', output_schema: 'object' }",
      'description': 'Get the details of a tool.',
    },
    execute: async ({ tool }: any, api: any) => {
      const toolsHome = await api.callTool('get_tools_home', {});
      const toolPath = `${toolsHome}/${tool}.ts`;
      const existsSync = require('fs').existsSync;
      if (!existsSync(toolPath)) {
        throw new Error(`The tool '${tool}' does not exist.`);
      }
      const toolModule = require(toolPath);
      return toolModule.schema;
    },
  },
  'get_tools_details': {
    'name': 'get_tools_details',
    'version': '1.0.0',
    'description': 'Get the details of the specified tools.',
    'schema': {
      'name': 'get_tools_details',
      "methodSignature": "get_tools_details(tools: string[]): { name: 'string', description: 'string', input_schema: 'object', output_schema: 'object' }[]",
      'description': 'Get the details of the specified tools.',
    },
    execute: async (params: any, api: any) => {
      const { tools } = params;
      const toolsDetails = await Promise.all(
        tools.map(async (tool: string) => {
          return await api.callTool('get_tool_details', { tool });
        }),
      );
      return toolsDetails;
    },
  },
  'list_active_tools': {
    'name': 'list_active_tools',
    'version': '1.0.0',
    'description': 'List all the active tools in the current session.',
    'schema': {
      'name': 'list_active_tools',
      "methodSignature": "list_active_tools(): string[]",
      'description': 'List all the active tools in the current session.',
    },
    execute: async (params: any, api: any) => {
      return Object.keys(api.tools);
    },
  },
  'load_tool': {
    'name': 'load_tool',
    'version': '1.0.0',
    'description': 'Load a tool from a file path.',
    'schema': {
      name: 'load_tool',
      "methodSignature": "load_tool(path: string): string",
      description: 'Load a tool from a file path.',
    },
    execute: async ({ path }: any, api: any) => {
      try {
        const toolModule = require(path);
        const toolName = toolModule.name; // Assuming the tool module exports its name
        api.toolRegistry.addTool(toolName, toolModule.source, toolModule.schema, toolModule.tags || []);
        return toolName;
      } catch (error: any) {
        throw new Error(`Failed to load tool: ${error.message} Tool source: ${error.stack}`);
      }
    },
  },
  'load_tool_source': {
    'name': 'load_tool_source',
    'version': '1.0.0',
    'description': 'Load a tool from a file path and return the source code.',
    'schema': {
      'name': 'load_tool_source',
      "methodSignature": "load_tool_source(path: string): string",
      'description': 'Load a tool from a file path and return the source code.',
    },
    execute: async ({ path }: any, api: any) => {
      try {
        const tool = await fs.readFile(path, 'utf8');
        return tool;
      } catch (error: any) {
        throw new Error(`Failed to load tool source: ${error.message} Tool source: ${error.stack}`);
      }
    },
  },
  'save_tool': {
    'name': 'save_tool',
    'version': '1.0.0',
    'description': 'Save a tool to a file path.',
    'schema': {
      name: 'save_tool',
      'methodSignature': 'save_tool(params: { tool: object, path: string }): string',
      description: 'Save a tool to a file path.',
    },
    execute: async ({ tool, path }: any, api: any) => {
      try {
        const name = Object.keys(tool)[0];
        await fs.writeFile(path, `module.exports = ${JSON.stringify(tool, null, 2)};`);
        return name;
      } catch (error: any) {
        throw new Error(`Failed to save tool: ${error.message} Tool source: ${error.stack}`);
      }
    },
  },
  search_news_api: {
    'name': 'search_news_api',
    'version': '1.0.0',
    'description': 'Performs a news search using the given query.',
    'schema': {
      'name': 'search_news_api',
      "methodSignature": "search_news_api(params: { q: string, from?: string, to?: string, language?: string, country?: string, domains?: string, sources?: string, sortBy?: string, num?: number }): string",
      'description': 'Performs a news search using the given query.',
    },
    execute: async (values: any) => {
      const axios = require('axios');
      const trunc = (str: any, len: any) => {
        return str.length > len ? str.substring(0, len - 3) + '...' : str;
      }
      try {
        const response = await axios.get(`https://newsapi.org/v2/everything?q=${values.q}&apiKey=${process.env.NEWS_API_KEY}`);
        const results = response.data.articles.map((item: any) => ({
          content: trunc(item.content, 100),
          title: item.title,
          url: item.url,
        }));
        // keep only the first num results
        let num = values.num ? values.num : 10;
        const res = results.slice(0, num);
        return JSON.stringify(res);
      } catch (error: any) {
        return `Error calling News API: ${error.message}`
      }
    }
  },
  search_google: {
    'name': 'search_google',
    'version': '1.0.0',
    'description': 'perform a google search using the given query',
    'schema': {
      "name": "search_google",
      "methodSignature": "search_google(params: { query: string }): string",
      "description": "perform a google search using the given query",
    },
    execute: async ({ query }: any) => {
      const config = {
        GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,
        GOOGLE_CX_ID: process.env.GOOGLE_CX_ID
      }
      try {
        const axios = require('axios');
        const response = await
          axios.get(`https://www.googleapis.com/customsearch/v1?key=${config.GOOGLE_API_KEY}&cx=${config.GOOGLE_CX_ID}&q=${query}`);
        const results = response.data.items.map((item: any) => ({
          title: item.title,
          link: item.link
        }));
        const res = JSON.stringify(results);
        return res;
      } catch (error: any) {
        return error.message;
      }
    }
  },
  fixJson: {
    // given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array
    // given some text content without any JSON within it, it will attempt to structure the text content into a JSON object
    'name': 'fixJson',
    'version': '1.0.0',
    'description': 'given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array, given some text content without any JSON within it, it will attempt to structure the text content into a JSON object',
    'schema': {
      'name': 'fixJson',
      'methodSignature': 'fixJson(params: { json: string, resultVar?: string }): any',
      'description': 'given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array, given some text content without any JSON within it, it will attempt to structure the text content into a JSON object',
    },
    execute: async ({ json, resultVar }: any, api: any) => {
      const convo = new Conversation('gemini');
      const sp = `Given some content that contains a JSON object or array, you ignore EVERYTHING BEFORE OR AFTER what is obviously JSON data, ignoring funky keys and weird data, and you output a syntactically-valid version of the JSON, with other quoting characters properly escaped, on a single line. If the content contains no JSON data, you output a JSON object containing the input data, structured in the most appropriate manner for the data.`;
      const tasks = await convo.chat([
        {
          role: 'system',
          content: sp
        },
        {
          role: 'user',
          content: json,
        },
      ], {} as any, 'gemini-1.5-flash-001');
      let task = tasks.content[0].text;
      try {
        task = JSON.parse(task);
      } catch (error: any) {
        task = api.extractJson(task);
      }
      if (resultVar) {
        api.store[resultVar] = task;
      }
      return task;
    }
  }

};
.//assistant/maintenance.ts
import Assistant from './assistant';
import ToolRegistry from './tool_registry';
import { MemoryStore } from './memory/store';

export class MaintenanceManager {
  private assistant: Assistant;
  private toolRegistry: ToolRegistry;
  private memoryStore: MemoryStore;

  constructor(assistant: Assistant, toolRegistry: ToolRegistry, memoryStore: MemoryStore) {
    this.assistant = assistant;
    this.toolRegistry = toolRegistry;
    this.memoryStore = memoryStore;
  }

  async performMaintenance(): Promise<void> {
    await this.reviewAutoGeneratedTools();
    await this.optimizeMemory();
  }

  private async reviewAutoGeneratedTools(): Promise<void> {
    await this.toolRegistry.reviewAutoGeneratedTools();
  }

  private async optimizeMemory(): Promise<void> {
    // Implement memory optimization logic
    // For example, remove old or low-confidence memories
    const memories = await this.memoryStore.listMemories();
    const lowConfidenceMemories = memories.filter(memory => memory.confidence < 0.3);
    for (const memory of lowConfidenceMemories) {
      await this.memoryStore.removeMemory(memory.input);
    }
  }
}.//assistant/conversation.ts

// conversation.ts
import { AnthropicVertex } from '@anthropic-ai/vertex-sdk';
import { VertexAI } from '@google-cloud/vertexai';

export default class Conversation {
  model: string;
  projectId: string;
  location: string;
  client: any;
  vertexAI: any;
  constructor(model: any) {
    this.model = model.toLowerCase();

    if (this.model !== 'claude' && this.model !== 'gemini') {
      throw new Error("Invalid model specified. Choose either 'claude' or 'gemini'.");
    }

    // Vertex AI Configuration (adjust if needed)
    this.projectId = 'silent-blade-417120';
    this.location = this.model === 'claude' ? 'us-east5' : 'us-central1';

    if (this.model === 'claude') {
      this.client = new AnthropicVertex({
        region: this.location,
        projectId: this.projectId,
      });
    } else {
      this.vertexAI = new VertexAI({
        project: this.projectId,
        location: this.location
      });
    }
  }

  async chat(messages: any[], options = {
    max_tokens : 4000, 
    temperature : 0.15,
    responseFormat: ''
  }, model = 'gemini-1.5-pro-001') {
    const {}: any = options;
    if(!Array.isArray(messages)) {
      throw new Error('Messages must be an array of objects.');
    }

    if (this.model === 'claude') {
      return this.chatWithClaude(messages, options);
    } else {
      return this.chatWithGemini(messages, options, model);
    }
  }

  async chatWithClaude(messages: any[], options = {
    max_tokens : 4000, 
    temperature : 0.15,
    responseFormat : ''
  }) {
    let { max_tokens, temperature, responseFormat } = options;
    if(responseFormat !== '') {
      responseFormat = `\n\nRESPONSE FORMAT. *** YOU are REQUIRED to return the response in JSON formatted with the following format: ${responseFormat} Do NOT SURROUND with Codeblocks ***`
    }
    try {
      let system = "You are a helpful assistant.";
      if (messages[0].role === "system") {
        system = messages[0].content + (responseFormat ? responseFormat : '');
        messages.shift();
      }
      if(responseFormat !== '') {
        messages[messages.length - 1].content += responseFormat;
      }
      let result = await this.client.messages.create({
        messages: messages,
        model: 'claude-3-5-sonnet@20240620',
        system,
        max_tokens: max_tokens || 4000,
        temperature: temperature,
      });
      if(responseFormat !== '') {
        try {
        result = JSON.parse(result.content[0].text);
        } catch (error) {
          result = result.content[0].text;
        }
      }
      return result;
    } catch (error) {
      console.error(error);
      return error;
    }
  }

  async chatWithGemini(messages: any[], options: any, model: string = 'gemini-1.5-pro-001') {
    const { max_tokens, temperature } = options;
    const generativeModel = this.vertexAI.getGenerativeModel({
      model: model,
    });
    const prompt = messages.map(message => `${message.role}: ${message.content}`).join('\n');

    const resp = await generativeModel.generateContent(prompt, {
      temperature: temperature,
      maxOutputTokens: max_tokens,
    });

    const contentResponse = await resp.response;
    return contentResponse;
  }
}.//assistant/index.ts
//SUB
import { CoreWorkflow } from "./workflow";
import { generateUsername } from "unique-username-generator";
import * as packageJson from "../../package.json";
import fs from 'fs';
import ToolRegistry from "./tool_registry";
import { ChromaClient } from "chromadb";
import Assistant from "./assistant";

export class AssistantSessionManager extends ToolRegistry {

    sessions: any[];
    activeSessionIndex: number;
    commandMode: boolean = false;

    constructor(public chromaClient: ChromaClient) {
        super();
        console.clear();
        this.sessions = [];
        this.activeSessionIndex = 0;
    }

    createNewSession() {
        const newSession = new AssistantSession(this, this.chromaClient);
        this.sessions.push(newSession);
        this.activeSessionIndex = this.sessions.length - 1;
        this.switchToSession(this.activeSessionIndex, false);
        this.emit('newSessionCreated', this.sessions[this.activeSessionIndex]);
       
    }

    switchToNextSession() {
        this.saveSessionState();
        this.activeSessionIndex = (this.activeSessionIndex + 1) % this.sessions.length;
        this.switchToSession(this.activeSessionIndex);
    }

    switchToSession(index: number, showPrompt: boolean = true) {
        this.activeSessionIndex = index;
        if (this.sessions[this.activeSessionIndex]) {
            console.clear();
            showPrompt && console.log(`\n--- Switched to session ${this.activeSessionIndex} ---`);
            this.sessions[this.activeSessionIndex].restoreSessionState();
            this.emit('sessionSwitched', this.sessions[this.activeSessionIndex]);
        }
    }

    executeCommandInActiveSession(command: string) {
        if (this.sessions.length === 0) {
            this.createNewSession();
        }
        this.emit('beforeExecuteCommand', { command });
        this.sessions[this.activeSessionIndex].execute(command);
        this.emit('afterExecuteCommand', { command });
    }

    saveSessionState() {
        this.sessions[this.activeSessionIndex].savedOutput = this.sessions[this.activeSessionIndex]._buffer ? this.sessions[this.activeSessionIndex]._buffer.toString() : '';
        this.emit('saveSessionState', this.sessions[this.activeSessionIndex].savedOutput);
    }
}


export class AssistantSession extends CoreWorkflow {

    id: string;
    debug: boolean = false;
    savedOutput: string = '';
    _buffer: any;

    sessionManager: AssistantSessionManager;
    actionHandlers: any = {};

    constructor(sessionManager: AssistantSessionManager, chromaClient: any) {
        super(sessionManager, chromaClient);
        this.id = generateUsername("", 2, 38);
        this.sessionManager = sessionManager;
        this.sessionManager.sessions.push(this);
        this.setupHandlers();
        this.setupWorkflowListeners();
    }

    emit<T extends string | symbol>(event: T, ...args: any[]): boolean {
        super.emit(event, ...args);
        this._buffer = this._buffer || [];
        this._buffer.push({ event, data: args });
        return true;
    }

    async execute(command: string) {
        if (command.startsWith('.')) {
          this.emit('beforeExecuteSpecialCommand', { command })
          await this.executeSpecialCommand(command);
          this.emit('afterExecuteSpecialCommand', { command });
        } else {
          this.emit('beforeExecuteCommand', { command })
          const result = await super.execute(command);
          this.emit('afterExecuteCommand', { command });
          return result.success ? { success: true, data: result.data } : { success: false, error: result.error };
        }
        return { success: true, data: '' };
      }

    private setupWorkflowListeners() {
        this.on('taskComplete', (data) => this.emit('taskComplete', data));
        this.on('toolUpdated', (data) => this.emit('toolUpdated', data));
    }

    async processInput(input: string): Promise<any> {
        const result = await this.execute(input);
        if (result.success) {
            return result.data;
        } else {
            throw result.error;
        }
    }

    setupHandlers() {
        super.setupHandlers();
        this.on('interrupt', (error: any) => {
            this.onInterrupt();
        });
    }

    async executeSpecialCommand(command: string) {
        super.executeSpecialCommand(command);
        switch (command) {
            case '.state':
                this.showState();
                break;
            case '.exit':
                this.exitSession();
                break;
            default:
                this.emit('text', `Unknown command: ${command}`);
        }
    }

    onInterrupt() {
        if (!this.working) {
            this.emit('goodbye');
            console.log('Goodbye!');
            process.exit(0);
        }
        this.removeAllListeners();
        this.sessionManager.sessions = this.sessionManager.sessions.filter((session) => session.id !== this.id);
        this.sessionManager.activeSessionIndex = 0;
        this.sessionManager.switchToSession(0);
        this.emit('text', 'Session interrupted.');
    }

    restoreSessionState() {
        this.emit('restoreSessionState', this.savedOutput);
        this.printHistory();
    }

    showHelp() {
        const helpMessage = `Commands:
.help\t\tShow this help message
.debug\t\tToggle debug mode on/off
.history\tShow command history for this session
.state\t\tShow current state of the session
.exit\t\tExit this session
Ctrl+A\t\tCreate a new session
Ctrl+C\t\tSwitch to the next session`;
        this.emit('text', helpMessage);
        return helpMessage;
    }

    toggleDebug() {
        this.debug = !this.debug;
        this.emit('text', `Debug mode is now ${this.debug ? 'on' : 'off'}`);
    }

    printHistory() {
        if (this.history.length === 0) {
            this.emit('text', 'This session has no history yet.');
            return;
        }
        const sessionHistory: any = [`Session History:`]
        this.history.forEach((command, index) => {
            sessionHistory.push(`${index + 1}. ${command}`);
        });
        this.emit('text', sessionHistory.join('\n'));
    }

    showState() {
        const state = {
            id: this.id,
            debug: this.debug,
            history: this.history
        };
        this.emit('text', JSON.stringify(state, null, 2));
    }

    exitSession() {
        this.removeAllListeners();
        this.sessionManager.sessions = this.sessionManager.sessions.filter((session) => session.id !== this.id);
        this.sessionManager.activeSessionIndex = 0;
        this.sessionManager.switchToSession(0);
    }

    async handleToolCommand(args: string[]) {
        const [subCmd, ...subArgs] = args;

        switch (subCmd) {
            case 'list':
                this.listTools();
                break;
            case 'add':
                await this.addTool(subArgs);
                break;
            case 'update':
                await this.updateTool(args[0], args[1]); // args[0] = name, args[1] = source file
                break;
            case 'rollback':
                await this.rollbackTool(args[0], args[1]); // args[0] = name, args[1] = version
                break;
            case 'history':
                await this.showToolHistory(subArgs);
                break;
            case 'help':
            default:
                this.showToolHelp();
        }
    }

    // Call a tool with error handling and fallback strategies
    async callTool(toolName: string, params: any) {
        return super.callTool(toolName, params);
    }

    async listTools() {
        const tools = await this.sessionManager.getToolList();
        const toolNames = tools.map((tool: any) => `${tool.name} (v${tool.version})`);
        return [...toolNames];
    }

    async addTool(args: string[]) {
        if (args.length < 2) {
            this.emit('text', "Usage: .tool add <name> <source_file> <schema> [tag1,tag2,...]");
            return;
        }

        const [name, sourceFile, schema, tagsString] = args;
        const tags = tagsString ? tagsString.split(',') : [];

        try {
            const source: any = fs.readFileSync(sourceFile, 'utf8');
            const added = await this.sessionManager.addTool(name, source, schema, tags);
            if (added) {
                this.emit('text', `Tool '${name}' added successfully.`);
            } else {
                this.emit('warning',`Tool '${name}' already exists.`);
            }
        } catch (error) {
            this.emit('error', error.message);
        }
    }

    async createToolSchema(source: string) {
        const schema = this.sessionManager.createToolSchema(source);
        this.emit('text', JSON.stringify(schema, null, 2));
        return schema;
    }

    async updateTool(name: string, sourceFile: string): Promise<boolean> {
        try {
            const source: any = await fs.readFileSync(sourceFile, 'utf8');
            const updated: any = await this.updateTool(name, source);
            if (updated) {
                this.emit('toolUpdated', { name, version: updated.version });
            } else {
                this.emit('warning', `Tool '${name}' not found.`);
            }
            return updated;
        } catch (error) {
            this.emit('error', error.message);
        }
        return false;
    }

    async rollbackTool(name: string, version: string): Promise<boolean> {
        try {
            const rolledBack: any = await this.rollbackTool(name, version);
            if (rolledBack) {
                this.emit('toolRolledBack', { name, version });
            } else {
                this.emit('warning', `Failed to rollback tool '${name}' to version ${version}.`);
            }
        } catch (error) {
            this.emit('error', error.message);
        }
        return false;
    }

    showToolHelp() {
        const ret = `Tool management commands:
.tool list\t\t\tList all available tools
.tool add <name> <file> [tags]\tAdd a new tool
.tool update <name> <file>\tUpdate an existing tool
.tool rollback <name> <version>\tRollback a toolto a specific version
.tool history <name>\t\tShow version history of a tool`;
        this.emit('text', ret);
        return ret;
    }

    interrupt() {
        this.emit('interrupt');
    }

    // Call the language model agent
    async callAgent(input: string, model = 'claude', resultVar?: string): Promise<{ success: boolean; data?: any; error?: Error; }> {
        return super.callAgent(input, model, resultVar);
    }
    
    // Execute a JavaScript script with retry and error handling using vm2
    async callScript(script: string, retryLimit: number = 3): Promise<any> {
        return super.callScript(script, retryLimit);
    }
}

const client = new ChromaClient({
    path: 'http://localhost:8000',
});

// Main execution
const sessionManager = new AssistantSessionManager(client);

const assistant = new Assistant(sessionManager, sessionManager.chromaClient);

sessionManager.createNewSession();

sessionManager.on('newSessionCreated', (session) => {
    session.emit('text', `Assistant v${packageJson.version} ready. Type '.help' for available commands.`);
});

export default sessionManager;
export { assistant }.//colors.ts
import chalk from 'chalk';

export const colors = {
  userInput: chalk.cyan,
  aiResponse: chalk.green,
  error: chalk.red,
  warning: chalk.yellow,
  info: chalk.blue,
  debug: chalk.gray,
  success: chalk.green,
};
.//fuzzy_search.ts
export function fuzzySearch(items: string[], query: string): string[] {
    const lowercaseQuery = query.toLowerCase();
    return items.filter(item => {
      const lowercaseItem = item.toLowerCase();
      let i = 0, n = -1, l;
      for (; l = lowercaseQuery[i++] ;) {
        if (!~(n = lowercaseItem.indexOf(l, n + 1))) return false;
      }
      return true;
    });
  }.//logger.ts
// logger.ts

import winston from 'winston';
import chalk from 'chalk';

// Define custom log levels
const logLevels = {
  error: 0,
  warn: 1,
  info: 2,
  text: 2,
  debug: 3,
  verbose: 4,
};

// Create color scheme for log levels
const logColors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  text: 'green',
  debug: 'blue',
  verbose: 'cyan',
};

// Create Winston logger instance
const logger = winston.createLogger({
  levels: logLevels,
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(({ timestamp, level, message, service }) => {
      const color = logColors[level] || 'white';
      return `${chalk.gray(timestamp)} ${chalk[color](level.toUpperCase())} [${service}]: ${message}`;
    })
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
  ],
});

// Create a function to dynamically enable/disable log levels
function setLogLevel(level: string) {
  logger.level = level;
}

// Create a function to enable/disable specific services
const enabledServices = new Set<string>();

function toggleService(service: string, enabled: boolean) {
  if (enabled) {
    enabledServices.add(service);
  } else {
    enabledServices.delete(service);
  }
}

// Create a wrapper function for logging
function log(level: string, message: string, service: string) {
  if (enabledServices.has(service) || enabledServices.size === 0) {
    logger.log({ level, message, service });
  }
}

export { logger, setLogLevel, toggleService, log };.//ui.ts
import readline from 'readline';
import chalk from 'chalk';
import boxen from 'boxen';
import { EventEmitter } from 'eventemitter3';
import { Theme, themes } from './themes';

export class UI extends EventEmitter {
  readlineInterface: any;
  currentTheme: Theme;

  constructor() {
    super();
    this.readlineInterface = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: '> '
    });

    this.currentTheme = themes.default;
  }

  applyTheme(theme: Theme) {
    this.currentTheme = theme;
    this.updateOutput(`Applied ${theme.name} theme`, 'info');
    this.emit('themeChanged', theme as Theme);
  }

  switchTheme(themeName: string) {
    const newTheme = themes[themeName];
    if (newTheme) {
      this.applyTheme(newTheme);
      this.updateOutput(`Switched to ${newTheme.name} theme`, 'info');
      this.emit('themeChanged', newTheme);
    } else {
      this.updateOutput(`Theme '${themeName}' not found`, 'error');
    }
  }

  updateOutput(
    content: string,
    type: 'userInput' | 'aiResponse' | 'error' | 'warning' | 'info' | 'debug' | 'success' = 'info'
  ) {
    let coloredContent;
    switch (type) {
      case 'userInput':
        coloredContent = chalk.cyan(content);
        break;
      case 'aiResponse':
        coloredContent = chalk.green(content);
        break;
      case 'error':
        coloredContent = chalk.red(content);
        break;
      case 'warning':
        coloredContent = chalk.yellow(content);
        break;
      case 'info':
        coloredContent = chalk.blue(content);
        break;
      case 'debug':
        coloredContent = chalk.gray(content);
        break;
      case 'success':
        coloredContent = chalk.green(content);
        break;
      default:
        coloredContent = content;
    }
    // status is shown right above the prompt - we use terminal escape codes to move the cursor up
    process.stdout.write('\u001b[1A\u001b[2K');
    console.log(coloredContent);
  }

  getInput(): Promise<string> {
    return new Promise((resolve) => {
      this.readlineInterface.question('', (input) => {
        resolve(input);
      });
    });
  }

  displayBoxedContent(content: string, title?: string) {
    const boxedContent = boxen(content, {
      padding: 1,
      margin: 1,
      borderStyle: 'round',
      borderColor: 'cyan',
      title: title,
      titleAlignment: 'center',
    });
    console.log(boxedContent);
  }
}.//index.ts
import Assistant from "./assistant/assistant";
import { AssistantSessionManager, AssistantSession } from "./assistant/index";
import { MaintenanceManager } from './assistant/maintenance';
import chalk from "chalk";
import boxen from "boxen";
import { themes } from './themes';
import readline from 'readline';
import * as packageJson from "../package.json";
import fs from 'fs';
import { ChromaClient } from "chromadb";
import { tools } from "./assistant/tools";
import ajv from 'ajv';
import { Tool, toolRegistryTools } from "./assistant/tool_registry";
import { log, setLogLevel, toggleService } from './logger';
import { UI } from "./ui";
import os from 'os';
import { WorkflowResult } from "./assistant/workflow";

const jsonSchemaValidator = new ajv();

async function jsonValidator(
    jsonSchema: string,
    jsonData: string,
): Promise<boolean> {
    try {
        const schema = JSON.parse(jsonSchema);
        const data = JSON.parse(jsonData);
        const validate = jsonSchemaValidator.compile(schema);
        const valid = validate(data);
        return valid;
    } catch (error) {
        return false;
    }
}

// Generic error handling function for file system operations
async function handleFileError(context: any, api: any) {
    const logError = (message: string, level: string = 'error') => {
        log(level, message, 'FileOperations');
    };

    logError(`File operation error: ${JSON.stringify(context)} `);

    const llmResponse = await api.callTool('callLLM', {
        system_prompt: 'Analyze the file operation error and suggest a fix.',
        prompt: JSON.stringify(context),
    });

    if (llmResponse.fix) {
        logError(`Attempting LLM fix: ${llmResponse.fix} `, 'debug');
        try {
            // Attempt to apply the LLM's fix (make sure it's safe!)
            // ... (Implement safe fix application logic here)
        } catch (fixError: any) {
            logError(`LLM fix attempt failed: ${fixError.message} `, 'error');
        }
    }

    // Safe Fallback:
    if (context.errorCode === 'ENOENT') {
        logError('File not found. Suggest creating the file or checking the path.', 'info');
        // ... (Implement logic to suggest file creation or path correction)
    } else {
        logError(`Unhandled file error code: ${context.errorCode} `, 'error');
        // ... (Handle other error codes with appropriate fallbacks)
    }
}


class TerminalSessionManager extends AssistantSessionManager {
    ui: UI;
    commandHistory: string[] = [];
    currentHistoryPage: number = 1;
    itemsPerPage: number = 10;

    extraTools: any = {
        wait_for_keypress: {
            'name': 'wait_for_keypress',
            'version': '1.0.0',
            'description': 'wait_for_keypress pauses execution until the user presses a key. Returns the key that was pressed and sets it to the resultVar if provided.',
            'schema': {
                'name': 'wait_for_keypress',
                'description': 'wait_for_keypress pauses execution until the user presses a key. Returns the key that was pressed and sets it to the resultVar if provided.',
                "methodSignature": "wait_for_keypress(resultVar?: string): string",
            },
            execute: async ({ resultVar }: any, api: any) => {
                const readline = require('readline');
                const rl = readline.createInterface({
                    input: process.stdin,
                    output: process.stdout,
                });

                return new Promise((resolve) => {
                    rl.question('Press any key to continue...', (key: string) => {
                        rl.close();
                        if (resultVar) {
                            api.store[resultVar] = key;
                        }
                        resolve(key);
                    });
                });
            },
        },
        'busybox2': {
            'name': 'files',
            'version': '1.0.0',
            'description': 'Performs file operations. Supported operations include read, append, prepend, replace, insert_at, remove, delete, copy..',
            'schema': {
                'name': 'busybox2',
                'description': 'Performs file operations. Supported operations include read, append, prepend, replace, insert_at, remove, delete, copy..',
                "methodSignature": "files(operations: { operation: string, path?: string, match?: string, data?: string, position?: number, target?: string }[]): string",
            },
            execute: async function ({ operations }: any, run: any) {
                try {
                    const fs = require('fs');
                    const pathModule = require('path');
                    const cwd = process.cwd();
                    for (const { operation, path, match, data, position, target } of operations) {
                        const p = pathModule.join(cwd, path || '');
                        const t = pathModule.join(cwd, target || '');
                        if (!fs.existsSync(p || t)) {
                            return `Error: File not found at path ${p || t} `;
                        }
                        let text = fs.readFileSync(p, 'utf8');
                        switch (operation) {
                            case 'read':
                                return text;
                            case 'append':
                                text += data;
                                break;
                            case 'prepend':
                                text = data + text;
                                break;
                            case 'replace':
                                text = text.replace(match, data);
                                break;
                            case 'insert_at':
                                text = text.slice(0, position) + data + text.slice(position);
                                break;
                            case 'remove':
                                text = text.replace(match, '');
                                break;
                            case 'delete':
                                fs.unlinkSync(p);
                                break;
                            case 'copy':
                                fs.copyFileSync(p, t);
                                break;
                            default:
                                return `Error: Unsupported operation ${operation} `;
                        }
                        fs.writeFileSync(p, text);
                    }
                    return `Successfully executed batch operations on files`;
                } catch (error: any) {
                    const context = {
                        errorCode: error.code,
                        operations: operations,
                        // ... other details
                    };
                    await handleFileError(context, run);
                    return `File operation '${operations}' failed. Check logs for details.`;
                }
            },
        },
    }

    // constructor(public chromaClient: ChromaClient) {

    //     super(chromaClient);
    //     this.ui = new UI();
    //     this.initializeSessionManagement();
    //     this.startStatusBarUpdates();
    //     this.initializeThemeSupport();

    //     readline.emitKeypressEvents(process.stdin);
    //     if (process.stdin.isTTY) process.stdin.setRawMode(true);

    //     this.addTool('wait_for_keypress', this.extraTools.wait_for_keypress.execute.toString(), this.extraTools.wait_for_keypress.schema, ['utility']);
    //     this.addTool('list_tools', toolRegistryTools.list_tools.execute.toString(), toolRegistryTools.list_tools.schema, ['utility']);
    //     this.addTool('add_tool', toolRegistryTools.add_tool.execute.toString(), toolRegistryTools.add_tool.schema, ['utility']);
    //     this.addTool('update_tool', toolRegistryTools.update_tool.execute.toString(), toolRegistryTools.update_tool.schema, ['utility']);
    //     this.addTool('delete_tool', toolRegistryTools.delete_tool.execute.toString(), toolRegistryTools.delete_tool.schema, ['utility']);
    //     this.addTool('get_tool_metadata', toolRegistryTools.get_tool_metadata.execute.toString(), toolRegistryTools.get_tool_metadata.schema, ['utility']);
    //     this.addTool('update_tool_metadata', toolRegistryTools.update_tool_metadata.execute.toString(), toolRegistryTools.update_tool_metadata.schema, ['utility']);
    //     this.addTool('get_tool_performance', toolRegistryTools.get_tool_performance.execute.toString(), toolRegistryTools.get_tool_performance.schema, ['utility']);
    //     this.addTool('get_all_performance_metrics', toolRegistryTools.get_all_performance_metrics.execute.toString(), toolRegistryTools.get_all_performance_metrics.schema, ['utility']);
    //     this.addTool('run_maintenance', toolRegistryTools.run_maintenance.execute.toString(), toolRegistryTools.run_maintenance.schema, ['utility']);
    //     this.addTool('analyze_and_create_tool', toolRegistryTools.analyze_and_create_tool.execute.toString(), toolRegistryTools.analyze_and_create_tool.schema, ['utility']);
    //     this.addTool('predict_likely_tools', toolRegistryTools.predict_likely_tools.execute.toString(), toolRegistryTools.predict_likely_tools.schema, ['utility']);
    //     this.addTool('get_tool_history', toolRegistryTools.get_tool_history.execute.toString(), toolRegistryTools.get_tool_history.schema, ['utility']);
    //     this.addTool('rollback_tool', toolRegistryTools.rollback_tool.execute.toString(), toolRegistryTools.rollback_tool.schema, ['utility']);
    //     this.addTool('generate_tool_report', toolRegistryTools.generate_tool_report.execute.toString(), toolRegistryTools.generate_tool_report.schema, ['utility']);
    //     this.addTool('busybox2', this.extraTools.busybox2.execute.toString(), this.extraTools.busybox2.schema, ['utility']);

    //     const toolList = Object.values(tools);
    //     toolList.forEach((tool) => {
    //         this.addTool(tool.name, tool.execute.toString(), tool.schema, tool.tags);
    //     });

    //     setTimeout(async () => {
    //         this.sessions[this.activeSessionIndex] && this.sessions[this.activeSessionIndex].emit('text', 'running self-improvement tasks...')
    //         await this.generateAndRunTests();
    //         await this.improveTools();
    //     }, 60000);

    //     
    // }
    constructor(public chromaClient: ChromaClient) {
        super(chromaClient);
        this.ui = new UI();
        this.initializeSessionManagement();
        this.startStatusBarUpdates();
        this.initializeThemeSupport();
        this.initializeHistoryBrowser();
        this.registerExtraTools();
    }

    private registerExtraTools() {
        const extraTools = {
            wait_for_keypress: {
                name: 'wait_for_keypress',
                version: '1.0.0',
                description: 'Pauses execution until the user presses a key.',
                schema: {
                    name: 'wait_for_keypress',
                    description: 'Pauses execution until the user presses a key.',
                    methodSignature: "wait_for_keypress(resultVar?: string): string",
                },
                execute: async ({ resultVar }: any, api: any) => {
                    const readline = require('readline');
                    const rl = readline.createInterface({
                        input: process.stdin,
                        output: process.stdout,
                    });
    
                    return new Promise((resolve) => {
                        rl.question('Press any key to continue...', (key: string) => {
                            rl.close();
                            if (resultVar) {
                                api.store[resultVar] = key;
                            }
                            resolve(key);
                        });
                    });
                },
            },
            busybox2: {
                name: 'files',
                version: '1.0.0',
                description: 'Performs file operations.',
                schema: {
                    name: 'busybox2',
                    description: 'Performs file operations.',
                    methodSignature: "files(operations: { operation: string, path?: string, match?: string, data?: string, position?: number, target?: string }[]): string",
                },
                execute: async function ({ operations }: any, run: any) {
                    try {
                        const fs = require('fs');
                        const pathModule = require('path');
                        const cwd = process.cwd();
                        for (const { operation, path, match, data, position, target } of operations) {
                            const p = pathModule.join(cwd, path || '');
                            const t = pathModule.join(cwd, target || '');
                            if (!fs.existsSync(p || t)) {
                                return `Error: File not found at path ${p || t} `;
                            }
                            let text = fs.readFileSync(p, 'utf8');
                            switch (operation) {
                                case 'read':
                                    return text;
                                case 'append':
                                    text += data;
                                    break;
                                case 'prepend':
                                    text = data + text;
                                    break;
                                case 'replace':
                                    text = text.replace(match, data);
                                    break;
                                case 'insert_at':
                                    text = text.slice(0, position) + data + text.slice(position);
                                    break;
                                case 'remove':
                                    text = text.replace(match, '');
                                    break;
                                case 'delete':
                                    fs.unlinkSync(p);
                                    break;
                                case 'copy':
                                    fs.copyFileSync(p, t);
                                    break;
                                default:
                                    return `Error: Unsupported operation ${operation} `;
                            }
                            fs.writeFileSync(p, text);
                        }
                        return `Successfully executed batch operations on files`;
                    } catch (error: any) {
                        const context = {
                            errorCode: error.code,
                            operations: operations,
                            // ... other details
                        };
                        await handleFileError(context, run);
                        return `File operation '${operations}' failed. Check logs for details.`;
                    }
                },
            },
        };

        this.addTool('wait_for_keypress', this.extraTools.wait_for_keypress.execute.toString(), this.extraTools.wait_for_keypress.schema, ['utility']);
        this.addTool('list_tools', toolRegistryTools.list_tools.execute.toString(), toolRegistryTools.list_tools.schema, ['utility']);
        this.addTool('add_tool', toolRegistryTools.add_tool.execute.toString(), toolRegistryTools.add_tool.schema, ['utility']);
        this.addTool('update_tool', toolRegistryTools.update_tool.execute.toString(), toolRegistryTools.update_tool.schema, ['utility']);
        this.addTool('delete_tool', toolRegistryTools.delete_tool.execute.toString(), toolRegistryTools.delete_tool.schema, ['utility']);
        this.addTool('get_tool_metadata', toolRegistryTools.get_tool_metadata.execute.toString(), toolRegistryTools.get_tool_metadata.schema, ['utility']);
        this.addTool('update_tool_metadata', toolRegistryTools.update_tool_metadata.execute.toString(), toolRegistryTools.update_tool_metadata.schema, ['utility']);
        this.addTool('get_tool_performance', toolRegistryTools.get_tool_performance.execute.toString(), toolRegistryTools.get_tool_performance.schema, ['utility']);
        this.addTool('get_all_performance_metrics', toolRegistryTools.get_all_performance_metrics.execute.toString(), toolRegistryTools.get_all_performance_metrics.schema, ['utility']);
        this.addTool('run_maintenance', toolRegistryTools.run_maintenance.execute.toString(), toolRegistryTools.run_maintenance.schema, ['utility']);
        this.addTool('analyze_and_create_tool', toolRegistryTools.analyze_and_create_tool.execute.toString(), toolRegistryTools.analyze_and_create_tool.schema, ['utility']);
        this.addTool('predict_likely_tools', toolRegistryTools.predict_likely_tools.execute.toString(), toolRegistryTools.predict_likely_tools.schema, ['utility']);
        this.addTool('get_tool_history', toolRegistryTools.get_tool_history.execute.toString(), toolRegistryTools.get_tool_history.schema, ['utility']);
        this.addTool('rollback_tool', toolRegistryTools.rollback_tool.execute.toString(), toolRegistryTools.rollback_tool.schema, ['utility']);
        this.addTool('generate_tool_report', toolRegistryTools.generate_tool_report.execute.toString(), toolRegistryTools.generate_tool_report.schema, ['utility']);
        this.addTool('busybox2', this.extraTools.busybox2.execute.toString(), this.extraTools.busybox2.schema, ['utility']);

        // Register toolRegistryTools
        Object.entries(toolRegistryTools).forEach(([name, tool]) => {
            this.addTool(name, tool.execute.toString(), tool.schema, ['utility']);
        });
    }

    initializeThemeSupport() {
        this.ui.readlineInterface.on('line', (line: string) => {
            if (line.startsWith('.theme')) {
                const themeName = line.split(' ')[1];
                this.ui.switchTheme(themeName);
            } else {
                this.executeCommandInActiveSession(line);
            }
        });
    }

    initializeHistoryBrowser() {
        const commands = [
            '.history - Show command history',
            '.clear - Clear the screen',
            '.help - Show this help message',
            '.exit - Exit the current session',
            '.tools - Manage tools'
        ];
        this.ui.readlineInterface.on('line', (line: string) => {
            if (line.trim() === '.history') {
                this.showHistory();
            } else if (line.trim() === '.clear') {
                console.clear();
            } else if (line.trim() === '.help') {
                this.showHelp();
            } else if (line.trim() === '.exit') {
                this.exitSession();
            } else if (line.trim().startsWith('.tools')) {
                const args = line.trim().split(' ').slice(1);
                this.handleToolCommand(args);
            } else {
                this.executeCommandInActiveSession(line);
                this.commandHistory.push(line);
                this.currentHistoryPage = Math.ceil(this.commandHistory.length / this.itemsPerPage);
            }
        });
    }

    showHistory() {
        if (this.commandHistory.length === 0) {
            this.ui.updateOutput('No commands in history.', 'info');
            return;
        }
        const startIndex = (this.currentHistoryPage - 1) * this.itemsPerPage;
        const endIndex = Math.min(startIndex + this.itemsPerPage, this.commandHistory.length);
        for (let i = startIndex; i < endIndex; i++) {
            this.ui.updateOutput(`${i + 1}. ${this.commandHistory[i]}`, 'info');
        }
    }

    initializeSessionManagement() {
        this.createNewSession();
    }

    handleLogCommand(command: string) {
        const [, subCommand, ...args] = command.split(' ');
        switch (subCommand) {
            case 'level':
                setLogLevel(args[0]);
                log('info', `Log level set to: ${args[0]}`, 'TerminalSessionManager');
                break;
            case 'enable':
                toggleService(args[0], true);
                log('info', `Logging enabled for service: ${args[0]}`, 'TerminalSessionManager');
                break;
            case 'disable':
                toggleService(args[0], false);
                log('info', `Logging disabled for service: ${args[0]}`, 'TerminalSessionManager');
                break;
            default:
                log('error', 'Invalid log command. Use: .log level <level> | .log enable <service> | .log disable <service>', 'TerminalSessionManager');
        }
    }

    createNewSession() {
        const newSession = new TerminalSession(this, this.chromaClient);
        this.sessions.push(newSession);
        this.activeSessionIndex = this.sessions.length - 1;
        this.switchToSession(this.activeSessionIndex, false);
    }

    switchToPreviousSession() {
        if (this.sessions.length > 1) {
            this.activeSessionIndex = (this.activeSessionIndex - 1 + this.sessions.length) % this.sessions.length;
            this.switchToSession(this.activeSessionIndex);
        }
    }

    switchToNextSession() {
        if (this.sessions.length > 1) {
            this.activeSessionIndex = (this.activeSessionIndex + 1) % this.sessions.length;
            this.switchToSession(this.activeSessionIndex);
        }
    }

    async switchToSession(index: number, showPrompt: boolean = true) {
        this.activeSessionIndex = index;
        if (this.sessions[this.activeSessionIndex]) {
            super.switchToSession(index);
            this.ui.updateOutput(`Switched to session ${this.sessions[index].id}`);
            if (showPrompt) {
                this.ui.readlineInterface.prompt();
            }
        }
    }


    async executeCommandInActiveSession(command: string) {
        if (this.sessions.length === 0) {
            this.createNewSession();
        }
        const activeSession = this.sessions[this.activeSessionIndex] as TerminalSession;
        try {
            const result = await activeSession.execute(command);
            if (result.success) {
                this.ui.updateOutput(`Result: ${JSON.stringify(result.data)}`, 'aiResponse');
            } else {
                this.ui.updateOutput(`Error: ${result.error?.message}`, 'error');
            }
        } catch (error) {
            console.error('Error executing command:', error);
            this.ui.updateOutput(`Unexpected error: ${(error as Error).message}`, 'error');
        }
    }

    saveSessionState() {
        // Implementation removed as it was related to blessed
    }

    startStatusBarUpdates() {
        setInterval(() => {
            const activeSession = this.sessions[this.activeSessionIndex];
            const sessionInfo = `${activeSession.id} (${this.activeSessionIndex + 1}/${this.sessions.length})`;
            const activeTools = this.getActiveTools();
            const memoryUsage = process.memoryUsage().heapUsed / 1024 / 1024;
            const performance = os.loadavg()[0];
            this.ui.updateOutput(`Session: ${sessionInfo} | Active Tools: ${activeTools.join(', ')} | Memory: ${memoryUsage.toFixed(2)}MB | Performance: ${performance.toFixed(2)}ms`, 'info');
        }, 10000);
    }

    getActiveTools() {
        // Implement logic to get currently active tools
        return ['Tool1', 'Tool2']; // Placeholder
    }

    showHelp() {
        const helpText = `
Commands:
.help\t\tShow this help message
.debug\tToggle debug mode on/off
.history\tShow command history for this session
.state\t\tShow current state of the session
.exit\t\tExit this session
Ctrl+A\t\tCreate a new session
Ctrl+C\t\tSwitch to the next session
.log level <level>\tSet the log level (error, warn, info, debug, verbose)
.log enable <service>\tEnable logging for a specific service
.log disable <service>\tDisable logging for a specific service
`;
        this.ui.updateOutput(boxen(helpText, { padding: 1 }));
    }

    exitSession() {
        this.sessions[this.activeSessionIndex].emit('interrupt');
    }

    async handleToolCommand(args: string[]) {
        const [subCmd, ...subArgs] = args;

        switch (subCmd) {
            case 'list':
                this.listTools();
                break;
            case 'add':
                await this.addTool(subArgs[0], subArgs[1], subArgs[2], subArgs.slice(3)); // args[0] = name, args[1] = source file, args[2] = schema, args[3] = tags
                break;
            case 'update':
                await this.updateTool(args[0], args[1]); // args[0] = name, args[1] = source file
                break;
            case 'rollback':
                await this.rollbackTool(args[0], args[1]); // args[0] = name, args[1] = version
                break;
            case 'history':
                await this.showToolHistory(subArgs[0]); // args[0] = name
                break;
            case 'help':
            default:
                this.showToolHelp();
        }
    }

    // Call a tool with error handling and fallback strategies
    async callTool(toolName: string, params: any) {
        return super.callTool(toolName, params);
    }

    async listTools() {
        const tools = await this.getToolList();
        this.ui.updateOutput(chalk.bold("Available tools:"));
        tools.forEach((tool: any) => {
            this.ui.updateOutput(` ${chalk.cyan(tool.name)} (v${tool.version})`);
        });
        return tools.map((tool: any) => tool.name);
    }


    async addTool(name: string, source: string, schema: any, tags: string[]): Promise<boolean> {
        try {
            const added = await super.addTool(name, source, schema, tags);
            if (added) {
                log('info', chalk.green(`Tool '${name}' added successfully.`), 'TerminalSession');
            } else {
                log('warn', chalk.yellow(`Tool '${name}' already exists.`), 'TerminalSession');
            }
        } catch (error) {
            log('error', chalk.red(`Error adding tool: ${error.message}`), 'TerminalSession');
            return false;
        }

        return true;
    }

    async createToolSchema(source: string) {
        const schema = this.createToolSchema(source);
        return schema;
    }

    async updateTool(name: string, sourceFile: any): Promise<boolean> {
        if (arguments.length < 2) {
            this.ui.updateOutput("Usage: .tool update <name> <source_file>", 'error');
            return false;
        }

        try {
            // get the current tool
            const tool: Tool = await this.getTool(name);
            tool.source = sourceFile.improvedFunction;
            // we need to recreate the schema
            const schema = await this.createToolSchema(sourceFile.improvedFunction);

            // update the tool
            tool.schema = schema;
            const updated: any = await tool.saveTool();
            
            if (updated) {
                this.ui.updateOutput(`Tool '${name}' updated successfully.`, 'success');
            } else {
                this.ui.updateOutput(`Tool '${name}' not found.`, 'warning');
            }
            return updated;
        } catch (error) {
            this.ui.updateOutput(`Error updating tool: ${error.message}`, 'error');
            return false;
        }
    }

    async showToolHistory(name: string) {
        if (arguments.length < 1) {
            this.ui.updateOutput("Usage: .tool history <name>", 'error');
            return;
        }
        try {
            const history = await this.getToolHistory(name);
            this.ui.updateOutput(`Version history for tool '${name}':`);
            history.forEach((version: any) => {
                this.ui.updateOutput(` v${version.version} - ${version.date}`);
            });
        } catch (error) {
            this.ui.updateOutput(`Error getting tool history: ${error.message}`, 'error');
        }
    }

    async rollbackTool(name: string, version: string): Promise<boolean> {
        if (arguments.length < 2) {
            this.ui.updateOutput("Usage: .tool rollback <name> <version>", 'error');
            return false;
        }
        try {
            const rolledBack: any = await this.rollbackTool(name, version);
            if (rolledBack) {
                this.ui.updateOutput(`Tool '${name}' rolled back to version ${version} successfully.`, 'success');
            } else {
                this.ui.updateOutput(`Failed to rollback tool '${name}' to version ${version}.`, 'warning');
            }
            return rolledBack;
        } catch (error) {
            this.ui.updateOutput(`Error rolling back tool: ${error.message}`, 'error');
            return false;
        }
    }

    showToolHelp() {
        const toolHelp = `
Tool management commands:
.tool list\t\t\tList all available tools
.tool add <name> <file> [tags]\tAdd a new tool
.tool update <name> <file>\tUpdate an existing tool
.tool rollback <name> <version>\tRollback a tool to a specific version
.tool history <name>\t\tShow version history of a tool
`;
        this.ui.updateOutput(boxen(toolHelp, { padding: 1 }));
    }
}

class TerminalSession extends AssistantSession {

    constructor(sessionManager: TerminalSessionManager, chromaClient: any) {
        super(sessionManager, chromaClient);
        this.setupUIHandlers();
        this.on('beforeExecuteCommand', (data: any) => {
            log('info', `${data.command}`, 'TerminalSession');
        });
        this.on('afterExecuteCommand', (data: any) => {
            if (data.success) {
                log('info', `Result: ${data.data}`, 'TerminalSession');
            } else {
                log('error', `Error: ${data.error}`, 'TerminalSession');
            }
            (this.sessionManager as TerminalSessionManager).ui.readlineInterface.prompt();
        });
        this.on('taskComplete', (data) => {
            log('info', `Task completed: ${data.task.name}`, 'TerminalSession');
            log('info', `Result: ${data.result}`, 'TerminalSession');
        });

        this.on('toolUpdated', (data) => {
            log('info', `Tool updated: ${data.name}`, 'TerminalSession');
        });
    }

    async execute(command: string): Promise<{ success: boolean; data: any; error?: undefined; } | { success: boolean; error: Error; data?: undefined; }> {
        try {
            this.history.push(command);
            this.working = true;

            this.emit('beforeExecuteCommand', { command });

            const result = await this.callAgent(command);

            const workflowResult: WorkflowResult = result.success !== undefined
                ? result as WorkflowResult
                : { success: true, data: result };

            this.emit('afterExecuteCommand', workflowResult);

            return workflowResult as any;
        } catch (error) {
            console.error('Error in TerminalSession execute:', error);
            const errorResult: WorkflowResult = { success: false, error: error as Error };
            this.emit('afterExecuteCommand', errorResult);
            return errorResult as any;
        } finally {
            this.working = false;
            this.emit('show-prompt');
        }
    }

    async callAgent(input: string, model = 'claude', resultVar?: string) {
        const sm: any = this.sessionManager;
        try {
            const result = await super.callAgent(input, model, resultVar);
            return result;
        } catch (error) {
            throw error;
        }
    }

    setupHandlers() {
        super.setupHandlers();
        this.on('ready', (error: any) => {
            this.onPrompt();
        });
        this.on('interrupt', (error: any) => {
            this.onInterrupt();
        });
    }

    setupUIHandlers() {
        let sm = this.sessionManager as any;

        this.on('beforeExecuteCommand', (data: any) => {
            sm.ui.updateOutput(`Executing: ${data.command}`, 'userInput');
        });

        this.on('afterExecuteCommand', (data: any) => {
            if (data.success) {
                sm.ui.updateOutput(`Result:`, 'success');
                sm.ui.displayBoxedContent(JSON.stringify(data.data, null, 2), 'Command Result');
            } else {
                sm.ui.updateOutput(`Error: ${data.error}`, 'error');
            }
        });

        this.on('taskComplete', (data: any) => {
            sm.updateOutput(`Task completed: ${data.task.name}`, 'success');
            sm.displayBoxedContent(JSON.stringify(data.result, null, 2), 'Task Result');
        });

        this.on('toolUpdated', (data: any) => {
            sm.updateOutput(`Tool updated: ${data.name}`, 'success');
        });

        this.on('ready', (error: any) => {
            this.onPrompt();
        });

        this.on('codeOutput', (data: any) => {
            sm.updateOutput(data.code, 'code');
        });
    }

    log(level: string, message: string, service: string) {
        const formattedMessage = `[${service}] ${level.toUpperCase()}: ${message}`;
        (this.sessionManager as TerminalSessionManager).ui.updateOutput(formattedMessage);
    }

    onSessionComplete({ message }: any) {
        log('info', message, 'TerminalSession');
        (this.sessionManager as TerminalSessionManager).ui.readlineInterface.prompt();
    }

    async executeSpecialCommand(command: string) {
        super.executeSpecialCommand(command);
        switch (command) {
            case '.state':
                this.showState();
                break;
            case '.exit':
                this.exitSession();
                break;
            default:
                log('error', `Unknown command: ${command}`, 'TerminalSession');
        }
        (this.sessionManager as TerminalSessionManager).ui.readlineInterface.prompt();
    }

    onBeforeEvent(data: any) {
        if (this.debug) {
            log('debug', JSON.stringify(data, null, 2), 'TerminalSession');
        }
    }

    onPrompt() {
        (this.sessionManager as TerminalSessionManager).ui.readlineInterface.prompt();
    }

    onInterrupt() {
        if (!this.working) {
            log('info', 'Goodbye!', 'TerminalSession');
            process.exit(0);
        }
        this.removeAllListeners();
        this.sessionManager.sessions = this.sessionManager.sessions.filter((session) => session.id !== this.id);
        this.sessionManager.activeSessionIndex = 0;
        this.sessionManager.switchToSession(0);

        log('info', 'Session interrupted.', 'TerminalSession');
    }

    restoreSessionState() {
        // Restore the saved output and print it to the console
        process.stdout.write(this.savedOutput);
        this.printHistory();
    }

    showHelp() {
        const helpText = `
Commands:
.help\t\tShow this help message
.debug\tToggle debug mode on/off
.history\tShow command history for this session
.state\t\tShow current state of the session
.exit\t\tExit this session
Ctrl+A\t\tCreate a new session
Ctrl+C\t\tSwitch to the next session
.log level <level>\tSet the log level (error, warn, info, debug, verbose)
.log enable <service>\tEnable logging for a specific service
.log disable <service>\tDisable logging for a specific service
`;
        log('info', boxen(helpText, { padding: 1 }), 'TerminalSession');
        return helpText;
    }

    toggleDebug() {
        this.debug = !this.debug;
        log('info', `Debug mode is now ${this.debug ? 'on' : 'off'}`, 'TerminalSession');
    }

    printHistory() {
        if (this.history.length === 0) {
            log('info', 'This session has no history yet.', 'TerminalSession');
            return;
        }
        log('info', 'Session History:', 'TerminalSession');
        this.history.forEach((command, index) => {
            log('info', `${index + 1}. ${command}`, 'TerminalSession');
        });
    }

    showState() {
        const state = {
            id: this.id,
            debug: this.debug,
            history: this.history
        };
        log('info', boxen(JSON.stringify(state, null, 2), { padding: 1 }), 'TerminalSession');
    }

    exitSession() {
        this.removeAllListeners();
        this.sessionManager.sessions = this.sessionManager.sessions.filter((session) => session.id !== this.id);
        this.sessionManager.activeSessionIndex = 0;
        this.sessionManager.switchToSession(0);
    }

    async handleToolCommand(args: string[]) {
        const [subCmd, ...subArgs] = args;

        switch (subCmd) {
            case 'list':
                this.listTools();
                break;
            case 'add':
                await this.addTool(subArgs);
                break;
            case 'update':
                await this.updateTool(args[0], args[1]); // args[0] = name, args[1] = source file
                break;
            case 'rollback':
                await this.rollbackTool(args[0], args[1]); // args[0] = name, args[1] = version
                break;
            case 'history':
                await this.showToolHistory(subArgs);
                break;
            case 'help':
            default:
                this.showToolHelp();
        }
    }

    // Call a tool with error handling and fallback strategies
    async callTool(toolName: string, params: any) {
        return super.callTool(toolName, params);
    }

    async listTools() {
        const tools = await this.sessionManager.getToolList();
        log('info', chalk.bold("Available tools:"), 'TerminalSession');
        tools.forEach((tool: any) => {
            log('info', ` ${chalk.cyan(tool.name)} (v${tool.version})`, 'TerminalSession');
        });
        return tools.map((tool: any) => tool.name);
    }

    async addTool(args: string[]) {
        if (args.length < 2) {
            log('error', "Usage: .tool add <name> <source_file> <schema> [tag1,tag2,...]", 'TerminalSession');
            return;
        }

        const [name, sourceFile, schema, tagsString] = args;
        const tags = tagsString ? tagsString.split(',') : [];

        try {
            const source: any = fs.readFileSync(sourceFile, 'utf8');
            const added = await this.sessionManager.addTool(name, source, schema, tags);
            if (added) {
                log('info', chalk.green(`Tool '${name}' added successfully.`), 'TerminalSession');
            } else {
                log('warn', chalk.yellow(`Tool '${name}' already exists.`), 'TerminalSession');
            }
        } catch (error) {
            log('error', chalk.red(`Error adding tool: ${error.message}`), 'TerminalSession');
        }
    }

    async createToolSchema(source: string) {
        const schema = this.sessionManager.createToolSchema(source);
        return schema;
    }

    async updateTool(name: string, sourceFile: string): Promise<boolean> {
        if (arguments.length < 2) {
            log('error', "Usage: .tool update <name> <source_file>", 'TerminalSession');
            return false;
        }

        try {
            // get the current tool
            const tool = await this.sessionManager.getTool(name);

            const source: any = await fs.promises.readFile(sourceFile, 'utf8');
            const updated: any = await this.sessionManager.updateTool(name, source, tool.schema, tool.tags);
            if (updated) {
                log('info', chalk.green(`Tool '${name}' updated successfully.`), 'TerminalSession');
            } else {
                log('warn', chalk.yellow(`Tool '${name}' not found.`), 'TerminalSession');
            }
            return updated;
        } catch (error) {
            log('error', chalk.red(`Error updating tool: ${error.message}`), 'TerminalSession');
            return false;
        }
    }

    async rollbackTool(name: string, version: string): Promise<boolean> {
        if (arguments.length < 2) {
            log('error', "Usage: .tool rollback <name> <version>", 'TerminalSession');
            return false;
        }
        try {
            const rolledBack: any = await this.sessionManager.rollbackTool(name, version);
            if (rolledBack) {
                log('info', chalk.green(`Tool '${name}' rolled back to version ${version} successfully.`), 'TerminalSession');
            } else {
                log('warn', chalk.yellow(`Failed to rollback tool '${name}' to version ${version}.`), 'TerminalSession');
            }
            return rolledBack;
        } catch (error) {
            log('error', chalk.red(`Error rolling back tool: ${error.message}`), 'TerminalSession');
            return false;
        }
    }

    showToolHelp() {
        const toolHelp = `
        Tool management commands:
        .tool list\t\t\tList all available tools
        .tool add <name> <file> [tags]\tAdd a new tool
        .tool update <name> <file>\tUpdate an existing tool
        .tool rollback <name> <version>\tRollback a tool to a specific version
        .tool history <name>\t\tShow version history of a tool
        `;
        log('info', boxen(toolHelp, { padding: 1 }), 'TerminalSession');
        return toolHelp;
    }

    interrupt() {
        this.emit('interrupt');
    }

    // Execute a JavaScript script with retry and error handling using vm2
    async callScript(script: string, retryLimit: number = 10): Promise<any> {
        try {
            const result = await super.callScript(script, retryLimit);
            return result;
        } finally {
            // No spinner to stop in this version
        }
    }
}


const client = new ChromaClient({
    path: 'http://localhost:8000',
});

// Main execution
const sessionManager = new TerminalSessionManager(client);

// Handle command-line arguments
const args = process.argv.slice(2);

if (args.length === 0) {
    log('info', chalk.bold.yellow(`AI Assistant CLI Version ${packageJson.version}`), 'Main');
    log('info', chalk.yellow("Type '.help' for instructions."), 'Main');
    sessionManager.ui.readlineInterface.prompt();
} else {
    const assistant = new Assistant(sessionManager, sessionManager.chromaClient);
    const maintenanceManager = new MaintenanceManager(
        assistant,
        sessionManager,
        assistant.memoryStore
    );
    setInterval(() => {
        maintenanceManager.performMaintenance();
    }, 24 * 60 * 60 * 1000);
    const query = args.join(' ');
    assistant.callAgent(query).then((response) => {
        process.exit(0);
    }).catch((error) => {
        log('error', error, 'Main');
        process.exit(1);
    })
}
.//visualization_api.ts
import { UI } from "./ui";

export class VisualizationAPI {
    constructor(private ui: UI) {}
  
    createLineChart(title: string, data: {x: number[], y: number[], title: string}) {
      this.ui.createChart('line', title, data);
    }
  
    createBarChart(title: string, data: {titles: string[], data: number[]}) {
      this.ui.createChart('bar', title, data);
    }
  
    createPieChart(title: string, data: {percent: number, label: string}[]) {
      this.ui.createChart('pie', title, data);
    }
  
    updateChart(title: string, data: any) {
      this.ui.updateChart(title, data);
    }
  }
  .//themes.ts
export interface Theme {
    name: string;
    background: string;
    foreground: string;
    border: string;
    focus: {
      border: string;
    };
    scrollbar: {
      bg: string;
    };
  }
  
  
  export const themes: { [key: string]: Theme } = {
    default: {
      name: 'Default',
      background: 'black',
      foreground: 'white',
      border: 'gray',
      focus: {
        border: 'cyan',
      },
      scrollbar: {
        bg: 'gray',
      },
    },
    light: {
      name: 'Light',
      background: 'white',
      foreground: 'black',
      border: 'gray',
      focus: {
        border: 'blue',
      },
      scrollbar: {
        bg: 'lightgray',
      },
    },
    dark: {
      name: 'Dark',
      background: '#1e1e1e',
      foreground: '#d4d4d4',
      border: '#3c3c3c',
      focus: {
        border: '#0078d4',
      },
      scrollbar: {
        bg: '#3c3c3c',
      },
    },
    highContrast: {
      name: 'High Contrast',
      background: 'black',
      foreground: 'yellow',
      border: 'white',
      focus: {
        border: 'cyan',
      },
      scrollbar: {
        bg: 'white',
      },
    },
  };