import { create } from "domain";

export class PromptBuilder {
  private basePrompt: string;
  private inputFields: { [key: string]: string } = {};
  private outputFormat: string = '';

  constructor(basePrompt: string) {
    this.basePrompt = basePrompt;
  }

  addInput(key: string, value: string): PromptBuilder {
    this.inputFields[key] = value;
    return this;
  }

  setOutputFormat(format: string): PromptBuilder {
    this.outputFormat = format;
    return this;
  }

  build(): string {
    let prompt = this.basePrompt;
    for (const [key, value] of Object.entries(this.inputFields)) {
      prompt = prompt.replace(`{${key}}`, value);
    }
    if (this.outputFormat) {
      prompt += `\n\nOutput Format:\n${this.outputFormat}`;
    }
    return prompt;
  }
}

export function makePromptFunction(conversation: any, systemPrompt: any, jsonResultFormat = undefined) {
  return async (userPrompt: any) => {
    if (jsonResultFormat) {
      systemPrompt = JSON.stringify({
        systemPrompt: systemPrompt,
        resultFormat: jsonResultFormat,
        options: ['DISABLE_ALL_COMMENTARY', 'DISABLE_CODEBLOCKS', 'JSON_OUTPUT_ONLY']
      });
    }
    try {
      const messages = [
        {
          role: 'system',
          content: systemPrompt,
        },
        {
          role: 'user',
          content: userPrompt,
        },
      ];
      const response = await conversation.chat(messages);
      const res = jsonResultFormat ? JSON.parse(response.content[0].text) : response.content[0].text;
      return res;
    } catch (error) {
      console.error(`Error calling prompt:`, error);
      throw error;
    }
  }
}

export const createPrompts = (conversation) => ({
  projectOverview: makePromptFunction(conversation, `
You are an AI assistant working on a sophisticated AI-powered CLI application. The project is structured as follows:

1. Core Components:
    - Assistant: The main class that handles task processing, tool management, and interaction with the AI model.
    - TerminalSessionManager: Manages multiple terminal sessions and user interactions.
    - TerminalSession: Represents an individual user session, handling command execution and state management.
    - ToolRegistry: Manages the available tools, including adding, updating, and calling tools.
    - MemoryStore: Handles storage and retrieval of past interactions and their outcomes.
    - Conversation: Manages interactions with the underlying AI model (Claude or Gemini).

2. Key Files:
    - main.ts: The entry point of the application, setting up the TerminalSessionManager and handling command-line arguments.
    - assistant.ts: Contains the Assistant class, which is the core of the application's intelligence.
    - terminalSessionManager.ts: Implements the TerminalSessionManager class.
    - terminalSession.ts: Implements the TerminalSession class.
    - toolRegistry.ts: Implements the ToolRegistry class and related tool management functions.
    - memoryStore.ts: Implements the MemoryStore class for managing application memory.
    - conversation.ts: Implements the Conversation class for interacting with AI models.
    - prompts.ts: Contains all the prompts used by the application, including this overview.

3. Utility Components:
    - ErrorLogger: Handles error logging and analysis.
    - UI: Manages the user interface and output formatting.
    - PromptBuilder: A utility class for constructing complex prompts.

4. Key Concepts:
    - Tools: Executable functions that the AI can use to perform specific tasks.
    - Memories: Stored past interactions and their outcomes for context and learning.
    - Tasks: Subtasks generated by the AI to accomplish user requests.
    - Prompts: Carefully crafted instructions for the AI to guide its responses and actions.

5. Workflow:
    - User input is received through the TerminalSessionManager.
    - The input is processed by the Assistant, which may involve:
      a. Retrieving relevant memories
      b. Decomposing the task into subtasks
      c. Executing tools
      d. Generating responses
    - Results are stored in memory for future reference.
    - The output is presented to the user through the UI.

6. Advanced Features:
    - Multi-session support: Users can create and switch between multiple sessions.
    - Dynamic tool management: Tools can be added, updated, or rolled back at runtime.
    - Error handling and recovery: The system attempts to recover from errors and can even fix its own scripts.
    - Continuous improvement: The system can optimize its tools and scripts over time.

When working with this project, keep in mind the following principles:
1. Modularity: Each component should have a clear, single responsibility.
2. Extensibility: The system should be easy to extend with new tools and capabilities.
3. Robustness: Error handling and recovery mechanisms should be in place at all levels.
4. Intelligence: Leverage the AI's capabilities to make the system more adaptive and powerful.
5. User-friendliness: Despite its complexity, the system should present a clear and intuitive interface to the user.

Your role is to assist in maintaining, extending, and improving this system. When given tasks related to this project, consider how they fit into the overall architecture and aim to maintain or enhance the system's capabilities and structure.
`),

  fixScript: makePromptFunction(conversation, (errorDescription: string) => new PromptBuilder(`
Analyze the provided script, script error, and context, generate a fixed version of the script, and output it and an explanation of your work in a JSON object.

Error Description:
{errorDescription}

Provide a fixed version of the script and an explanation of the changes made.
    `)
    .addInput('errorDescription', errorDescription)
    .build(),
    `{ "modifiedScript": string, "explanation": string }`
  ),

  adaptMemory: makePromptFunction(conversation, (memory: any, newInput: string) => new PromptBuilder(`
      Given a new input and a similar previous experience, please adapt the previous response to fit the new input:

      Previous Input: ${memory.input}
      Previous Response: ${memory.response}
      Tools Used: ${memory.usedTools.join(', ')}
      New Input: ${newInput}

      Adapted Response:
    `)
    .addInput('memory', JSON.stringify(memory))
    .addInput('newInput', newInput)
    .build()
  ),

  taskDecomposition: makePromptFunction(conversation, (toolsRepresentation: string, memoriesRepresentation: string) => new PromptBuilder(`
Transform the given task into a sequence of subtasks, each with a JavaScript script that uses the provided tools to achieve the subtask objective.

Available Tools:
${toolsRepresentation}

Similar Past Experiences:
${memoriesRepresentation}
`)
    .build(),
    `{
    "task": "<taskName>:<description>",
    "script": "<JavaScript script>",
    "chat": "<subtask explanation>",
    "resultVar": "<optional result variable>"
}[]`
  ),

  generateTestHarness: makePromptFunction(conversation, (source: string, schema: any) =>
    new PromptBuilder(`
      You are a test coverage generator for javascript functions. Given a javascript function and its schema and description, you generate a test harness which thoroughly tests the function. You write your test harnesses in the following format:
      \`\`\`javascript
      const testHarness = {
          beforeAll: (context) => {
              context.log('beforeAll');
          },
          test1: (context) => {
              context.log('test1');
              context.assert(true, 'Test 1 passed');
          },
          test2: (context) => {
              context.log('test2');
          },
      };
      \`\`\`

      Tool Source:
      {source}

      Schema:
      {schema}

      You output RAW Javascript CODE ONLY. Do not include any comments or explanations in the code.
    `)
      .addInput('source', JSON.stringify(source))
      .addInput('schema', JSON.stringify(schema))
      .build()
  ),

  hardenToolCode: makePromptFunction(conversation, (source: string) => new PromptBuilder(`
      You are a tool hardener. You take the given Javascript and you harden it if you see any security or execution vulnerabilities. You harden code by:
      - removing any awaiters and other intermediate-output code
      - adding any missing import statements
      - fixing any broken code. 
      - You output only RAW JAVASCRIPT, WITHOUT ANY COMMENTARY, EXPLANATION or FORMATTING.

      Source Code:
      {source}
    `)
    .addInput('source', source)
    .build()
  ),

  enhanceToolCode: makePromptFunction(conversation, (source: string) => new PromptBuilder(`
      You are a tool enhancer. You take the given Javascript and you enhance it by:
      - enhancing options and settings
      - adding functionality which will make the tool more useful
      - adding more logging and error handling
      - You output only RAW JAVASCRIPT, WITH COMMENTARY, EXPLANATION and FORMATTING.

      Source Code:
      {source}
    `)
    .addInput('source', source)
    .build()
  ),

  prepareFunction: makePromptFunction(conversation, (source: string) => new PromptBuilder(`
      You prepare javascript code for execution. You take the given Javascript and you:
      - fix any broken code
      - remove any awaiters and other intermediate-output code
      - add any missing import statements
      - Do NOT export the function, just return it as a string
      - You output only RAW JAVASCRIPT, WITH COMMENTARY, EXPLANATION and FORMATTING.

      Source Code:
      {source}
    `)
    .addInput('source', source)
    .build()
  ),

  createToolSchema: makePromptFunction(conversation, (tool: string) => new PromptBuilder(`
      Given the source code of a tool, you generate a schema for it. 

Example schema 1: 
{ 
  'name': 'file', 
  'description': 'Performs file operations like read, write, append, prepend, replace, insert, remove, delete, copy', 
  'input_schema': { 
    'type': 'object', 
    'properties': { 
      'operation': { 
        'type': 'string', 
        'description': 'The operation to perform on the file. Supported operations: read, write, append, prepend, replace, insert_at, remove, delete, copy', 
        'enum': ['read', 'write', 'append', 'prepend', 'replace', 'insert_at', 'remove', 'delete', 'copy'], 
      }, 
      'path': { 
        'type': 'string', 
        'description': 'The path to the file. Required for all operations except 'list_attached'.', 
      }, 
      'match': { 
        'type': 'string', 
        'description': 'The string or regex pattern to match. Required for 'replace' and 'remove' operations.', 
      }, 
      'data': { 
        'type': 'string', 
        'description': 'The data to write, append, prepend, replace, or insert. Required for 'write', 'append', 'prepend', 'replace', and 'insert_at' operations.', 
      }, 
      'position': { 
        'type': 'number', 
        'description': 'The position to insert the data at. Required for 'insert_at' operation.', 
      }, 
      'target': { 
        'type': 'string', 
        'description': 'The target path for the 'copy' operation.', 
      }, 
    }, 
    'required': ['operation'], 
  }, 
  'output_schema': { 
    'type': 'string', 
    'description': 'A message indicating the result of the file operation.', 
  }, 
}

Example Schema 2: 
{
  'name': 'files', 
  'description': 'Performs batch file operations.', 
  'input_schema': {
    'type': 'object', 
    'properties': {
      'operations': {
        'type': 'array', 
        'description': 'An array of file operations to perform.', 
        'items': {
          'type': 'object', 
          'properties': {
            'operation': {
              'type': 'string', 
              'description': 'The operation to perform on the file.', 
              'enum': ['read', 'append', 'prepend', 'replace', 'insert_at', 'remove', 'delete', 'copy', 'attach', 'list_attached', 'detach']
            }, 
            'path': {
              'type': 'string', 
              'description': 'The path to the file. Required for all operations except 'list_attached'.', 
            }, 
            'match': {
              'type': 'string', 
              'description': 'The string or regex pattern to match. Required for 'replace' and 'remove' operations.', 
            }, 
            'data': {
              'type': 'string', 
              'description': 'The data to write, append, prepend, replace, or insert. Required for 'write', 'append', 'prepend', 'replace', and 'insert_at' operations.', 
            }, 
            'position': {
              'type': 'number', 
              'description': 'The position to insert the data at. Required for 'insert_at' operation.', 
            }, 
            'target': {
              'type': 'string', 
              'description': 'The target path for the 'copy' operation.', 
            }, 
          }, 
          'required': ['operation']
        }
      }
    }, 
    'required': ['operations']
  }, 
  'output_schema': {
    'type': 'string', 
    'description': 'A message indicating the result of the batch file operations.'
  }
}

Examine the source code of the tool and generate a schema for it: 
{tool}
`)
    .addInput('tool', JSON.stringify(tool))
    .build()
  ),

  cleanupToolCode: makePromptFunction(conversation, (tool: string) => new PromptBuilder(`
      You are a tool cleaner. You take the given Javascript and you clean it by:
      - fixing any broken code
      - removing any awaiters and other intermediate-output code
      - adding any missing import statements
      - Do NOT export the function, just return it as a string
      - You output only RAW JAVASCRIPT, WITHOUT ANY COMMENTARY, EXPLANATION or FORMATTING.

      Source Code:
      {tool}
    `)
    .addInput('tool', tool)
    .build()
  ),

  improveTool: makePromptFunction(conversation, (tool: string) => new PromptBuilder(`
      You are javascript developer working to improve javascript functions. Given the function's source code, schema, and any existing test results, <important>output an improved version of the function. If you cannot improve the function, output the original source code.</important><critical>output NO commentary, explanation or formatting</critical>

      Tool Source: {tool}
    `)
    .addInput('tool', tool)
    .build()
  ),

  createNewToolWithLLM: makePromptFunction(conversation, (description: string, schema: any, constraints: string[]) => new PromptBuilder(`
      You create Javascript functions given a set of instructions. 
      You will be given a description, a schema, and a set of constraints. 
      Generate the JavaScript code for a tool that fulfills the requirements while observing the constraints.
      Return a JSON object with the following format: { "name": "function_name", "description": "Brief description", "methodSignature": "function_name(param1: type, param2: type): returnType", "source": "function function_name(param1, param2) { ... }" }
      You output only RAW JAVASCRIPT, WITHOUT ANY COMMENTARY, EXPLANATION or FORMATTING.

      Description: {description}
      Schema: {schema}
      Constraints: {constraints}
    `)
    .addInput('description', description)
    .addInput('schema', JSON.stringify(schema))
    .addInput('constraints', constraints.join(', '))
    .build()
  ),

  analyzeAndCreateToolFromScript: makePromptFunction(conversation, (script: string, taskDescription: string, existingToolNames: string[]) => new PromptBuilder(`
Given the following script and task description, determine if this script represents a unique and reusable functionality not adequately covered by existing tools.

Existing tools: {existingToolNames}

Script:
{script}

Task Description:
{taskDescription}

If this script represents a unique and reusable functionality, provide the following in JSON format:
1. A semantically-meaningful function name
2. A brief description of the tool's functionality
3. A method signature
4. Any necessary modifications to make the script more generalized and reusable

If the functionality is already adequately represented by existing tools, return null.
    `)
    .addInput('existingToolNames', existingToolNames.join(', '))
    .addInput('script', script)
    .addInput('taskDescription', taskDescription)
    .build(),
    `{
  "name": "function_name",
  "description": "Brief description",
  "methodSignature": "function_name(param1: type, param2: type): returnType",
  "modifiedScript": "// Modified script code"
}`
  ),

  reviewAutoGeneratedTool: makePromptFunction(conversation, (tool: any) => new PromptBuilder(`
Review the following auto-generated tool and determine if it should be kept, modified, or removed:

Name: {name}
Description: {description}
Method Signature: {methodSignature}
Source:
{source}

Provide your recommendation in JSON format:
{
  "action": "keep" | "modify" | "remove",
  "reason": "Brief explanation",
  "modifications": "If action is 'modify', provide the modified source code here"
}
    `)
    .addInput('name', tool.name)
    .addInput('description', tool.schema.description)
    .addInput('methodSignature', tool.schema.methodSignature)
    .addInput('source', tool.source)
    .build()
  ),

  standardizeTool: makePromptFunction(conversation, (name: string, source: string, schema: any) => new PromptBuilder(`
You are an AI assistant tasked with standardizing tool code into a specific module format. Use the template below, incorporating the given code into the execute function. Fix any obvious issues and ensure the code is properly formatted and exported.

Template:

// This is javascript code for a tool module
class {name}Tool {

  async execute(params, api) {
    // Tool implementation goes here
  }

}

module.exports = new {name}Tool();

Original Tool Code:
{source}

Schema:
{schema}

Please provide the complete standardized tool module code, including the class definition and export.
<critical>DO NOT include any commentary, explanation, or formatting. YOUR OUTPUT SHOULD BE RAW Javascript Code</critical>
    `)
    .addInput('name', name)
    .addInput('source', source)
    .addInput('schema', JSON.stringify(schema, null, 2))
    .build()
  ),

  taskProcessingDecompose: makePromptFunction(conversation, (task: string, tools: string, memories: string, mode = 'decompose') =>
    new PromptBuilder(`
Process the following task according to the specified mode:

Task: {task}

Available Tools:
{tools}

Relevant Memories:
{memories}

Mode: decompose

Decompose the task into subtasks with clear objectives and scripts.
`)
      .addInput('task', task)
      .addInput('tools', tools)
      .addInput('memories', memories)
      .addInput('mode', mode)
      .build(),
    '[{"task": "name:description", "script": "code", "chat": "explanation"}]'
  ),

  analyzeCode: makePromptFunction(conversation, (code: string) =>
    new PromptBuilder(`
  Analyze the following code:
  
  Code:
  {code}
  
  Provide insights on structure, bugs, performance, and improvements.
    `)
      .addInput('code', code)
      .build(),
    '{"structure": "", "bugs": "", "performance": "", "improvements": ""}'
  ),

  explainCode: makePromptFunction(conversation, (code: string) =>
    new PromptBuilder(`
Explain the following code:

Code:
{code}

Explain the code in simple terms, avoiding technical jargon where possible.
  `)
    .addInput('code', code)
    .build(),
  'String explanation'
  ),

  auditCode: makePromptFunction(conversation, (code: string) =>
    new PromptBuilder(`
Audit the following code for security vulnerabilities:

Code:
{code}

Identify potential security vulnerabilities and suggest mitigations.
  `)
    .addInput('code', code)
    .build(),
  '[{"vulnerability": "", "mitigation": ""}]'
),

  improveCode: makePromptFunction(conversation, (code: string) =>
    new PromptBuilder(`
Improve the following code:

Code:
{code}

Suggest improvements or optimizations for the given code.
  `)
    .addInput('code', code)
    .build(),
  '{"improvedCode": "", "explanations": []}'
  ),

  taskProcessingAnalyse: makePromptFunction(conversation, (task: string, tools: string, memories: string, mode = 'analyze') =>
    new PromptBuilder(`
Process the following task according to the specified mode:

Task: {task}

Available Tools:
{tools}

Relevant Memories:
{memories}

Mode: {mode}

Analyze the task and provide insights on approach and potential challenges.
`)
      .addInput('task', task)
      .addInput('tools', tools)
      .addInput('memories', memories)
      .addInput('mode', mode)
      .build(),
    '{"approach": string, "challenges": string, "recommendations": string}'
  ),

  visualizeData: makePromptFunction(conversation, (data: string, context: string) =>
    new PromptBuilder(`
  Process the following data for visualization:

  Data: {data}
  Context: {context}

  Suggest appropriate data visualization techniques.
    `)
      .addInput('data', data)
      .addInput('context', context)
      .build(),
    '[{"chartType": "", "rationale": ""}]'
  ),

  analyzeData: makePromptFunction(conversation, (data: string, context: string) =>
    new PromptBuilder(`
  Analyze the following data:

  Data: {data}
  Context: {context}

  Provide a detailed analysis of the data.
    `)
      .addInput('data', data)
      .addInput('context', context)
      .build(),
    '{"insights": [], "correlations": [], "anomalies": []}'
  ),

  summarizeData: makePromptFunction(conversation, (data: string, context: string) =>
    new PromptBuilder(`
  Summarize the following data:

  Data: {data}
  Context: {context}

  Summarize the key points and insights from the data.
    `)
      .addInput('data', data)
      .addInput('context', context)
      .build(),
    '{"summary": "", "keyPoints": []}'
  ),

  analyzeError: makePromptFunction(conversation, (error: string, context: string) =>
    new PromptBuilder(`
  Analyze the following error:
  
  Error: {error}
  Context: {context}
  
  Analyze the error and suggest potential causes.
    `)
      .addInput('error', error)
      .addInput('context', context)
      .build(),
    '{"possibleCauses": [], "impactAssessment": ""}'
  ),

  explainError: makePromptFunction(conversation, (error: string, context: string) =>
    new PromptBuilder(`
  Explain the following error:
  
  Error: {error}
  Context: {context}
  
  Explain the error in user-friendly terms.
    `)
      .addInput('error', error)
      .addInput('context', context)
      .build(),
    'String explanation'
  ),

  fixError: makePromptFunction(conversation, (error: string, context: string) =>
    new PromptBuilder(`
  Suggest a fix for the following error:
  
  Error: {error}
  Context: {context}
  
  Suggest a fix or workaround for the error.
    `)
      .addInput('error', error)
      .addInput('context', context)
      .build(),
    '{"fixSuggestion": "", "preventionTips": []}'
  ),

  commandProcessing: makePromptFunction(conversation, (compactRepresentation: string, memoriesRepresentation: string) =>
    new PromptBuilder(`Transform the given task into a sequence of subtasks, each with a JavaScript script that uses the provided tools to achieve the subtask objective.

Available Tools:
{compactRepresentation}

Similar Past Experiences:
{memoriesRepresentation}

Additional tools can be explored using 'list_all_tools', 'get_tool_details', and 'load_tool'.

Process:

1. Analyze the task and identify necessary steps, considering similar past experiences
2. Decompose into subtasks with clear objectives and input/output
3. For each subtask, write a JavaScript script using the tools
  a. Access previous subtask results with taskResults.<taskName>_results: \`const lastResult = taskResults.firstTask_results; ...\`
  b. Store subtask results in a variable for future use: \`const result = { key: 'value' }; taskResults.subtask_results = result; ...\`
  c. End the script with a return statement for the subtask deliverable: \`return result;\`
4. Test each script and verify the output
5. Provide a concise explanation of the subtask's purpose and approach MAKE SURE THE SCRIPT YOU WRITE IS JAVASCRIPT.

Data Management:

- Store subtask results in resultVar (JSON/array format): \`taskResults.subtask_results = result;\`
Access previous subtask data with taskResults.<resultVar>: \`const lastResult = taskResults.subtask_results; ...\`
Include only resultVar instructions in responses, not the actual data.

`)
      .addInput('compactRepresentation', compactRepresentation)
      .addInput('memoriesRepresentation', memoriesRepresentation)
      .build(),
    `
      [
        {
          "task": "<taskName>:<description>",
          "script": "<JavaScript script>",
          "chat": "<subtask explanation>",
          "resultVar": "<optional result variable>"
        },
        // ... additional subtasks
      ]
    `
  ),

  jsonPromptExamples: makePromptFunction(conversation, (compactRepresentation: string, memoriesRepresentation: string) => new PromptBuilder(`
    
Examples:

\`\`\`json
[
  {
    "task": "get_last_100_lines:Get the last 100 lines of each log file in the /var/log directory",
    "script": "const files = await bash('ls /var/log');\nconst lastLines = await callLLMs({ prompts: files.split('\\n'), system_prompt: 'Write a shell script that prints the last 100 lines of the given file: \\$\{file}', resultVar: 'last100Lines' });\ntaskResults.last100Lines_results = lastLines;\nreturn lastLines;",
    "chat": "This subtask first lists all files in the \`/var/log\` directory. Then, it uses the \`callLLMs\` tool to generate a shell script for each file, which will extract the last 100 lines of that file. The results are stored in the \`last100Lines\` variable.",
    "resultVar": "last100Lines"
  },
  {
    "task": "extract_errors:Extract timestamps and error messages from the retrieved log lines",
    "script": "const errors = [];\nfor (const line of taskResults.last100Lines_results) {\n if (line.includes('ERROR')) {\n const timestampRegex = /\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}/;\n const timestampMatch = line.match(timestampRegex);\n const timestamp = timestampMatch ? timestampMatch[1] : 'N/A';\n const errorMessage = line.split('ERROR')[1].trim();\n errors.push({ timestamp, message: errorMessage });\n }\n}\ntaskResults.errors_results = errors;\nreturn errors;",
    "chat": "This subtask iterates through the \`last100Lines\` results and extracts timestamps and error messages for lines containing 'ERROR'. The extracted information is stored in the \`errors\` variable.",
    "resultVar": "errors"
  },
  {
    "task": "save_error_report:Save the extracted errors as a JSON file",
    "script": "await bash('echo \\\"' + JSON.stringify(taskResults.errors_results) + '\\\" > error_report.json');\nreturn 'Error report saved to error_report.json';",
    "chat": "This subtask writes the extracted errors (from the \`errors\` variable) to a JSON file named \`error_report.json\`."
  },
  {
    "task": "create_project_structure:Create the directory structure for the project",
    "script": "await bash('mkdir my-node-project');\ntaskResults.projectPath_results = 'my-node-project';\nreturn 'Project directory created';",
    "chat": "Creates the main project directory (\`my-node-project\`)",
    "resultVar": "projectPath"
  },
  {
    "task": "create_config_file:Create and populate the config.json file",
    "script": "const config = { welcomeMessage: 'Hello from the new Node.js project!' };\nawait bash('echo \\\"' + JSON.stringify(config, null, 2) + '\\\" > \\\"' + taskResults.projectPath_results + '/config.json\\\"');\nreturn 'Configuration file created';",
    "chat": "Creates \`config.json\` within the project directory and adds a default welcome message."
  },
  {
    "task": "generate_utils_module:Create the utils.js module with a logging function",
    "script": "const utilsCode = \`const logMessage = (message) => { console.log(message); };\nmodule.exports = { logMessage };\n\`;\nawait bash('echo \\\"' + utilsCode + '\\\" > \\\"' + taskResults.projectPath_results + '/utils.js\\\"');\nreturn 'Utility module created';",
    "chat": "Creates \`utils.js\` with a function to log messages to the console."
  },
  {
    "task": "generate_index_file:Create the main index.js file with logic to load configuration and use the utils module",
    "script": "const indexCode = \`const config = require('./config.json');\nconst { logMessage } = require('./utils');\nlogMessage(config.welcomeMessage);\n\`;\nawait bash('echo \\\"' + indexCode + '\\\" > \\\"' + taskResults.projectPath_results + '/index.js\\\"');\nreturn 'Index file created';",
    "chat": "Creates \`index.js\`, which loads configuration and uses the \`logMessage\` function from \`utils.js\`."
  },
  {
    "task": "list_files:List the files in a directory",
    "script": "await bash('ls /home/user/documents');\nreturn 'Files listed';",
    "chat": "This subtask lists all files in the \`/home/user/documents\` directory using the \`ls\` command.",
    "resultVar": null
  },
  {
    "task": "check_file_existence:Check if a file exists",
    "script": "await bash('test -f /home/user/documents/report.txt');\nreturn 'File exists';",
    "chat": "This subtask checks if the \`report.txt\` file exists in the \`/home/user/documents\` directory using the \`test\` command.",
    "resultVar": null
  },
  {
    "task": "copy_file:Copy a file to a different location",
    "script": "await bash('cp /home/user/documents/report.txt /home/user/backup');\nreturn 'File copied';",
    "chat": "This subtask copies the \`report.txt\` file from \`/home/user/documents\` to \`/home/user/backup\` using the \`cp\` command.",
    "resultVar": null
  },
  {
    "task": "move_file:Move a file to a different location",
    "script": "await bash('mv /home/user/documents/report.txt /home/user/backup');\nreturn 'File moved';",
    "chat": "This subtask moves the \`report.txt\` file from \`/home/user/documents\` to \`/home/user/backup\` using the \`mv\` command.",
    "resultVar": null
  },
  {
    "task": "delete_file:Delete a file",
    "script": "await bash('rm /home/user/documents/report.txt');\nreturn 'File deleted';",
    "chat": "This subtask deletes the \`report.txt\` file from the \`/home/user/documents\` directory using the \`rm\` command.",
    "resultVar": null
  },
  {
    "task": "create_directory:Create a new directory",
    "script": "await bash('mkdir /home/user/new-directory');\nreturn 'Directory created';",
    "chat": "This subtask creates a new directory named \`new-directory\` in the \`/home/user\` directory using the \`mkdir\` command.",
    "resultVar": null
  },
  {
    "task": "delete_directory:Delete a directory",
    "script": "await bash('rmdir /home/user/new-directory');\nreturn 'Directory deleted';",
    "chat": "This subtask deletes the \`new-directory\` directory from the \`/home/user\` directory using the \`rmdir\` command.",
    "resultVar": null
  },
  {
    "task": "print_current_directory:Print the current working directory",
    "script": "await bash('pwd');\nreturn 'Current working directory printed';",
    "chat": "This subtask prints the current working directory using the \`pwd\` command.",
    "resultVar": null
  },
  {
    "task": "change_directory:Change the current working directory",
    "script": "await bash('cd /home/user/documents');\nreturn 'Directory changed';",
    "chat": "This subtask changes the current working directory to \`/home/user/documents\` using the \`cd\` command.",
    "resultVar": null
  }
]
\`\`\`

CRITICAL: Verify the JSON output for accuracy and completeness before submission. *** OUTPUT ONLY JSON ***`),
    `[
      {
        "task": "string",
        "script": "string",
        "chat": "string",
        "resultVar": "string | null"
      }
    ]`
  ),

  listAllTools: makePromptFunction(conversation, () =>
    new PromptBuilder(`
      List all available tools with a brief description and the method signature for each tool. The tools should be presented in a structured format for easy reference.
    `)
      .build(),
    `[
        {
          "name": "tool_name",
          "description": "Brief description",
          "methodSignature": "function_name(param1: type, param2: type): returnType"
        },
        // ... additional tools
      ]`
  ),

  getToolDetails: makePromptFunction(conversation, (toolName: string) =>
    new PromptBuilder(`
      Retrieve the detailed information for the specified tool.

      Tool Name: {toolName}
    `)
      .addInput('toolName', toolName)
      .build(),
    `{
        "name": "tool_name",
        "description": "Detailed description",
        "methodSignature": "function_name(param1: type, param2: type): returnType",
        "source": "function function_name(param1, param2) { ... }"
      }`
  ),

  loadTool: makePromptFunction(conversation, (toolName: string) =>
    new PromptBuilder(`
      Load the specified tool for use in the current task.

      Tool Name: {toolName}
    `)
      .addInput('toolName', toolName)
      .build(),
    `{
        "name": "tool_name",
        "description": "Brief description",
        "methodSignature": "function_name(param1: type, param2: type): returnType",
        "source": "function function_name(param1, param2) { ... }"
      }`
  ),

  listAllMemories: makePromptFunction(conversation, () =>
    new PromptBuilder(`
      List all available memories with a brief description and the method signature for each memory. The memories should be presented in a structured format for easy reference.
    `)
      .build(),
    `[
        {
          "name": "memory_name",
          "description": "Brief description",
          "methodSignature": "function_name(param1: type, param2: type): returnType"
        },
        // ... additional memories
      ]`
  ),

  getMemoryDetails: makePromptFunction(conversation, (memoryName: string) =>
    new PromptBuilder(`
      Retrieve the detailed information for the specified memory.

      Memory Name: {memoryName}
    `)
      .addInput('memoryName', memoryName)
      .build(),
    `{
        "name": "memory_name",
        "description": "Detailed description",
        "methodSignature": "function_name(param1: type, param2: type): returnType",
        "source": "function function_name(param1, param2) { ... }"
      }`
  ),

  summarizeConversation: makePromptFunction(conversation, (conversationBuffer: Array<{ role: string, content: string }>) => new PromptBuilder(`
    Analyze the following conversation and provide a concise summary of the recent activity and context. Focus on the user's goals, key decisions, and any important information discovered during the conversation.

    Conversation:
    ${JSON.stringify(conversationBuffer, null, 2)}

    Summary:
  `)
    .addInput('conversationBuffer', JSON.stringify(conversationBuffer))
    .build()
  ),

});