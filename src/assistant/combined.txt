.//metrics/__test__/metrics.test.ts
import { MetricsService } from '../metricsService';
import fs from 'fs';

jest.mock('fs');

describe('MetricsService', () => {
  let metricsService: MetricsService;

  beforeEach(() => {
    (fs.existsSync as jest.Mock).mockReturnValue(false);
    (fs.writeFileSync as jest.Mock).mockImplementation(() => {});
    metricsService = new MetricsService();
    // Reset the mock calls count after service initialization
    (fs.writeFileSync as jest.Mock).mockClear();
  });

  it('should record tool addition', () => {
    metricsService.recordToolAddition('newTool');
    expect(fs.writeFileSync).toHaveBeenCalledTimes(1);
  });

  it('should record tool update', () => {
    metricsService.recordToolAddition('existingTool');
    (fs.writeFileSync as jest.Mock).mockClear(); // Clear previous calls
    metricsService.recordToolUpdate('existingTool');
    expect(fs.writeFileSync).toHaveBeenCalledTimes(1);
  });

  it('should record tool usage', () => {
    metricsService.recordToolAddition('usedTool');
    (fs.writeFileSync as jest.Mock).mockClear(); // Clear previous calls
    metricsService.recordToolUsage('usedTool', 100, true);
    expect(fs.writeFileSync).toHaveBeenCalledTimes(1);
  });

  it('should get tool metrics', () => {
    metricsService.recordToolAddition('metricTool');
    metricsService.recordToolUsage('metricTool', 100, true);
    const metrics = metricsService.getToolMetrics('metricTool');
    expect(metrics).toBeDefined();
    expect(metrics?.usageCount).toBe(1);
  });

  it('should generate a report', () => {
    metricsService.recordToolAddition('reportTool');
    metricsService.recordToolUsage('reportTool', 100, true);
    const report = metricsService.generateReport();
    expect(report).toContain('reportTool');
  });
});.//metrics/metricsService.ts
// metricsService.ts
import fs from 'fs';
import path from 'path';

interface ToolMetrics {
  additionDate: string;
  lastUpdateDate: string;
  usageCount: number;
  averageExecutionTime: number;
  totalExecutionTime: number;
  successRate: number;
  totalExecutions: number;
  successfulExecutions: number;
}

export class MetricsService {
  private metrics: Map<string, ToolMetrics>;
  private metricsFilePath: string;

  constructor(metricsFilePath: string = path.join(__dirname, '../../metrics.json')) {
    this.metricsFilePath = metricsFilePath;
    this.metrics = new Map();
    this.loadMetrics();
  }

  private loadMetrics(): void {
    if (fs.existsSync(this.metricsFilePath)) {
      const data = fs.readFileSync(this.metricsFilePath, 'utf8');
      const jsonMetrics = JSON.parse(data);
      this.metrics = new Map(Object.entries(jsonMetrics));
    }
  }

  private saveMetrics(): void {
    const jsonMetrics = Object.fromEntries(this.metrics);
    fs.writeFileSync(this.metricsFilePath, JSON.stringify(jsonMetrics, null, 2));
  }

  recordToolAddition(toolName: string): void {
    const now = new Date().toISOString();
    this.metrics.set(toolName, {
      additionDate: now,
      lastUpdateDate: now,
      usageCount: 0,
      averageExecutionTime: 0,
      totalExecutionTime: 0,
      successRate: 1,
      totalExecutions: 0,
      successfulExecutions: 0,
    });
    this.saveMetrics();
  }

  recordToolUpdate(toolName: string): void {
    const metrics = this.metrics.get(toolName);
    if (metrics) {
      metrics.lastUpdateDate = new Date().toISOString();
      this.saveMetrics();
    }
  }

  recordToolUsage(toolName: string, executionTime: number, success: boolean): void {
    const metrics = this.metrics.get(toolName);
    if (metrics) {
      metrics.usageCount++;
      metrics.totalExecutionTime += executionTime;
      metrics.totalExecutions++;
      if (success) {
        metrics.successfulExecutions++;
      }
      metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalExecutions;
      metrics.successRate = metrics.successfulExecutions / metrics.totalExecutions;
      this.saveMetrics();
    }
  }

  recordToolRemoval(toolName: string): void {
    this.metrics.delete(toolName);
    this.saveMetrics();
  }

  getToolMetrics(toolName: string): ToolMetrics | undefined {
    return this.metrics.get(toolName);
  }

  getAllMetrics(): Map<string, ToolMetrics> {
    return new Map(this.metrics);
  }

  generateReport(): string {
    let report = "Tool Metrics Report\n==================\n\n";
    for (const [toolName, metrics] of this.metrics.entries()) {
      report += `Tool: ${toolName}\n`;
      report += `  Added: ${metrics.additionDate}\n`;
      report += `  Last Updated: ${metrics.lastUpdateDate}\n`;
      report += `  Usage Count: ${metrics.usageCount}\n`;
      report += `  Average Execution Time: ${metrics.averageExecutionTime.toFixed(2)}ms\n`;
      report += `  Success Rate: ${(metrics.successRate * 100).toFixed(2)}%\n`;
      report += `  Total Executions: ${metrics.totalExecutions}\n\n`;
    }
    return report;
  }
}.//tools/tool.ts
  import Conversation from '../conversation/conversation';
import { ScriptMetadata } from '../script/metadataManager';

  export class Tool {
    static conversation: any;
    execute: any;
    constructor(
      public name: string,
      public source: string,
      public schema: any,
      public tags: string[],
      public metadata: ScriptMetadata,
      public _execute: Function
    ) {
      Tool.conversation = new Conversation('claude');
      if(_execute) {
        this.execute = _execute;
      } else {
        this.execute = (params: any): Promise<any> => {
          const func = new Function('params', this.source);
          return func(params, { conversation: Tool.conversation });
        }
      }
    }
  
    update(source: string, schema: any, tags: string[], metadata: Partial<ScriptMetadata>): void {
      this.source = source;
      this.schema = schema;
      this.tags = tags;
      this.metadata = {
        ...this.metadata,
        ...metadata,
        lastModifiedDate: new Date(),
        version: this.incrementVersion(this.metadata.version)
      };
    }
  
    private incrementVersion(version: string): string {
      const [major, minor, patch] = version.split('.').map(Number);
      return `${major}.${minor}.${patch + 1}`;
    }

    public needsImprovement(): boolean {
      return this.metadata.tags.includes('needs-improvement');
    }
}.//tools/toolRegistry.ts
// toolRegistry.ts
import { Tool } from './tool';
import { MetricsService } from '../metrics/metricsService';
import { ConversationService } from '../conversation/conversationService';
import { ScriptManager } from '../script/scriptManager';
import { ToolWatcher } from './toolWatcher';
import { ScriptMetadata } from '../script/metadataManager';
import { makePromptFunction } from '../prompts/promptService';
import * as tools from '../defaultTools';
import { log } from '../logging/logger';

const bash = {
  'name': 'bash',
  'version': '1.0.0',
  'description': 'Performs bash operations. Supported operations include execute.',
  'schema': {
      'name': 'bash',
      'description': 'Performs bash operations. Supported operations include execute.',
      "methodSignature": "bash({ operations: { operation: string, command: string }[...] }): string",
  },
  execute: async function (operations, run) {
      const result: any = [];
      if(!Array.isArray(operations)) operations = [operations];
      try {
          const { execSync } = require('child_process');
          for (const { command } of operations) {
             result.push( execSync(command, { stdio: 'inherit' }));
          }
          return result.length > 1 ? result : result[0];
      }
      catch (error) {
          return error.message;
      }
  },
};

export class ToolRegistry {
  private tools: Map<string, Tool> = new Map();
  private scriptManager: ScriptManager;
  public toolWatcher: ToolWatcher;
  private conversation: any;
  constructor(
    private metricsService: MetricsService,
    private conversationService: ConversationService
  ) {
    this.scriptManager = new ScriptManager(this);
    this.initialize();
    this.toolWatcher = new ToolWatcher(this);
    this.conversation = this.conversationService.conversation;

    this.addTool('bash', bash.execute.toString(), bash.schema, ['auto-generated'], bash.execute);
    for(const [k,v] of Object.entries(tools.tools)) {
      const tool = v as any;
      this.addTool(tool.schema.name, tool.execute.toString(), tool.schema, [], tool.execute);
      console.log(`Tool added: ${tool.schema.name}`);
    }
  }

  async initialize(): Promise<void> {
    await this.scriptManager.initialize();
    await this.toolWatcher.initialize();

  }

  async reviewAutoGeneratedTools(): Promise<void> {
    const allTools = await this.getToolList();
    const autoGeneratedTools = allTools.filter(tool => tool.tags.includes('auto-generated'));
  
    for (const tool of autoGeneratedTools) {
      const reviewPrompt = `
        Review the following auto-generated tool and determine if it should be kept, modified, or removed:
  
        Name: ${tool.name}
        Description: ${tool.schema.description}
        Source:
        ${tool.source}
  
        Provide your recommendation in JSON format:
        {
          "action": "keep" | "modify" | "remove",
          "reason": "Brief explanation",
          "modifications": "If action is 'modify', provide the modified source code here"
        }
      `;
  
      const reviewResult = await this.conversationService.chat([
        { role: 'system', content: 'You are an AI assistant tasked with reviewing and maintaining the tool registry.' },
        { role: 'user', content: reviewPrompt }
      ]);
  
      const { action, reason, modifications } = JSON.parse(reviewResult.content[0].text);
  
      switch (action) {
        case 'keep':
          console.log(`Tool '${tool.name}' kept. Reason: ${reason}`);
          break;
        case 'modify':
          await this.updateTool(tool.name, modifications, tool.schema, tool.tags);
          console.log(`Tool '${tool.name}' modified. Reason: ${reason}`);
          break;
        case 'remove':
          await this.removeTool(tool.name);
          console.log(`Tool '${tool.name}' removed. Reason: ${reason}`);
          break;
      }
    }
  }

  // install an npm package in our environment
  async installPackage(packageName: string): Promise<void> {
    // simulate installation
    await new Promise(resolve => setTimeout(resolve, 2000));
    console.log(`Package installed: ${packageName}`);
  }

  async installPackages(packages: string[]): Promise<void> {
    const promises: any = [];
    for (const pkg of packages) {
      promises.push(this.installPackage(pkg));
    }
    await Promise.all(promises);
  }

  async createTools(tools: any) {
    const promises: any = [];
    for (const tool of tools) {
      promises.push(this.addTool(tool.name, tool.execute.toString(), tool.schema, tool.tags, tool.execute));
    }
    await Promise.all(promises);
  }

  async callTool(name: string, params: any): Promise<any> {
    if (!this. tools.has(name)) {
      throw new Error(`Tool not found: ${name}`);
    }
    const tool = this.tools.get(name)!;
    const startTime = Date.now();
    try {
      const result = await tool.execute(params, this);
      const executionTime = Date.now() - startTime;
      this.metricsService.recordToolUsage(name, executionTime, true);
      return result;
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.metricsService.recordToolUsage(name, executionTime, false);
      throw error;
    }
  }

  async addTool(name: string, source: string, schema: any, tags: string[], _execute: any, metadata?: Partial<ScriptMetadata>): Promise<boolean> {
    if (this.tools.has(name)) {
      return false;
    }
    const defaultMetadata: ScriptMetadata = {
      originalQuery: '',
      creationDate: new Date(),
      lastModifiedDate: new Date(),
      author: 'System',
      version: '1.0.0',
      tags: tags,
      dependencies: [],
      description: schema.description || ''
    };
    const fullMetadata = { ...defaultMetadata, ...metadata };
    const tool = new Tool(name, source, schema, tags, fullMetadata, _execute);
    this.tools.set(name, tool);
    this.metricsService.recordToolAddition(name);
    return true;
  }

  async updateTool(name: string, source: string, schema: any, tags: string[], metadata?: Partial<ScriptMetadata>): Promise<boolean> {
    if (!this.tools.has(name)) {
      return false;
    }
    const tool = this.tools.get(name)!;
    tool.update(source, schema, tags, metadata || {});
    this.metricsService.recordToolUpdate(name);
    return true;
  }

  async removeTool(name: string): Promise<boolean> {
    if (this.tools.has(name)) {
      this.tools.delete(name);
      this.metricsService.recordToolRemoval(name);
      return true;
    }
    return false;
  }

  getMetrics(toolName: string): any {
    return this.metricsService.getToolMetrics(toolName);
  }

  getAllMetrics(): Map<string, any> {
    return this.metricsService.getAllMetrics();
  }

  getCompactRepresentation(): string {
    return Array.from(this.tools.keys())
      .map(name => `${name}: ${this.tools.get(name)!.schema.description}`)
      .join('\n');
  }

  async getTool(name: string): Promise<Tool | undefined> {
    return this.tools.get(name);
  }

  async getToolList(): Promise<Tool[]> {
    return Array.from(this.tools.values());
  }

  async cleanupUnusedScripts(): Promise<void> {
    await this.scriptManager.cleanupUnusedScripts();
  }

  async addMetadata(scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    await this.scriptManager.addMetadata(scriptName, metadata);
  }

  async getMetadata(scriptName: string): Promise<ScriptMetadata | null> {
    return await this.scriptManager.getMetadata(scriptName);
  }

  async updateMetadata(scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    await this.scriptManager.updateMetadata(scriptName, metadata);
  }

  async removeMetadata(scriptName: string): Promise<void> {
    await this.scriptManager.removeMetadata(scriptName);
  }

  async predictLikelyTools(input: any): Promise<{ tool: string, justification: string }[]> {
    const toolNames = Array.from(this.tools.keys());
    const systemPrompt = 'You are tasked with selecting the most appropriate tools for accomplishing a given task.';
    const prompt = `Given the request: ${input.task}\nand tools: ${toolNames.join(', ')}\n${systemPrompt}\n
Which tools do you think would be most useful for accomplishing the task?
Provide your predictions as an array of tool names and your justification for each choice.`;
    const response = makePromptFunction(
      this.conversationService, 
      systemPrompt, 
      prompt, 
      { task: 'required' }, 
      '{ tool: string, justification: string }[]'
    )(input);
    return response;
  }

  async improveTools(): Promise<void> {
    for (const tool of this.tools.values()) {
      if (tool.needsImprovement()) {
        const improvedSource = await this.getImprovedToolSource(tool);
        await this.updateTool(tool.name, improvedSource, tool.schema, tool.tags);
      }
    }
  }

  async analyzeAndCreateToolFromScript(script: string, taskName: string, taskDescription: string): Promise<void> {
    const analysis = await this.analyzeScript(script, taskDescription);
    if (analysis.shouldCreateTool) {
      await this.addTool(taskName, analysis.source, analysis.schema, analysis.tags, new Function('params', analysis.source));
    }
  }

  private async getImprovedToolSource(tool: Tool): Promise<string> {
    return tool.source;
  }

  private async analyzeScript(script: string, taskDescription: string): Promise<any> {
    return {
      shouldCreateTool: true,
      name: 'new-tool',
      source: script,
      schema: {},
      tags: ['auto-generated']
    };
  }

  hasTool(name: string): boolean {
    return this.tools.has(name);
  }

}.//tools/toolWatcher.ts
// toolWatcher.ts
import chokidar from 'chokidar';
import path from 'path';
import fs from 'fs';
import { ToolRegistry } from '../tools/toolRegistry';
import { loggingService } from '../logging/logger';

export class ToolWatcher {
  private watcher: chokidar.FSWatcher;
  private toolsDir: string;

  constructor(private toolRegistry: ToolRegistry) {
    this.toolsDir = path.join(__dirname, '../../tools');
    // does the tools directory exist?
    if (!fs.existsSync(this.toolsDir)) {
      fs.mkdirSync(this.toolsDir);
    }
    this.watcher = chokidar.watch(this.toolsDir, {
      ignored: /(^|[\/\\])\../, // ignore dotfiles
      persistent: true
    });

    this.setupWatcher();
  }

  public async initialize() {
    await this.loadExistingTools();
  }

  private setupWatcher() {
    this.watcher
      .on('add', (filePath) => this.handleNewFile(filePath))
      .on('change', (filePath) => this.handleFileChange(filePath))
      .on('unlink', (filePath) => this.handleFileRemoval(filePath));
  }

  private async handleNewFile(filePath: string) {
    loggingService.info(`New tool file detected: ${filePath}`, { service: 'ToolWatcher' });
    await this.loadTool(filePath);
  }

  private async handleFileChange(filePath: string) {
    loggingService.info(`Tool file changed: ${filePath}`, { service: 'ToolWatcher' });
    await this.loadTool(filePath);
  }

  private async handleFileRemoval(filePath: string) {
    loggingService.info(`Tool file removed: ${filePath}`, { service: 'ToolWatcher' });
    const toolName = path.basename(filePath, '.ts');
    await this.toolRegistry.removeTool(toolName);
  }


  private async loadTool(filePath: string) {
    try {
      const toolName = path.basename(filePath, '.ts');
      
      if (this.toolRegistry.hasTool(toolName)) {
        loggingService.info(`Tool '${toolName}' already loaded. Skipping.`, { service: 'ToolWatcher' });
        return;
      }
  
      const toolModule = await import(filePath);
      
      if (toolModule.default && typeof toolModule.default === 'object') {
        const tool = toolModule.default;
        await this.toolRegistry.addTool(toolName, tool.source, tool.schema, tool.tags || [], tool.execute, tool.metadata);
        loggingService.info(`Tool '${toolName}' loaded successfully`, { service: 'ToolWatcher' });
      } else {
        loggingService.error(`Invalid tool format in file: ${filePath}`, { service: 'ToolWatcher' } as any);
      }
    } catch (error) {
      loggingService.error(`Error loading tool from file ${filePath}: ${error.message}`, { service: 'ToolWatcher' } as any);
    }
  }

  public async loadExistingTools() {
    const files = await fs.promises.readdir(this.toolsDir);
    for (const file of files) {
      if (file.endsWith('.ts')) {
        await this.loadTool(path.join(this.toolsDir, file));
      }
    }
  }
}.//tools/__tests__/toolRegistry.test.ts
// toolRegistry.test.ts
import { ToolRegistry } from '../toolRegistry';
import { sampleTool } from './fixtures/sampleTool';
import { MockMetricsService } from './fixtures/mockMetricsService';
import { ConversationService } from '../../conversation/conversationService';
import { Tool } from '../tool';


describe('ToolRegistry', () => {
    let toolRegistry: ToolRegistry;
    let mockMetricsService: MockMetricsService;
    let mockConversationService: jest.Mocked<ConversationService>;

    beforeEach(() => {
        mockMetricsService = new MockMetricsService();
        mockConversationService = {
            chat: jest.fn(),
            setModel: jest.fn(),
        } as any;
        toolRegistry = new ToolRegistry(mockMetricsService as any, mockConversationService);
    });

    describe('addTool', () => {
        it('should add a new tool successfully', async () => {
            const result = await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            expect(result).toBe(true);
            const tool = await toolRegistry.getTool(sampleTool.name);
            expect(tool).toBeDefined();
            expect(tool?.name).toBe(sampleTool.name);
            expect(mockMetricsService.recordToolAddition).toHaveBeenCalledWith(sampleTool.name);
        });

        it('should not add a tool with a duplicate name', async () => {
            await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            const result = await toolRegistry.addTool(
                sampleTool.name,
                'different source',
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            expect(result).toBe(false);
            expect(mockMetricsService.recordToolAddition).toHaveBeenCalledTimes(1);
        });
    });

    describe('updateTool', () => {
        it('should update an existing tool', async () => {
            await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            const newSource = 'console.log("Updated!");';
            const result = await toolRegistry.updateTool(
                sampleTool.name,
                newSource,
                sampleTool.schema,
                sampleTool.tags,
            );
            expect(result).toBe(true);
            const tool = await toolRegistry.getTool(sampleTool.name);
            expect(tool?.source).toBe(newSource);
            expect(mockMetricsService.recordToolUpdate).toHaveBeenCalledWith(sampleTool.name);
        });

        it('should return false for non-existent tool', async () => {
            const result = await toolRegistry.updateTool(
                'nonExistentTool',
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags
            );
            expect(result).toBe(false);
            expect(mockMetricsService.recordToolUpdate).not.toHaveBeenCalled();
        });
    });


    describe('removeTool', () => {
        it('should remove an existing tool', async () => {
            await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            const result = await toolRegistry.removeTool(sampleTool.name);
            expect(result).toBe(true);
            expect(await toolRegistry.getTool(sampleTool.name)).toBeUndefined();
            expect(mockMetricsService.recordToolRemoval).toHaveBeenCalledWith(sampleTool.name);
        });

        it('should return false for non-existent tool', async () => {
            const result = await toolRegistry.removeTool('nonExistentTool');
            expect(result).toBe(false);
            expect(mockMetricsService.recordToolRemoval).not.toHaveBeenCalled();
        });
    });

    describe('getTool', () => {
        it('should return the correct tool by name', async () => {
            await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            const tool = await toolRegistry.getTool(sampleTool.name);
            expect(tool).toBeDefined();
            expect(tool?.name).toBe(sampleTool.name);
            expect(tool?.source).toBe(sampleTool.source);
        });

        it('should return undefined for non-existent tool', async () => {
            const tool = await toolRegistry.getTool('nonExistentTool');
            expect(tool).toBeUndefined();
        });
    });

    describe('callTool', () => {
        it('should execute the tool and return the result', async () => {
            const mockExecute = jest.fn().mockResolvedValue('result');
            await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            const tool = await toolRegistry.getTool(sampleTool.name);
            (tool as any).execute = mockExecute;

            const result = await toolRegistry.callTool(sampleTool.name, { param: 'value' });
            expect(result).toBe('result');
            expect(mockExecute).toHaveBeenCalledWith({ param: 'value' });
            expect(mockMetricsService.recordToolUsage).toHaveBeenCalledWith(sampleTool.name, expect.any(Number), true);
        });

        it('should throw an error for non-existent tool', async () => {
            await expect(toolRegistry.callTool('nonExistentTool', {})).rejects.toThrow('Tool not found');
        });

        it('should record tool usage failure on error', async () => {
            await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            const tool = await toolRegistry.getTool(sampleTool.name);
            (tool as any).execute = jest.fn().mockRejectedValue(new Error('Execution failed'));

            await expect(toolRegistry.callTool(sampleTool.name, {})).rejects.toThrow('Execution failed');
            expect(mockMetricsService.recordToolUsage).toHaveBeenCalledWith(sampleTool.name, expect.any(Number), false);
        });
    });

    describe('getToolList', () => {
        it('should return a list of all tools', async () => {
            await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            await toolRegistry.addTool(
                'anotherTool',
                'console.log("Another tool");',
                { description: 'Another test tool' },
                ['test'],
                console.log
            );
            const tools = await toolRegistry.getToolList();
            expect(tools).toHaveLength(2);
            expect(tools[0]).toBeInstanceOf(Tool);
            expect(tools[1]).toBeInstanceOf(Tool);
            expect(tools.map(t => t.name)).toContain(sampleTool.name);
            expect(tools.map(t => t.name)).toContain('anotherTool');
        });
    });

    describe('improveTools', () => {
        it('should attempt to improve tools that need improvement', async () => {
            const mockImprove = jest.fn().mockResolvedValue('improved source');
            jest.spyOn(toolRegistry as any, 'getImprovedToolSource').mockImplementation(mockImprove);

            await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                ['auto-generated'],
                console.log
            );
            const tool = await toolRegistry.getTool(sampleTool.name);
            (tool as any).needsImprovement = jest.fn().mockReturnValue(true);

            await toolRegistry.improveTools();

            expect(mockImprove).toHaveBeenCalled();
            expect(mockMetricsService.recordToolUpdate).toHaveBeenCalledWith(sampleTool.name);
        });

        it('should not attempt to improve tools that don\'t need improvement', async () => {
            const mockImprove = jest.fn().mockResolvedValue('improved source');
            jest.spyOn(toolRegistry as any, 'getImprovedToolSource').mockImplementation(mockImprove);

            await toolRegistry.addTool(
                sampleTool.name,
                sampleTool.source,
                sampleTool.schema,
                sampleTool.tags,
                console.log
            );
            const tool = await toolRegistry.getTool(sampleTool.name);
            (tool as any).needsImprovement = jest.fn().mockReturnValue(false);

            await toolRegistry.improveTools();

            expect(mockImprove).not.toHaveBeenCalled();
            expect(mockMetricsService.recordToolUpdate).not.toHaveBeenCalled();
        });
    });

    describe('analyzeAndCreateToolFromScript', () => {
        it('should analyze a script and create a new tool if appropriate', async () => {
            const mockAnalyze = jest.fn().mockResolvedValue({
                shouldCreateTool: true,
                name: 'newTool',
                source: 'console.log("New tool");',
                schema: { description: 'A new tool' },
                tags: ['auto-generated']
            });
            jest.spyOn(toolRegistry as any, 'analyzeScript').mockImplementation(mockAnalyze);

            await toolRegistry.analyzeAndCreateToolFromScript('console.log("Test script");', 'newTool', 'A test task');

            expect(mockAnalyze).toHaveBeenCalledWith('console.log("Test script");', 'A test task');
            expect(mockMetricsService.recordToolAddition).toHaveBeenCalledWith('newTool');
        });

        it('should not create a tool if analysis suggests against it', async () => {
            const mockAnalyze = jest.fn().mockResolvedValue({ shouldCreateTool: false });
            jest.spyOn(toolRegistry as any, 'analyzeScript').mockImplementation(mockAnalyze);

            await toolRegistry.analyzeAndCreateToolFromScript('console.log("Test script");', 'Test Task', 'A test task');

            expect(mockAnalyze).toHaveBeenCalledWith('console.log("Test script");', 'A test task');
            expect(mockMetricsService.recordToolAddition).not.toHaveBeenCalled();
        });
    });

    describe('reviewAutoGeneratedTools', () => {
        it('should review and potentially modify auto-generated tools', async () => {
            await toolRegistry.addTool('autoTool', 'console.log("Auto tool");', { description: 'An auto-generated tool' }, ['auto-generated'], console.log);

            mockConversationService.chat.mockResolvedValue({
                content: [{
                    text: JSON.stringify({
                        action: 'modify',
                        reason: 'Improvement needed',
                        modifications: 'console.log("Improved auto tool");'
                    })
                }]
            });

            await toolRegistry.reviewAutoGeneratedTools();

            expect(mockConversationService.chat).toHaveBeenCalled();
            expect(mockMetricsService.recordToolUpdate).toHaveBeenCalledWith('autoTool');

            const updatedTool = await toolRegistry.getTool('autoTool');
            expect(updatedTool?.source).toBe('console.log("Improved auto tool");');
        });

        it('should remove auto-generated tools if review suggests removal', async () => {
            await toolRegistry.addTool('autoTool', 'console.log("Auto tool");', { description: 'An auto-generated tool' }, ['auto-generated'], console.log);

            mockConversationService.chat.mockResolvedValue({
                content: [{
                    text: JSON.stringify({
                        action: 'remove',
                        reason: 'Not useful'
                    })
                }]
            });

            await toolRegistry.reviewAutoGeneratedTools();

            expect(mockConversationService.chat).toHaveBeenCalled();
            expect(mockMetricsService.recordToolRemoval).toHaveBeenCalledWith('autoTool');

            const removedTool = await toolRegistry.getTool('autoTool');
            expect(removedTool).toBeUndefined();
        });
    });

    describe('initialize', () => {
        it('should initialize scriptManager and toolWatcher', async () => {
            const mockScriptManagerInitialize = jest.spyOn(toolRegistry['scriptManager'], 'initialize').mockResolvedValue();
            const mockToolWatcherInitialize = jest.spyOn(toolRegistry['toolWatcher'], 'initialize').mockResolvedValue();

            await toolRegistry.initialize();

            expect(mockScriptManagerInitialize).toHaveBeenCalled();
            expect(mockToolWatcherInitialize).toHaveBeenCalled();
        });
    });

    describe('installPackage', () => {
        it('should simulate package installation', async () => {
            const consoleSpy = jest.spyOn(console, 'log');
            await toolRegistry.installPackage('test-package');
            expect(consoleSpy).toHaveBeenCalledWith('Package installed: test-package');
        });
    });

    describe('installPackages', () => {
        it('should install multiple packages', async () => {
            const installPackageSpy = jest.spyOn(toolRegistry, 'installPackage').mockResolvedValue();
            await toolRegistry.installPackages(['package1', 'package2']);
            expect(installPackageSpy).toHaveBeenCalledTimes(2);
            expect(installPackageSpy).toHaveBeenCalledWith('package1');
            expect(installPackageSpy).toHaveBeenCalledWith('package2');
        });
    });

    describe('createTools', () => {
        it('should create multiple tools', async () => {
            const addToolSpy = jest.spyOn(toolRegistry, 'addTool').mockResolvedValue(true);
            const tools = [
                { name: 'tool1', source: 'source1', schema: {}, tags: [] },
                { name: 'tool2', source: 'source2', schema: {}, tags: [] }
            ];
            await toolRegistry.createTools(tools);
            expect(addToolSpy).toHaveBeenCalledTimes(2);
            expect(addToolSpy).toHaveBeenCalledWith('tool1', 'source1', {}, []);
            expect(addToolSpy).toHaveBeenCalledWith('tool2', 'source2', {}, []);
        });
    });

    describe('predictLikelyTools', () => {
        it('should predict likely tools for a given input', async () => {
            const mockResponse = [
                { tool: 'tool1', justification: 'reason1' },
                { tool: 'tool2', justification: 'reason2' }
            ];
            mockConversationService.chat.mockResolvedValue({ content: [{ text: JSON.stringify(mockResponse) }] });

            const result = await toolRegistry.predictLikelyTools({ task: 'test task' });

            expect(result).toEqual(mockResponse);
            expect(mockConversationService.chat).toHaveBeenCalled();
        });
    });

    describe('analyzeScript', () => {
        it('should analyze a script and suggest tool creation', async () => {
            const mockAnalysis = {
                shouldCreateTool: true,
                name: 'newTool',
                source: 'console.log("New tool");',
                schema: {},
                tags: ['auto-generated']
            };
            jest.spyOn(toolRegistry as any, 'analyzeScript').mockResolvedValue(mockAnalysis);

            const result = await (toolRegistry as any).analyzeScript('console.log("Test script");', 'Test description');

            expect(result).toEqual(mockAnalysis);
        });
    });

    describe('getMetrics', () => {
        it('should return metrics for a specific tool', () => {
            const mockMetrics = { usageCount: 5, averageExecutionTime: 100 };
            mockMetricsService.getToolMetrics.mockReturnValue(mockMetrics);

            const result = toolRegistry.getMetrics('testTool');

            expect(result).toEqual(mockMetrics);
            expect(mockMetricsService.getToolMetrics).toHaveBeenCalledWith('testTool');
        });
    });

    describe('getAllMetrics', () => {
        it('should return metrics for all tools', () => {
            const mockAllMetrics = new Map([
                ['tool1', { usageCount: 5, averageExecutionTime: 100 }],
                ['tool2', { usageCount: 3, averageExecutionTime: 150 }]
            ]);
            mockMetricsService.getAllMetrics.mockReturnValue(mockAllMetrics);

            const result = toolRegistry.getAllMetrics();

            expect(result).toEqual(mockAllMetrics);
            expect(mockMetricsService.getAllMetrics).toHaveBeenCalled();
        });
    });

    describe('getCompactRepresentation', () => {
        it('should return a compact representation of all tools', async () => {
            await toolRegistry.addTool('tool1', 'source1', { description: 'desc1' }, [], console.log);
            await toolRegistry.addTool('tool2', 'source2', { description: 'desc2' }, [], console.log);

            const result = toolRegistry.getCompactRepresentation();

            expect(result).toBe('tool1: desc1\ntool2: desc2');
        });
    });
});
.//tools/__tests__/toolWatcher.test.ts
import { ToolWatcher } from '../toolWatcher';
import { ToolRegistry } from '../toolRegistry';
import { MetricsService } from '../../metrics/metricsService';
import { ConversationService } from '../../conversation/conversationService';
import * as fs from 'fs';
import * as path from 'path';
import * as chokidar from 'chokidar';

jest.mock('../toolRegistry');
jest.mock('../../metrics/metricsService');
jest.mock('../../conversation/conversationService');
jest.mock('path');
jest.mock('chokidar');

jest.mock('fs', () => ({
  promises: {
    readdir: jest.fn(),
  },
  existsSync: jest.fn(),
}));

describe('ToolWatcher', () => {
  let toolWatcher: ToolWatcher;
  let mockToolRegistry: jest.Mocked<ToolRegistry>;
  let mockMetricsService: jest.Mocked<MetricsService>;
  let mockConversationService: jest.Mocked<ConversationService>;

  beforeEach(() => {
    mockMetricsService = new MetricsService() as jest.Mocked<MetricsService>;
    mockConversationService = new ConversationService() as jest.Mocked<ConversationService>;
    mockToolRegistry = new ToolRegistry(mockMetricsService, mockConversationService) as jest.Mocked<ToolRegistry>;
    
    // Mock path.join to return a fixed path
    (path.join as jest.Mock).mockReturnValue('/mock/tools/dir');
    
    // Mock fs.existsSync to return true
    (fs.existsSync as jest.Mock).mockReturnValue(true);
    
    // Mock chokidar.watch to return a mock watcher
    (chokidar.watch as jest.Mock).mockReturnValue({
      on: jest.fn().mockReturnThis(),
    });

    toolWatcher = new ToolWatcher(mockToolRegistry);
  });

  it('should initialize and load existing tools', async () => {
    const mockReaddir = jest.spyOn(fs.promises, 'readdir').mockResolvedValue(['tool1.ts', 'tool2.ts'] as any);
    const mockLoadTool = jest.spyOn(toolWatcher as any, 'loadTool').mockResolvedValue(undefined);

    await toolWatcher.initialize();

    expect(mockReaddir).toHaveBeenCalledWith('/mock/tools/dir');
    expect(mockLoadTool).toHaveBeenCalledTimes(2);
    expect(mockLoadTool).toHaveBeenCalledWith('/mock/tools/dir/tool1.ts');
    expect(mockLoadTool).toHaveBeenCalledWith('/mock/tools/dir/tool2.ts');
  });

  it('should handle new file', async () => {
    const mockLoadTool = jest.spyOn(toolWatcher as any, 'loadTool').mockResolvedValue(undefined);
    
    await (toolWatcher as any).handleNewFile('/path/to/newTool.ts');

    expect(mockLoadTool).toHaveBeenCalledWith('/path/to/newTool.ts');
  });

  it('should handle file change', async () => {
    const mockLoadTool = jest.spyOn(toolWatcher as any, 'loadTool').mockResolvedValue(undefined);
    
    await (toolWatcher as any).handleFileChange('/path/to/changedTool.ts');

    expect(mockLoadTool).toHaveBeenCalledWith('/path/to/changedTool.ts');
  });

  it('should handle file removal', async () => {
    await (toolWatcher as any).handleFileRemoval('/path/to/removedTool.ts');

    expect(mockToolRegistry.removeTool).toHaveBeenCalledWith('removedTool');
  });

  it('should load a tool', async () => {
    const mockToolModule = {
      default: {
        name: 'testTool',
        execute: jest.fn(),
        schema: {},
        tags: []
      }
    };
    jest.mock('/path/to/testTool.ts', () => mockToolModule, { virtual: true });

    await (toolWatcher as any).loadTool('/path/to/testTool.ts');

    expect(mockToolRegistry.addTool).toHaveBeenCalledWith(
      "testTool",
      expect.any(Function),
      mockToolModule.default.schema,
      mockToolModule.default.tags || []
    );
  });
});.//tools/__tests__/fixtures/mockMetricsService.ts
export class MockMetricsService {
    recordToolAddition = jest.fn();
    recordToolUpdate = jest.fn();
    recordToolRemoval = jest.fn();
    recordToolUsage = jest.fn();
    getToolMetrics = jest.fn();
    getAllMetrics = jest.fn();
  }.//tools/__tests__/fixtures/sampleTool.ts
export const sampleTool = {
    name: 'sampleTool',
    source: 'console.log("Hello, World!");',
    schema: { description: 'A sample tool for testing' },
    tags: ['test'],
  };.//memory/memoryService.ts
// memoryService.ts
import { ChromaClient, Collection } from 'chromadb';
import { ConfidenceCalculator } from './confidence';
import { MemoryPruner } from './pruner';
import { MemoryConsolidator } from './consolidator';
import { MemoryRefiner } from './refiner';
import { MemoryStore } from './store';

export interface Memory {
  input: string;
  response: string;
  confidence: number;
}

export class MemoryService {
  private collection: Collection;
  private confidenceCalculator: ConfidenceCalculator;
  private memoryPruner: MemoryPruner;
  private memoryConsolidator: MemoryConsolidator;
  private memoryRefiner: MemoryRefiner;
  private memoryStore: MemoryStore;

  constructor(private chromaClient: ChromaClient) {
    this.initializeCollection();
    this.confidenceCalculator = new ConfidenceCalculator();
    this.memoryPruner = new MemoryPruner();
    this.memoryConsolidator = new MemoryConsolidator(chromaClient);
    this.memoryRefiner = new MemoryRefiner();
    this.memoryStore = new MemoryStore(chromaClient);
  }

  private async initializeCollection() {
    this.collection = await this.chromaClient.getOrCreateCollection({
      name: "agent_memories",
      metadata: { "hnsw:space": "cosine" }
    });
  }

  async storeMemory(input: string, response: string, confidence: number): Promise<void> {
    const id = this.generateId();
    await this.collection.add({
      ids: [id],
      documents: [response],
      metadatas: [{ input, confidence }],
    });
    await this.memoryStore.storeMemory( input, response, confidence );
  }

  async findSimilarMemories(input: string, threshold: number = 0.7): Promise<any> {
    await this.initializeCollection();
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 5,
    });

    return results.metadatas[0].map((metadata, index) => ({
      input: (metadata && metadata.input) || '',
      response: (results && results.documents && results.documents[0][index] ) || '',
      confidence: (metadata && metadata.input),
      similarity: results.distances && results.distances.length > 0 ? 1 - results.distances[0][index] : 0,
    })).filter(memory => memory.similarity > threshold) as any;
  }

  async updateMemory(input: string, response: string, newConfidence: number): Promise<void> {
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 1,
    });

    if (results.ids[0] && results.ids[0][0]) {
      const id = results.ids[0][0];
      await this.collection.update({
        ids: [id],
        documents: [response],
        metadatas: [{ input, confidence: newConfidence }],
      });
    }
  }

  async listMemories(): Promise<any[]> {
    const results = await this.collection.get();
    return results.metadatas.map((metadata, index) => (metadata ? {
      input: metadata.input,
      response: results.documents[index],
      confidence: metadata.confidence,
    } : null));
  }

  async removeMemory(input: string): Promise<void> {
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 1,
    });

    if (results.ids[0] && results.ids[0][0]) {
      const id = results.ids[0][0];
      await this.collection.delete({ ids: [id] });
    }
  }

  async pruneMemories(): Promise<void> {
    await this.memoryPruner.pruneMemories(this.memoryStore);
  }

  async consolidateMemories(): Promise<void> {
    await this.memoryConsolidator.consolidateMemories(this.memoryStore);
  }

  async refineMemories(model: string = 'claude'): Promise<void> {
    await this.memoryRefiner.refineMemories(this.memoryStore, model);
  }

  calculateInitialConfidence(chromaConfidence: number, response: string): number {
    return this.confidenceCalculator.calculateInitialConfidence(chromaConfidence, response);
  }

  calculateRetrievalConfidence(storedConfidence: number, chromaConfidence: number): number {
    return this.confidenceCalculator.calculateRetrievalConfidence(storedConfidence, chromaConfidence);
  }

  updateConfidence(oldConfidence: number, chromaConfidence: number): number {
    return this.confidenceCalculator.updateConfidence(oldConfidence, chromaConfidence);
  }

  private generateId(): string {
    return Math.random().toString(36).substring(2, 15);
  }
}.//memory/pruner.ts
import { MemoryStore, Memory } from './store';

export class MemoryPruner {
  async pruneMemories(memoryStore: MemoryStore): Promise<void> {
    const memories = await memoryStore.listMemories();
    const memoriesToPrune = this.identifyMemoriesToPrune(memories);
    await this.removeMemories(memoryStore, memoriesToPrune);
  }

  private identifyMemoriesToPrune(memories: Memory[]): string[] {
    const LOW_CONFIDENCE_THRESHOLD = 0.3;
    const MAX_MEMORIES = 1000; // Arbitrary limit

    let memoriesToPrune: string[] = [];

    // Prune low confidence memories
    memoriesToPrune = memoriesToPrune.concat(
      memories
        .filter(memory => memory.confidence < LOW_CONFIDENCE_THRESHOLD)
        .map(memory => memory.input)
    );

    // If we're still over the limit, remove oldest memories
    if (memories.length - memoriesToPrune.length > MAX_MEMORIES) {
      const sortedMemories = memories.sort((a, b) => b.confidence - a.confidence);
      memoriesToPrune = memoriesToPrune.concat(
        sortedMemories
          .slice(MAX_MEMORIES)
          .map(memory => memory.input)
      );
    }

    return memoriesToPrune;
  }

  private async removeMemories(memoryStore: MemoryStore, memoryInputs: string[]): Promise<void> {
    for (const input of memoryInputs) {
      // Assuming MemoryStore has a removeMemory method
      await memoryStore.removeMemory(input);
    }
  }
}.//memory/confidence.ts
export class ConfidenceCalculator {
  calculateInitialConfidence(chromaConfidence: number, response: string): number {
    const lengthScore = this.calculateLengthScore(response);
    const complexityScore = this.calculateComplexityScore(response);

    // Weighted average of factors
    const confidence = (
      chromaConfidence * 0.6 +
      lengthScore * 0.2 +
      complexityScore * 0.2
    );

    return Math.min(Math.max(confidence, 0), 1); // Ensure confidence is between 0 and 1
  }

  calculateRetrievalConfidence(storedConfidence: number, chromaConfidence: number): number {
    // Combine stored confidence with Chroma's similarity score
    const combinedConfidence = (storedConfidence + chromaConfidence) / 2;
    return Math.min(Math.max(combinedConfidence, 0), 1);
  }

  updateConfidence(oldConfidence: number, chromaConfidence: number): number {
    // Exponential moving average to smooth confidence updates
    const alpha = 0.3; // Smoothing factor
    const updatedConfidence = alpha * chromaConfidence + (1 - alpha) * oldConfidence;

    return Math.min(Math.max(updatedConfidence, 0), 1); // Ensure confidence is between 0 and 1
  }

  private calculateLengthScore(response: string): number {
    const words = this.simpleTokenize(response);
    const optimalLength = 50; // Adjust based on your use case
    const lengthDifference = Math.abs(words.length - optimalLength);
    return Math.exp(-lengthDifference / optimalLength);
  }

  private calculateComplexityScore(response: string): number {
    const words = this.simpleTokenize(response);
    const uniqueWords = new Set(words);
    const lexicalDiversity = uniqueWords.size / words.length;

    // Assuming a good lexical diversity is around 0.6-0.7
    return Math.min(lexicalDiversity / 0.7, 1);
  }

  private simpleTokenize(text: string): string[] {
    // Simple word-splitting function
    return text.toLowerCase().match(/\b(\w+)\b/g) || [];
  }
}.//memory/store.ts
// MemoryStore.ts
import { ChromaClient, Collection } from 'chromadb';

export interface Memory {
  input: string;
  response: string;
  confidence: number;
}

export class MemoryStore {
  private collection: Collection;

  constructor(private chromaClient: ChromaClient) {
    this.initializeCollection();
  }

  private async initializeCollection() {
    this.collection = await this.chromaClient.getOrCreateCollection({
      name: "agent_memories",
      metadata: { "hnsw:space": "cosine" }
    });
  }

  async storeMemory(input: string, response: string, confidence: number): Promise<void> {
    const id = this.generateId();
    await this.collection.add({
      ids: [id],
      documents: [response],
      metadatas: [{ input, confidence }],
    });
  }

  async findSimilarMemories(input: string, threshold: number): Promise<Array<Memory & { similarity: number }>> {
    await this.initializeCollection();
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 5,
    });

    return results.metadatas[0].map((metadata, index) => (metadata && results.distances ? {
      input: metadata.input,
      response: results.documents[0][index],
      confidence: metadata.confidence,
      similarity: 1 - (results.distances[0][index] || 0)
    } : null)).filter(memory => memory && memory.similarity > threshold) as any;
  }

  async updateMemory(input: string, response: string, newConfidence: number): Promise<void> {
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 1,
    });

    if (results.ids[0] && results.ids[0][0]) {
      const id = results.ids[0][0];
      await this.collection.update({
        ids: [id],
        documents: [response],
        metadatas: [{ input, confidence: newConfidence }],
      });
    }
  }

  async listMemories(): Promise<Memory[]> {
    const results = await this.collection.get();
    return results.metadatas.map((metadata, index) => (metadata && metadata.confidence ? {
      input: metadata.input,
      response: results.documents[index],
      confidence: metadata.confidence,
    } : null) as any).filter(memory => memory) as Memory[];
  }

  async removeMemory(input: string): Promise<void> {
    const results = await this.collection.query({
      queryTexts: [input],
      nResults: 1,
    });

    if (results.ids[0] && results.ids[0][0]) {
      const id = results.ids[0][0];
      await this.collection.delete({ ids: [id] });
    }
  }

  private generateId(): string {
    return Math.random().toString(36).substring(2, 15);
  }
}.//memory/consolidator.ts
import { MemoryStore, Memory } from './store';
import { ChromaClient } from 'chromadb';
import { ConfidenceCalculator } from './confidence';
import natural from 'natural';

export class MemoryConsolidator {
  private chromaClient: ChromaClient;
  private confidenceCalculator: ConfidenceCalculator;
  private tfidf: natural.TfIdf;

  constructor(chromaClient: ChromaClient) {
    this.chromaClient = chromaClient;
    this.confidenceCalculator = new ConfidenceCalculator();
    this.tfidf = new natural.TfIdf();
  }

  async consolidateMemories(memoryStore: MemoryStore): Promise<void> {
    const memories = await memoryStore.listMemories();
    this.buildTfidfModel(memories);
    const clusters = await this.clusterSimilarMemories(memories);
    
    for (const cluster of clusters) {
      if (cluster.length > 1) {
        const consolidatedMemory = await this.mergeMemories(cluster);
        await this.updateConsolidatedMemory(memoryStore, consolidatedMemory, cluster);
      }
    }
  }

  private buildTfidfModel(memories: Memory[]): void {
    memories.forEach(memory => {
      this.tfidf.addDocument(memory.input + ' ' + memory.response);
    });
  }

  private async clusterSimilarMemories(memories: Memory[]): Promise<Memory[][]> {
    const SIMILARITY_THRESHOLD = 0.8;
    const clusters: Memory[][] = [];
    const embeddingCache: { [key: string]: number[] } = {};

    for (const memory of memories) {
      let added = false;
      const memoryEmbedding = await this.getEmbedding(memory.input + ' ' + memory.response, embeddingCache);

      for (const cluster of clusters) {
        const clusterEmbedding = await this.getEmbedding(
          cluster[0].input + ' ' + cluster[0].response,
          embeddingCache
        );
        
        if (this.cosineSimilarity(memoryEmbedding, clusterEmbedding) > SIMILARITY_THRESHOLD) {
          cluster.push(memory);
          added = true;
          break;
        }
      }

      if (!added) {
        clusters.push([memory]);
      }
    }

    return clusters;
  }

  private async getEmbedding(text: string, cache: { [key: string]: number[] }): Promise<number[]> {
    if (!cache[text]) {
     const coll = await this.chromaClient.getOrCreateCollection({
      name: "agent_memories",
      metadata: { "hnsw:space": "cosine" }
     });
     cache[text] = coll.embeddingFunction && (await coll.embeddingFunction.generate([text]))[0] || [];
    }
    return cache[text];
  }

  private cosineSimilarity(vec1: number[], vec2: number[]): number {
    const dotProduct = vec1.reduce((sum, val, i) => sum + val * vec2[i], 0);
    const mag1 = Math.sqrt(vec1.reduce((sum, val) => sum + val * val, 0));
    const mag2 = Math.sqrt(vec2.reduce((sum, val) => sum + val * val, 0));
    return dotProduct / (mag1 * mag2);
  }

  private async mergeMemories(cluster: Memory[]): Promise<Memory> {
    const combinedInput = this.combineTexts(cluster.map(m => m.input));
    const combinedResponse = this.combineTexts(cluster.map(m => m.response));
    
    const newConfidence = await this.calculateMergedConfidence(cluster, combinedInput, combinedResponse);

    return {
      input: combinedInput,
      response: combinedResponse,
      confidence: newConfidence,
    };
  }

  private combineTexts(texts: string[]): string {
    const sentences = texts.flatMap(text => text.split(/[.!?]+/).filter(s => s.trim().length > 0));
    const uniqueSentences = Array.from(new Set(sentences));
    
    uniqueSentences.sort((a, b) => {
      const scoreA = this.tfidf.tfidf(a.split(' '), 0);
      const scoreB = this.tfidf.tfidf(b.split(' '), 0);
      return scoreB - scoreA;
    });

    return uniqueSentences.join('. ') + '.';
  }

  private async calculateMergedConfidence(cluster: Memory[], combinedInput: string, combinedResponse: string): Promise<number> {
    const individualConfidences = cluster.map(m => m.confidence);
    const averageConfidence = individualConfidences.reduce((sum, conf) => sum + conf, 0) / cluster.length;
    
    const newInitialConfidence = await this.confidenceCalculator.calculateInitialConfidence(1.0, combinedResponse);
    
    return (averageConfidence + newInitialConfidence) / 2;
  }

  private async updateConsolidatedMemory(
    memoryStore: MemoryStore,
    consolidatedMemory: Memory,
    originalMemories: Memory[]
  ): Promise<void> {
    await memoryStore.storeMemory(
      consolidatedMemory.input,
      consolidatedMemory.response,
      consolidatedMemory.confidence
    );

    for (const memory of originalMemories) {
      await memoryStore.removeMemory(memory.input);
    }
  }
}.//memory/refiner.ts
import { MemoryStore, Memory } from './store';
import { ConfidenceCalculator } from './confidence';
import Conversation from '../conversation/conversation';

export class MemoryRefiner {
  private confidenceCalculator: ConfidenceCalculator;

  constructor() {
    this.confidenceCalculator = new ConfidenceCalculator();
  }

  async refineMemories(memoryStore: MemoryStore, model: string = 'claude'): Promise<void> {
    const memories = await memoryStore.listMemories();
    for (const memory of memories) {
      if (memory.confidence < 0.8) {
        const refinedResponse = await this.getRefinedResponse(memory.input, memory.response, model);
        const newConfidence = this.confidenceCalculator.updateConfidence(
          memory.confidence,
          memory.confidence // TODO: replace with Chroma's similarity score
        );
      await memoryStore.updateMemory(memory.input, refinedResponse, newConfidence);
    }
  }
}

// TODO: not gonna work, becuse it has no context of the conversation
private async getRefinedResponse(input: string, previousResponse: string, model: string): Promise<string> {
  const convo = new Conversation(model);
  const prompt = `Given the following input and previous response, please provide an improved response:
  
Input: ${input}

Previous Response: ${previousResponse}

Improved Response:`;

  const response = await convo.chat([
    { role: 'system', content: 'You are an AI assistant tasked with improving responses.' },
    { role: 'user', content: prompt }
  ]);

  return response.content[0].text;
}
}.//main.ts
// main.ts
import { AgentService } from './agentService';
import { ToolRegistry } from './tools/toolRegistry';
import { MemoryService } from './memory/memoryService';
import { ErrorHandlingService } from './logging/errorHandlingService';
import { PromptService } from './prompts/promptService';
import { ConversationService } from './conversation/conversationService';
import { MetricsService } from './metrics/metricsService';
import { ChromaClient } from 'chromadb';
import { MaintenanceManager } from './maintenance';
import { loggingService } from './logging/logger';
import { EnhancedUI } from './terminal/ui';

class Application {
  private agentService: AgentService;
  private maintenanceManager: MaintenanceManager;
  private metricsService: MetricsService;
  private ui: EnhancedUI;

  constructor() {
    this.ui = new EnhancedUI();
    const chromaClient = new ChromaClient();
    this.metricsService = new MetricsService();
    const conversationService = new ConversationService('claude');
    const toolRegistry = new ToolRegistry(this.metricsService, conversationService);
    const memoryService = new MemoryService(chromaClient);
    const errorHandlingService = new ErrorHandlingService();
    const promptService = new PromptService(conversationService, toolRegistry);

    this.agentService = new AgentService(
      toolRegistry,
      memoryService,
      errorHandlingService,
      promptService,
      conversationService
    );

    this.maintenanceManager = new MaintenanceManager(
      this.agentService, 
      toolRegistry, 
      memoryService
    );

    this.setupUIEventHandlers();
  }

  private setupUIEventHandlers(): void {
    this.ui.on('command', async (command: string) => {
      if (command.toLowerCase() === 'exit') {
        this.ui.close();
        return;
      }
      try {
        const result = await this.processUserInput(command);
        if (result !== undefined) {
          this.ui.updateOutput(JSON.stringify(result, null, 2), 'info');
        } else {
          this.ui.updateOutput('Command processed successfully, but no output was returned.', 'info');
        }
      } catch (error) {
        this.ui.updateOutput(`Error: ${error.message}`, 'error');
      }
    });
  }

  async initialize(): Promise<void> {
    loggingService.info('Initializing application...');
    await this.agentService.initialize();
    this.setupMaintenanceSchedule();
    loggingService.info('Application initialized successfully.');
    this.ui.displayWelcomeMessage();
  }

  private setupMaintenanceSchedule(): void {
    loggingService.debug('Setting up maintenance schedule...');
    setInterval(() => {
      this.maintenanceManager.performMaintenance().catch(error => {
        loggingService.error('Error during maintenance', error);
      });
    }, 24 * 60 * 60 * 1000);
    loggingService.debug('Maintenance schedule set up.');
  }

  async getMetricsReport(): Promise<string> {
    loggingService.debug('Generating metrics report...');
    return this.metricsService.generateReport();
  }

  async processUserInput(input: string): Promise<any> {
    try {
      loggingService.info(`Processing user input: ${input}`);
      return await this.agentService.processCommand(input);
    } catch (error) {
      loggingService.error('Error processing user input', error);
      throw error;
    }
  }

  async getCommandHistory(): Promise<string[]> {
    loggingService.debug('Retrieving command history...');
    return this.agentService.getCommandHistory();
  }

  async getToolMetrics(toolName: string): Promise<any> {
    loggingService.debug(`Retrieving metrics for tool: ${toolName}`);
    return await this.agentService.getToolMetrics(toolName);
  }

  async getAllToolMetrics(): Promise<Map<string, any>> {
    loggingService.debug('Retrieving all tool metrics...');
    return await this.agentService.getAllToolMetrics();
  }

  async getToolMetadata(toolName: string): Promise<any> {
    loggingService.debug(`Retrieving metadata for tool: ${toolName}`);
    return await this.agentService.getToolMetadata(toolName);
  }
}

// Usage
const app = new Application();
app.initialize().then(async () => {
  loggingService.info('Application started.');
}).catch(error => {
  loggingService.error('Failed to initialize application', error);
  process.exit(1);
});.//agentService.ts
// agentService.ts
import { ToolRegistry } from './tools/toolRegistry';
import { MemoryService } from './memory/memoryService';
import { ErrorHandlingService } from './logging/errorHandlingService';
import { PromptService } from './prompts/promptService';
import { ConversationService } from './conversation/conversationService';
import { HistoryService } from './history/historyService';
import { ScriptMetadata } from './script/metadataManager';
import { EventEmitter } from 'eventemitter3';

export class AgentService extends EventEmitter {
  private historyService: HistoryService = new HistoryService();

  constructor(
    private toolRegistry: ToolRegistry,
    private memoryService: MemoryService,
    private errorHandlingService: ErrorHandlingService,
    private promptService: PromptService,
    private conversationService: ConversationService
  ) {
    super();
  }

  async initialize(): Promise<void> {
    await this.toolRegistry.initialize();
  }

  async processCommand(command: string): Promise<any> {
    try {
      // Step 1: Save to history
      this.historyService.saveToHistory(command);

      // Step 2: Analyze request prompt
      const {
        existingTools,
        newTools,
        packages,
        useSingleTool,
        toolName,
        params
      } = await this.promptService.determineTaskTools({
        task: command,
        likelyTools: this.toolRegistry.getCompactRepresentation(),
        relevantMemories: JSON.stringify(await this.memoryService.findSimilarMemories(command))
      });

      // Step 3: Get memory
      const similarMemories = await this.memoryService.findSimilarMemories(command);

      if (useSingleTool) {
        let tool = await this.toolRegistry.getTool(toolName);
        if (!tool) {
          throw new Error(`Tool not found: ${toolName}`);
        }
        let repairedTool, hasRepaired = false;
        return await this.errorHandlingService.withRetry(async (repairedValues: any) => {
          if(repairedValues.repaired) {
            let { reason, name, source } = repairedValues;
            repairedTool = name;
            await this.toolRegistry.updateTool(toolName, source, tool.schema, tool.tags, tool.metadata);
            hasRepaired = true;
          }
          const vv = await this.toolRegistry.callTool(toolName, params);
          return vv
        }, 3, async (error: any) => {
          let ret = await this.promptService.repairFailedScriptExecution({error, chat: command, toolName, params});
          ret = await tool.execute(params);
          return ret;
        });
      } else {
        if (packages || newTools) {
          // Handle package installation and new tool creation
          await this.installPackages(packages);
          await this.createTools(newTools);
          return this.processCommand(command); // Recursive call after setup
        } else {
          // Decompose command into tasks
          const tasks = await this.promptService.generateTasks({
            task: command,
            availableTools: existingTools,
            memories: JSON.stringify(similarMemories)
          });

          // Execute tasks
          const results = await this.executeTasks(tasks);

          // Create and save memory
          const memory = this.createFormattedMemory(command, results, similarMemories);
          await this.memoryService.storeMemory(memory, JSON.stringify(results), 1.0); // Assuming high confidence for now

          return results;
        }
      }
    } catch (error) {
      console.error('Error processing command:', error);
      throw error;
    }
  }

  private async installPackages(packages: string[]): Promise<void> {
    // forward the request to the tool registry
    await this.toolRegistry.installPackages(packages);
  }

  private async createTools(tools: any[]): Promise<void> {
    // forward the request to the tool registry
    await this.toolRegistry.createTools(tools);
  }  

  private async executeTasks(tasks: any[], maxRetries: number = 3): Promise<any[]> {
    const results: any[] = [];
    let toolName = '', sourceCode = '', tool;
    for (let { task, source, chat, params } of tasks) {
      const [taskName] = toolName ? [toolName + ':' + 'Automatically fixing issue'] : task.split(':');
      sourceCode = source;
      const taskResult = await this.errorHandlingService.withRetry(async (repairedValues: any) => {
        if(repairedValues) {
          const { repaired, reason, name, source } = repairedValues;
          this.emit('chat', `Tool '${name}' repaired. Reason: ${reason}`);
          if(repaired) {
            toolName = name;
            sourceCode = source;
            await this.toolRegistry.addTool(toolName, source, tool.schema, tool.tags, tool.metadata);
          }
        }
        tool = await this.toolRegistry.getTool(taskName);
        if (!tool) {
          throw new Error(`Tool not found: ${taskName}`);
        }
        return await tool.execute(params);
      }, maxRetries, async (error: any) => {
        return await this.promptService.repairFailedScriptExecution({error, chat, source: sourceCode, task});
      });
      results.push(taskResult);
    }
    return results;
  }

  private createFormattedMemory(command: string, results: any[], similarMemories: any[]): any {
    // Implement memory formatting logic here
    // This could involve combining the command, results, and similar memories
    // into a structured format for storage
    return {
      command,
      results,
      relatedMemories: similarMemories
    };
  }

  async improveTools(): Promise<void> {
    await this.toolRegistry.improveTools();
  }

  async analyzeAndCreateToolFromScript(script: string, taskName: string, taskDescription: string): Promise<void> {
    await this.toolRegistry.analyzeAndCreateToolFromScript(script, taskName, taskDescription);
  }

  async performMaintenance(): Promise<void> {
    await this.memoryService.pruneMemories();
    await this.memoryService.consolidateMemories();
    await this.memoryService.refineMemories();
    await this.toolRegistry.cleanupUnusedScripts();
  }

  async getToolMetrics(toolName: string): Promise<any> {
    return this.toolRegistry.getMetrics(toolName);
  }

  async getAllToolMetrics(): Promise<Map<string, any>> {
    return this.toolRegistry.getAllMetrics();
  }

  async getToolMetadata(toolName: string): Promise<ScriptMetadata | null> {
    return this.toolRegistry.getMetadata(toolName);
  }

  async updateToolMetadata(toolName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    await this.toolRegistry.updateMetadata(toolName, metadata);
  }

  async getCommandHistory(): Promise<string[]> {
    return this.historyService.getHistory();
  }

}.//sandboxedExecutionEnvironment.ts
// sandboxedExecutionEnvironment.ts

import { NodeVM } from 'vm2';
import fs from 'fs-extra';
import path from 'path';
import { EventEmitter } from 'events';
import { performance } from 'perf_hooks';
import * as v8 from 'v8';
import crypto from 'crypto';

class SandboxError extends Error {
  constructor(message: string, public readonly code: string) {
    super(message);
    this.name = 'SandboxError';
  }
}

interface SandboxOptions {
  sandboxDir: string;
  maxFileSize?: number;
  maxTotalStorage?: number;
  allowedFileExtensions?: string[];
  maxConcurrentOperations?: number;
  maxMemoryUsage?: number;
  maxCpuTime?: number;
  allowedModules?: string[];
}

export class SandboxedExecutionEnvironment extends EventEmitter {
  private readonly sandboxDir: string;
  private readonly maxFileSize: number;
  private readonly maxTotalStorage: number;
  private readonly allowedFileExtensions: string[];
  private readonly maxConcurrentOperations: number;
  private readonly maxMemoryUsage: number;
  private readonly maxCpuTime: number;
  private readonly allowedModules: string[];
  private currentOperations: number = 0;

  constructor(options: SandboxOptions) {
    super();
    this.validateOptions(options);
    this.sandboxDir = options.sandboxDir;
    this.maxFileSize = options.maxFileSize || 1024 * 1024; // 1MB default
    this.maxTotalStorage = options.maxTotalStorage || 10 * 1024 * 1024; // 10MB default
    this.allowedFileExtensions = options.allowedFileExtensions || ['.txt', '.json', '.csv'];
    this.maxConcurrentOperations = options.maxConcurrentOperations || 5;
    this.maxMemoryUsage = options.maxMemoryUsage || 100 * 1024 * 1024; // 100MB default
    this.maxCpuTime = options.maxCpuTime || 1000; // 1 second default
    this.allowedModules = options.allowedModules || [];
    fs.ensureDirSync(this.sandboxDir);
  }

  private validateOptions(options: SandboxOptions): void {
    if (!options.sandboxDir) {
      throw new SandboxError('Sandbox directory must be specified', 'INVALID_CONFIG');
    }
    if (options.maxFileSize && options.maxFileSize <= 0) {
      throw new SandboxError('Max file size must be positive', 'INVALID_CONFIG');
    }
    if (options.maxTotalStorage && options.maxTotalStorage <= 0) {
      throw new SandboxError('Max total storage must be positive', 'INVALID_CONFIG');
    }
    if (options.maxConcurrentOperations && options.maxConcurrentOperations <= 0) {
      throw new SandboxError('Max concurrent operations must be positive', 'INVALID_CONFIG');
    }
    if (options.maxMemoryUsage && options.maxMemoryUsage <= 0) {
      throw new SandboxError('Max memory usage must be positive', 'INVALID_CONFIG');
    }
    if (options.maxCpuTime && options.maxCpuTime <= 0) {
      throw new SandboxError('Max CPU time must be positive', 'INVALID_CONFIG');
    }
  }

  

  async execute(code: string, context: any = {}, timeout: number = 5000): Promise<any> {
    const vm = new NodeVM({
      timeout,
      sandbox: {
        ...context,
        saveFile: this.wrapAsyncOperation(this.saveFile.bind(this)),
        readFile: this.wrapAsyncOperation(this.readFile.bind(this)),
        listFiles: this.wrapAsyncOperation(this.listFiles.bind(this)),
        deleteFile: this.wrapAsyncOperation(this.deleteFile.bind(this)),
        console: {
          log: (...args: any[]) => this.emit('log', 'info', ...args),
          error: (...args: any[]) => this.emit('log', 'error', ...args),
        },
      },
      require: {
        external: true,
        builtin: this.allowedModules,
        root: this.sandboxDir,
      },
      nesting: false,
      wrapper: 'none',
    });

    const wrappedCode = `
      const memoryUsage = process.memoryUsage();
      if (memoryUsage.heapUsed > ${this.maxMemoryUsage}) {
        throw new Error('Memory limit exceeded');
      }
      ${code}
    `;

    const start = performance.now();
    try {
      const result = await vm.run(wrappedCode, this.sandboxDir);
      const end = performance.now();
      const executionTime = end - start;
      
      if (executionTime > this.maxCpuTime) {
        throw new SandboxError('CPU time limit exceeded', 'CPU_LIMIT_EXCEEDED');
      }

      this.emit('executionComplete', { success: true, executionTime });
      return result;
    } catch (error) {
      this.emit('executionComplete', { success: false, error: error.message });
      throw new SandboxError(`Sandbox execution failed: ${error.message}`, 'EXECUTION_FAILED');
    }
  }

  private wrapAsyncOperation<T>(operation: (...args: any[]) => Promise<T>): (...args: any[]) => Promise<T> {
    return async (...args: any[]) => {
      if (this.currentOperations >= this.maxConcurrentOperations) {
        throw new SandboxError('Too many concurrent file operations', 'CONCURRENT_OPERATIONS_LIMIT');
      }
      this.currentOperations++;
      try {
        return await operation(...args);
      } finally {
        this.currentOperations--;
      }
    };
  }

  private async saveFile(fileName: string, content: string): Promise<void> {
    this.validateFileName(fileName);
    const filePath = path.join(this.sandboxDir, fileName);
    
    if (Buffer.from(content).length > this.maxFileSize) {
      throw new SandboxError(`File size exceeds the maximum allowed size of ${this.maxFileSize} bytes`, 'FILE_SIZE_EXCEEDED');
    }

    const totalSize = await this.getTotalStorageSize();
    if (totalSize + Buffer.from(content).length > this.maxTotalStorage) {
      throw new SandboxError(`Saving this file would exceed the total storage limit of ${this.maxTotalStorage} bytes`, 'TOTAL_STORAGE_EXCEEDED');
    }

    await fs.writeFile(filePath, content, 'utf8');
    this.emit('fileSaved', fileName);
  }

  private async readFile(fileName: string): Promise<string> {
    this.validateFileName(fileName);
    const filePath = path.join(this.sandboxDir, fileName);
    if (!await fs.pathExists(filePath)) {
      throw new SandboxError(`File not found: ${fileName}`, 'FILE_NOT_FOUND');
    }
    const content = await fs.readFile(filePath, 'utf8');
    this.emit('fileRead', fileName);
    return content;
  }

  private async listFiles(): Promise<string[]> {
    const files = await fs.readdir(this.sandboxDir);
    this.emit('filesListed', files.length);
    return files;
  }

  private async deleteFile(fileName: string): Promise<void> {
    this.validateFileName(fileName);
    const filePath = path.join(this.sandboxDir, fileName);
    if (!await fs.pathExists(filePath)) {
      throw new SandboxError(`File not found: ${fileName}`, 'FILE_NOT_FOUND');
    }
    await fs.remove(filePath);
    this.emit('fileDeleted', fileName);
  }

  private validateFileName(fileName: string): void {
    const ext = path.extname(fileName);
    if (!this.allowedFileExtensions.includes(ext)) {
      throw new SandboxError(`File extension '${ext}' is not allowed. Allowed extensions are: ${this.allowedFileExtensions.join(', ')}`, 'INVALID_FILE_EXTENSION');
    }
    
    const sanitizedFileName = path.basename(fileName);
    if (sanitizedFileName !== fileName) {
      throw new SandboxError('Invalid file name. File names cannot contain path traversal characters.', 'INVALID_FILE_NAME');
    }
  }

  private async getTotalStorageSize(): Promise<number> {
    const files = await this.listFiles();
    let totalSize = 0;
    for (const file of files) {
      const stats = await fs.stat(path.join(this.sandboxDir, file));
      totalSize += stats.size;
    }
    return totalSize;
  }

  public async getResourceUsage(): Promise<{ memoryUsage: number, cpuUsage: number }> {
    const memoryUsage = v8.getHeapStatistics().used_heap_size;
    const cpuUsage = process.cpuUsage();
    return { memoryUsage, cpuUsage: cpuUsage.user + cpuUsage.system };
  }

  public async cleanup(): Promise<void> {
    await fs.emptyDir(this.sandboxDir);
    this.emit('sandboxCleaned');
  }

  // Utility method to generate a unique file name
  public generateUniqueFileName(extension: string): string {
    const uniqueId = crypto.randomBytes(16).toString('hex');
    return `${uniqueId}${extension}`;
  }

  // Method to get the full path of a file in the sandbox
  public getFilePath(fileName: string): string {
    return path.join(this.sandboxDir, fileName);
  }

  // Method to check if a file exists in the sandbox
  public async fileExists(fileName: string): Promise<boolean> {
    const filePath = this.getFilePath(fileName);
    return fs.pathExists(filePath);
  }

  // Method to get file stats
  public async getFileStats(fileName: string): Promise<any> {
    const filePath = this.getFilePath(fileName);
    if (!await this.fileExists(fileName)) {
      throw new SandboxError(`File not found: ${fileName}`, 'FILE_NOT_FOUND');
    }
    return fs.stat(filePath);
  }

  // Method to rename a file in the sandbox
  public async renameFile(oldName: string, newName: string): Promise<void> {
    this.validateFileName(oldName);
    this.validateFileName(newName);
    const oldPath = this.getFilePath(oldName);
    const newPath = this.getFilePath(newName);
    if (!await this.fileExists(oldName)) {
      throw new SandboxError(`File not found: ${oldName}`, 'FILE_NOT_FOUND');
    }
    if (await this.fileExists(newName)) {
      throw new SandboxError(`File already exists: ${newName}`, 'FILE_ALREADY_EXISTS');
    }
    await fs.rename(oldPath, newPath);
    this.emit('fileRenamed', { oldName, newName });
  }

  // Method to copy a file in the sandbox
  public async copyFile(sourceName: string, targetName: string): Promise<void> {
    this.validateFileName(sourceName);
    this.validateFileName(targetName);
    const sourcePath = this.getFilePath(sourceName);
    const targetPath = this.getFilePath(targetName);
    if (!await this.fileExists(sourceName)) {
      throw new SandboxError(`Source file not found: ${sourceName}`, 'FILE_NOT_FOUND');
    }
    if (await this.fileExists(targetName)) {
      throw new SandboxError(`Target file already exists: ${targetName}`, 'FILE_ALREADY_EXISTS');
    }
    await fs.copy(sourcePath, targetPath);
    this.emit('fileCopied', { sourceName, targetName });
  }

  // Method to get the size of the sandbox directory
  public async getSandboxSize(): Promise<number> {
    const files = await this.listFiles();
    let totalSize = 0;
    for (const file of files) {
      const stats = await this.getFileStats(file);
      totalSize += stats.size;
    }
    return totalSize;
  }

  // Method to check if the sandbox is within size limits
  public async checkSandboxSize(): Promise<boolean> {
    const currentSize = await this.getSandboxSize();
    return currentSize <= this.maxTotalStorage;
  }

  // Method to get sandbox information
  public getSandboxInfo(): {
    sandboxDir: string;
    maxFileSize: number;
    maxTotalStorage: number;
    allowedFileExtensions: string[];
    maxConcurrentOperations: number;
    maxMemoryUsage: number;
    maxCpuTime: number;
    allowedModules: string[];
  } {
    return {
      sandboxDir: this.sandboxDir,
      maxFileSize: this.maxFileSize,
      maxTotalStorage: this.maxTotalStorage,
      allowedFileExtensions: this.allowedFileExtensions,
      maxConcurrentOperations: this.maxConcurrentOperations,
      maxMemoryUsage: this.maxMemoryUsage,
      maxCpuTime: this.maxCpuTime,
      allowedModules: this.allowedModules,
    };
  }
}.//terminal/uiLogger.ts
// uiLogger.ts
import Transport from 'winston-transport';
import { EnhancedUI } from './ui';

interface UILoggerOptions extends Transport.TransportStreamOptions {
  ui: EnhancedUI;
}

export class UILogger extends Transport {
  private ui: EnhancedUI;

  constructor(options: UILoggerOptions) {
    super(options);
    this.ui = options.ui;
  }

  log(info: any, callback: () => void): void {
    setImmediate(() => {
      this.emit('logged', info);
    });

    this.ui.updateOutput(info.message, info.level);
    callback();
  }
}.//terminal/terminalSession.ts
// terminalSession.ts
import { AgentService } from '../agentService';
import { HistoryService } from '../history/historyService';

export class TerminalSession {
  private historyService: HistoryService;

  constructor(
    public readonly id: string,
    private agentService: AgentService
  ) {
    this.historyService = new HistoryService();
  }

  async execute(command: string): Promise<any> {
    this.historyService.saveToHistory(command);
    return await this.agentService.processCommand(command);
  }

  getHistory(): string[] {
    return this.historyService.getHistory();
  }

  clearHistory(): void {
    this.historyService.clearHistory();
  }

  searchHistory(query: string): string[] {
    return this.historyService.searchHistory(query);
  }

}.//terminal/terminalSessionManager.ts
// terminalSessionManager.ts
import { TerminalSession } from './terminalSession';
import { AgentService } from '../agentService';

export class TerminalSessionManager {
  private sessions: Map<string, TerminalSession> = new Map();

  constructor(private agentService: AgentService) {}

  createSession(id: string): TerminalSession {
    const session = new TerminalSession(id, this.agentService);
    this.sessions.set(id, session);
    return session;
  }

  getSession(id: string): TerminalSession | undefined {
    return this.sessions.get(id);
  }

  removeSession(id: string): boolean {
    return this.sessions.delete(id);
  }

  getAllSessions(): TerminalSession[] {
    return Array.from(this.sessions.values());
  }

  async executeCommandInSession(sessionId: string, command: string): Promise<any> {
    const session = this.getSession(sessionId);
    if (!session) {
      throw new Error(`Session not found: ${sessionId}`);
    }
    return await session.execute(command);
  }
}.//terminal/visualizationApi.ts
import { UI } from "./ui";

export class VisualizationAPI {
    constructor(private ui: UI) {}
  
    createLineChart(title: string, data: {x: number[], y: number[], title: string}) {
      this.ui.createChart('line', title, data);
    }
  
    createBarChart(title: string, data: {titles: string[], data: number[]}) {
      this.ui.createChart('bar', title, data);
    }
  
    createPieChart(title: string, data: {percent: number, label: string}[]) {
      this.ui.createChart('pie', title, data);
    }

}
  .//terminal/ui.ts
// ui.ts
import readline from 'readline';
import chalk from 'chalk';
import { loggingService } from '../logging/logger';
import { UILogger } from './uiLogger';
import { loggingConfig } from '../logging/config';
import EventEmitter from 'eventemitter3';

export class EnhancedUI extends EventEmitter {
  private uiLogger: UILogger;
  private logColors: { [key: string]: string } = {
    error: 'red',
    warn: 'yellow',
    info: 'green',
    debug: 'blue',
    verbose: 'cyan'
  };
  private rl: readline.Interface;
  private levels: string[] = [ 'error', 'warn', 'info', 'debug', 'verbose' ];
  private level: string = 'info';

  constructor() {
    super();
    this.setOutputLevel('info');

    this.uiLogger = new UILogger({
      ui: this,
      level: loggingConfig.ui.level
    });
    loggingService.addTransport(this.uiLogger);

    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: chalk.cyan('AI> ')
    });

    this.setupReadlineInterface();
    this.setupKeyPressHandler();
  }

  private setupKeyPressHandler(): void {
    readline.emitKeypressEvents(process.stdin);
    if (process.stdin.isTTY) {
      process.stdin.setRawMode(true);
    }

    process.stdin.on('keypress', (str, key) => {
      if (key.ctrl || key.meta) {
        const num = parseInt(str);
        if (!isNaN(num) && num >= 0 && num <= 4) {
          this.emit('logLevelChange', this.levels[num]);
        }
      }
    });
  }
  
  private setupReadlineInterface(): void {
    this.rl.on('line', (line) => {
      line = line.trim();
      if (line) {
        this.emit('command', line);
      }
      this.rl.prompt();
    });

    this.rl.on('close', () => {
      console.log(chalk.yellow('Goodbye!'));
      process.exit(0);
    });

    // Initial prompt
    this.rl.prompt();
  }

  updateOutput(content: string, level: string = 'info'): void {
    const color = this.logColors[level] || 'white';
    
    // Clear the current line
    readline.clearLine(process.stdout, 0);
    readline.cursorTo(process.stdout, 0);

    // Write the content
    console.log(chalk[color](content));

    // Re-render the prompt
    this.rl.prompt(true);
  }

  setOutputLevel(level: string): void {
    this.level = level;
  }

  async getUserInput(prompt: string): Promise<string> {
    return new Promise((resolve) => {
      this.rl.question(chalk.cyan(prompt), (answer) => {
        resolve(answer);
      });
    });
  }

  displayWelcomeMessage(): void {
    console.log(chalk.bold.green('Welcome to the AI Assistant!'));
    console.log(chalk.yellow('Type your commands and press Enter. Type "exit" to quit.'));
    this.rl.prompt();
  }

  clearScreen(): void {
    console.clear();
  }

  close(): void {
    this.rl.close();
  }
}.//defaultTools.ts

// tools.ts
// tools.ts
import 'dotenv/config';
import shell from 'shelljs';
import Conversation from './conversation/conversation';
import validator from 'validator';
import * as fs from 'fs/promises'; // Use fs.promises for async/await
import ajv from 'ajv';
import { text } from 'blessed';

const ethers = require('ethers');


// Helper function to validate address
function validateAddress(address: string): boolean {
  console.log(`Validating address: ${address}`);
  return ethers.utils.isAddress(address);
}

// Helper function to validate private key
function validatePrivateKey(privateKey: string): boolean {
  console.log(`Validating private key: ${privateKey}`);
  return ethers.utils.isHexString(privateKey, 32);
}

// Helper function to validate ABI
function validateABI(abi: any): boolean {
  console.log(`Validating ABI: ${JSON.stringify(abi)}`);
  return Array.isArray(abi);
}

// Helper function to validate transaction
function validateTransaction(transaction: any): boolean {
  console.log(`Validating transaction: ${JSON.stringify(transaction)}`);
  return transaction.to && transaction.value && typeof transaction.to === 'string' && typeof transaction.value === 'string';
}


const jsonSchemaValidator = new ajv();

async function jsonValidator(
  jsonSchema: string,
  jsonData: string,
): Promise<boolean> {
  try {
    const schema = JSON.parse(jsonSchema);
    const data = JSON.parse(jsonData);
    const validate = jsonSchemaValidator.compile(schema);
    const valid = validate(data);
    return valid;
  } catch (error) {
    return false;
  }
}


// Generic error handling function for file system operations
async function handleFileError(context: any, api: any) {
  const logError = (message: string, level: string = 'error') => {
    api.emit('error', `[${level.toUpperCase()}] ${message} `);
  };

  logError(`File operation error: ${JSON.stringify(context)} `);

  let llmResponse = await api.conversation.chat([
    {
      role: 'system',
      content: 'Analyze the file operation error and suggest a fix.',
    },
    {
      role: 'user',
      content: JSON.stringify(context),
    },
  ]);
  llmResponse = llmResponse.content[0].text.trim();

  if (llmResponse.fix) {
    logError(`Attempting LLM fix: ${llmResponse.fix} `, 'debug');
    try {
      // Attempt to apply the LLM's fix (make sure it's safe!)
      // ... (Implement safe fix application console.logic here)
    } catch (fixError: any) {
      logError(`LLM fix attempt failed: ${fixError.message} `, 'error');
    }
  }

  // Safe Fallback:
  if (context.errorCode === 'ENOENT') {
    logError('File not found. Suggest creating the file or checking the path.', 'info');
    // ... (Implement console.logic to suggest file creation or path correction)
  } else {
    logError(`Unhandled file error code: ${context.errorCode} `, 'error');
    // ... (Handle other error codes with appropriate fallbacks)
  }
}

export const tools: { [key: string]: any } = {
  
  wallet_balance: {
    schema: {
      "name": "wallet_balance",
      "description": "Get the balance of an Ethereum wallet.",
      "input_schema": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "The address of the wallet."
          },
          "provider": {
            "type": "string",
            "description": "The provider URL."
          },
          "resultVar": {
            "type": "string",
            "description": "Optional. The variable to store the patched content in."
          }
        },
        "required": [
          "address",
          "provider"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The balance of the wallet in ether."
      }
    },
    execute: async ({ address, provider, resultVar }: any, api: any) => {
      console.log(`wallet_balance called with address: ${address}, provider: ${provider}`);
      if (!validateAddress(address)) {
        throw new Error('Invalid Ethereum address');
      }
      console.log(`Getting balance for address: ${address} from provider: ${provider}`);
      const balance = await new ethers.providers.JsonRpcProvider(provider).getBalance(address);
      console.log(`Balance: ${balance}`);
      if (resultVar) {
        api.store[resultVar] = ethers.utils.formatEther(balance);
        console.log(`Stored balance in variable: ${resultVar}`);
      }
      return ethers.utils.formatEther(balance);
    },
  },
  wallet_sendTransaction: {
    schema: {
      "name": "wallet_sendTransaction",
      "description": "Send a transaction from an Ethereum wallet.",
      "input_schema": {
        "type": "object",
        "properties": {
          "privateKey": {
            "type": "string",
            "description": "The private key of the wallet."
          },
          "transaction": {
            "type": "object",
            "properties": {
              "to": {
                "type": "string",
                "description": "The address of the recipient."
              },
              "value": {
                "type": "string",
                "description": "The amount to send in wei."
              },
              "gasLimit": {
                "type": "string",
                "description": "Optional. The gas limit for the transaction."
              },
              "nonce": {
                "type": "number",
                "description": "Optional. The nonce for the transaction."
              },
            },
            "required": [
              "to",
              "value"
            ]
          },
          "provider": {
            "type": "string",
            "description": "The provider URL."
          }
        },
        "required": [
          "privateKey",
          "transaction",
          "provider"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The transaction hash."
      }
    },
    execute: async ({ privateKey, transaction, provider }: { privateKey: string, transaction: any, provider: string }) => {
      console.log(`wallet_sendTransaction called with privateKey: ${privateKey}, transaction: ${JSON.stringify(transaction)}, provider: ${provider}`);
      if (!validatePrivateKey(privateKey)) {
        throw new Error('Invalid private key');
      }
      if (!validateTransaction(transaction)) {
        throw new Error('Invalid transaction object');
      }
      console.log(`Sending transaction from wallet with private key: ${privateKey} to provider: ${provider}`);
      const wallet = new ethers.Wallet(privateKey, new ethers.providers.JsonRpcProvider(provider));
      const tx = await wallet.sendTransaction(transaction);
      console.log(`Transaction hash: ${tx.hash}`);
      return tx.hash;
    },
  },
  wallet_estimateGas: {
    schema: {
      "name": "wallet_estimateGas",
      "description": "Estimate the gas cost of an Ethereum transaction.",
      "input_schema": {
        "type": "object",
        "properties": {
          "transaction": {
            "type": "object",
            "properties": {
              "to": {
                "type": "string",
                "description": "The address of the recipient."
              },
              "value": {
                "type": "string",
                "description": "The amount to send in wei."
              },
              "data": {
                "type": "string",
                "description": "Optional. The data for the transaction."
              },
            },
            "required": [
              "to",
              "value"
            ]
          },
          "provider": {
            "type": "string",
            "description": "The provider URL."
          }
        },
        "required": [
          "transaction",
          "provider"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The estimated gas cost."
      }
    },
    execute: async ({ transaction, provider }: { transaction: any, provider: string }) => {
      console.log(`wallet_estimateGas called with transaction: ${JSON.stringify(transaction)}, provider: ${provider}`);
      if (!validateTransaction(transaction)) {
        throw new Error('Invalid transaction object');
      }
      console.log(`Estimating gas for transaction: ${JSON.stringify(transaction)} on provider: ${provider}`);
      const gasEstimate = await new ethers.providers.JsonRpcProvider(provider).estimateGas(transaction);
      console.log(`Gas estimate: ${gasEstimate.toString()}`);
      return gasEstimate.toString();
    },
  },
  contract_deploy: {
    schema: {
      "name": "contract_deploy",
      "description": "Deploy an Ethereum smart contract.",
      "input_schema": {
        "type": "object",
        "properties": {
          "privateKey": {
            "type": "string",
            "description": "The private key of the wallet."
          },
          "abi": {
            "type": "string",
            "description": "The ABI of the contract, as a JSON string."
          },
          "bytecode": {
            "type": "string",
            "description": "The bytecode of the contract."
          },
          "args": {
            "type": "array",
            "description": "The arguments for the contract constructor."
          },
          "provider": {
            "type": "string",
            "description": "The provider URL."
          }
        },
        "required": [
          "privateKey",
          "abi",
          "bytecode",
          "provider"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The address of the deployed contract."
      }
    },
    execute: async ({ privateKey, abi, bytecode, args, provider }: { privateKey: string, abi: string, bytecode: string, args: any[], provider: string }) => {
      console.log(`contract_deploy called with privateKey: ${privateKey}, abi: ${abi}, bytecode: ${bytecode}, args: ${JSON.stringify(args)}, provider: ${provider}`);
      if (!validatePrivateKey(privateKey)) {
        throw new Error('Invalid private key');
      }
      const parsedAbi = JSON.parse(abi);
      if (!validateABI(parsedAbi)) {
        throw new Error('Invalid ABI format');
      }
      console.log(`Deploying contract with ABI: ${JSON.stringify(parsedAbi)} and bytecode: ${bytecode} to provider: ${provider}`);
      const wallet = new ethers.Wallet(privateKey, new ethers.providers.JsonRpcProvider(provider));
      const factory = new ethers.ContractFactory(parsedAbi, bytecode, wallet);
      const contract = await factory.deploy(...(args || []));
      await contract.deployed();
      console.log(`Contract deployed at address: ${contract.address}`);
      return contract.address;
    },
  },
  contract_interact: {
    schema: {
      "name": "contract_interact",
      "description": "Interact with an Ethereum smart contract.",
      "input_schema": {
        "type": "object",
        "properties": {
          "privateKey": {
            "type": "string",
            "description": "The private key of the wallet."
          },
          "contractAddress": {
            "type": "string",
            "description": "The address of the contract."
          },
          "abi": {
            "type": "string",
            "description": "The ABI of the contract, as a JSON string."
          },
          "methodName": {
            "type": "string",
            "description": "The name of the method to call."
          },
          "args": {
            "type": "array",
            "description": "The arguments for the method."
          },
          "provider": {
            "type": "string",
            "description": "The provider URL."
          }
        },
        "required": [
          "privateKey",
          "contractAddress",
          "abi",
          "methodName",
          "args",
          "provider"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The result of the method call."
      }
    },
    execute: async ({ privateKey, contractAddress, abi, methodName, args, provider }: { privateKey: string, contractAddress: string, abi: string, methodName: string, args: any[], provider: string }) => {
      console.log(`contract_interact called with privateKey: ${privateKey}, contractAddress: ${contractAddress}, abi: ${abi}, methodName: ${methodName}, args: ${JSON.stringify(args)}, provider: ${provider}`);
      if (!validatePrivateKey(privateKey)) {
        throw new Error('Invalid private key');
      }
      if (!validateAddress(contractAddress)) {
        throw new Error('Invalid Ethereum address');
      }
      const parsedAbi = JSON.parse(abi);
      if (!validateABI(parsedAbi)) {
        throw new Error('Invalid ABI format');
      }
      console.log(`Interacting with contract at address: ${contractAddress} with method: ${methodName} and args: ${JSON.stringify(args)} on provider: ${provider}`);
      const wallet = new ethers.Wallet(privateKey, new ethers.providers.JsonRpcProvider(provider));
      const contract = new ethers.Contract(contractAddress, parsedAbi, wallet);
      const result = await contract[methodName](...(args || []));
      console.log(`Method call result: ${result.toString()}`);
      return result.toString();
    },
  },
  contract_call: {
    schema: {
      "name": "contract_call",
      "description": "Call a method of an Ethereum smart contract.",
      "input_schema": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "type": "string",
            "description": "The address of the contract."
          },
          "abi": {
            "type": "string",
            "description": "The ABI of the contract, as a JSON string."
          },
          "methodName": {
            "type": "string",
            "description": "The name of the method to call."
          },
          "args": {
            "type": "array",
            "description": "The arguments for the method."
          },
          "provider": {
            "type": "string",
            "description": "The provider URL."
          }
        },
        "required": [
          "contractAddress",
          "abi",
          "methodName",
          "args",
          "provider"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The result of the method call."
      }
    },
    execute: async ({ contractAddress, abi, methodName, args, provider }: { contractAddress: string, abi: string, methodName: string, args: any[], provider: string }) => {
      console.log(`contract_call called with contractAddress: ${contractAddress}, abi: ${abi}, methodName: ${methodName}, args: ${JSON.stringify(args)}, provider: ${provider}`);
      if (!validateAddress(contractAddress)) {
        throw new Error('Invalid Ethereum address');
      }
      const parsedAbi = JSON.parse(abi);
      if (!validateABI(parsedAbi)) {
        throw new Error('Invalid ABI format');
      }
      console.log(`Calling contract method: ${methodName} with args: ${JSON.stringify(args)} on provider: ${provider}`);
      const contract = new ethers.Contract(contractAddress, parsedAbi, new ethers.providers.JsonRpcProvider(provider));
      const result = await contract[methodName](...(args || []));
      console.log(`Method call result: ${result.toString()}`);
      return result.toString();
    },
  },
  contract_events: {
    schema: {
      "name": "contract_events",
      "description": "Get events emitted by an Ethereum smart contract.",
      "input_schema": {
        "type": "object",
        "properties": {
          "contractAddress": {
            "type": "string",
            "description": "The address of the contract."
          },
          "abi": {
            "type": "string",
            "description": "The ABI of the contract, as a JSON string."
          },
          "eventName": {
            "type": "string",
            "description": "The name of the event to listen for."
          },
          "filters": {
            "type": "object",
            "description": "The filters to apply to the event."
          },
          "provider": {
            "type": "string",
            "description": "The provider URL."
          }
        },
        "required": [
          "contractAddress",
          "abi",
          "eventName",
          "filters",
          "provider"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "A JSON stringified array of event data."
      }
    },
    execute: async ({ contractAddress, abi, eventName, filters, provider }: { contractAddress: string, abi: string, eventName: string, filters: any, provider: string }) => {
      console.log(`contract_events called with contractAddress: ${contractAddress}, abi: ${abi}, eventName: ${eventName}, filters: ${JSON.stringify(filters)}, provider: ${provider}`);
      if (!validateAddress(contractAddress)) {
        throw new Error('Invalid Ethereum address');
      }
      const parsedAbi = JSON.parse(abi);
      if (!validateABI(parsedAbi)) {
        throw new Error('Invalid ABI format');
      }
      console.log(`Getting events for contract: ${contractAddress}, event: ${eventName}, filters: ${JSON.stringify(filters)} from provider: ${provider}`);
      const contract = new ethers.Contract(contractAddress, parsedAbi, new ethers.providers.JsonRpcProvider(provider));
      const events = await contract.queryFilter(contract.filters[eventName](), filters);
      console.log(`Events: ${JSON.stringify(events)}`);
      return JSON.stringify(events.map((event: any) => event.args));
    },
  },
  utilities_formatEther: {
    schema: {
      "name": "utilities_formatEther",
      "description": "Convert a value from wei to ether.",
      "input_schema": {
        "type": "object",
        "properties": {
          "wei": {
            "type": "string",
            "description": "The value in wei."
          }
        },
        "required": [
          "wei"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The value in ether."
      }
    },
    execute: async ({ wei }: { wei: string }) => {
      console.log(`utilities_formatEther called with wei: ${wei}`);
      const etherValue = ethers.utils.formatEther(wei);
      console.log(`Ether value: ${etherValue}`);
      return etherValue;
    },
  },
  utilities_parseEther: {
    schema: {
      "name": "utilities_parseEther",
      "description": "Convert a value from ether to wei.",
      "input_schema": {
        "type": "object",
        "properties": {
          "ether": {
            "type": "string",
            "description": "The value in ether."
          }
        },
        "required": [
          "ether"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The value in wei."
      }
    },
    execute: async ({ ether }: { ether: string }) => {
      console.log(`utilities_parseEther called with ether: ${ether}`);
      const weiValue = ethers.utils.parseEther(ether).toString();
      console.log(`Wei value: ${weiValue}`);
      return weiValue;
    },
  },
  utilities_hash: {
    schema: {
      "name": "utilities_hash",
      "description": "Compute the hash of a value.",
      "input_schema": {
        "type": "object",
        "properties": {
          "input": {
            "type": "string",
            "description": "The input value."
          }
        },
        "required": [
          "input"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The hash of the input value."
      }
    },
    execute: async ({ input }: { input: string }) => {
      console.log(`utilities_hash called with input: ${input}`);
      const hash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(input));
      console.log(`Hash: ${hash}`);
      return hash;
    },
  },
  utilities_computeAddress: {
    schema: {
      "name": "utilities_computeAddress",
      "description": "Compute the address of a public key.",
      "input_schema": {
        "type": "object",
        "properties": {
          "publicKey": {
            "type": "string",
            "description": "The public key."
          }
        },
        "required": [
          "publicKey"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The address corresponding to the public key."
      }
    },
    execute: async ({ publicKey }: { publicKey: string }) => {
      console.log(`utilities_computeAddress called with publicKey: ${publicKey}`);
      const address = ethers.utils.computeAddress(publicKey);
      console.log(`Address: ${address}`);
      return address;
    },
  },
  bash: {
    schema: {
      "name": "bash",
      "description": "Executes a bash command. Trusty and reliable. Favor this tool over others for simple file and terminal operations.",
      "input_schema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "description": "The bash command to execute. Make sure to escape special characters, and for multi-line commands, use a single string with '\\n' for new lines."
          }
        },
        "required": [
          "command"
        ]
      },
      "output_schema": {
        "type": "string",
        "description": "The output of the bash command."
      }
    },
    execute: async (params: any, api) => {
      const { exec } = require('child_process');
      return new Promise((resolve, reject) => {
        params = Array.isArray(params) ? params[0] : params;
        exec(params, (error: any, stdout: any, stderr: any) => {
          if (error) {
            resolve(error);
          } else {
            resolve(stdout);
          }
        });
      });
    },
  },
  'get_file_tree': {
    'name': 'get_file_tree',
    'version': '1.0.0',
    'description': 'Retrieves the file tree structure from the given path.',
    'schema': {
      'name': 'get_file_tree',
      'description': 'Retrieves the file tree structure from the given path.',
      'methodSignature': 'get_file_tree(value: string, n: number): object',
    },
    execute: async ({ value, n }: any, state: any) => {
      const fs = require('fs');
      const pathModule = require('path');
      const cwd = process.cwd();
      const explore = (dir: any, depth: any) => {
        dir = pathModule.join(cwd, dir || '');
        if (depth < 0) return null;
        const directoryTree: any = { path: dir, children: [] };
        try {
          const fsd = fs.readdirSync(dir, { withFileTypes: true });
          fsd.forEach((dirent: any) => {
            const fullPath = pathModule.join(dir, dirent.name); // Use pathModule instead of path
            // ignore node_modules and .git directories
            if (dirent.isDirectory() && (dirent.name === 'node_modules' || dirent.name === '.git')) return;
            if (dirent.isDirectory()) {
              directoryTree.children.push(explore(fullPath, depth - 1));
            } else {
              directoryTree.children.push({ path: fullPath });
            }
          });
        } catch (e: any) {
          return e.message;
        }
        return directoryTree;
      };
      return explore(value, n);
    },
  },
  say_aloud: {
    'name': 'say_aloud',
    'version': '1.0.0',
    'description': 'Speaks the given text aloud using PlayHT. PASS IN A text and voice PARAMETERS TO SPEAK ALOUD.',
    'schema': {
      'name': 'say_aloud',
      'description': 'Speaks the given text aloud using PlayHT. PASS IN A text and voice PARAMETERS TO SPEAK ALOUD. voice can be either \'male\' or \'female\'.',
      'methodSignature': 'say_aloud({text, voice}:{string, string}): string',
    },
    execute: async (params: any, api: any) => {
      const PlayHT = require('playht');
      const fs = require('fs');
      var player = require('play-sound')({});

      const apiKey = process.env.PLAYHT_AUTHORIZATION;
      const userId = process.env.PLAYHT_USER_ID;
      const maleVoice = process.env.PLAYHT_MALE_VOICE;
      const femaleVoice = process.env.PLAYHT_FEMALE_VOICE;

      // Initialize PlayHT API
      PlayHT.init({
        apiKey: apiKey,
        userId: userId,
      });
      function getNonce() {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      }

      async function speakSentence(sentence: string, voice: string) {
        if (!sentence) return;
        const stream = await PlayHT.stream(sentence, {
          voiceEngine: 'PlayHT2.0-turbo',
          voiceId: voice === 'male' ? maleVoice : femaleVoice,
        });
        const chunks: any = [];
        stream.on('data', (chunk: any) => chunks.push(chunk));

        return new Promise((resolve, reject) => {
          stream.on('end', () => {
            const buf = Buffer.concat(chunks);
            // save the audio to a file
            const filename = `${getNonce()}.mp3`;
            fs.writeFileSync(filename, buf);
            player.play(
              filename,
              function (err: any) {
                fs.unlinkSync(filename);
                resolve('done');
              },
            );
          });
        });
      }

      if (!Array.isArray(params)) params = [params];
      for (const param of params) {
        // if params is a string, convert it to an object
        let { text, voice } = param;
        voice = voice || 'female';
        if (!text) throw new Error('Text is required to speak aloud');
        if (!voice) throw new Error('Voice is required to speak aloud');

        let sentences = await api.conversation.chat([
          {
            role: 'system',
            content: 'Convert the given text into a number of sentences meant to be spoken aloud. This means breaking the text into sentences that are easy to read and understand as well as phonetically pronouncing any difficult words, urls, or acronyms.*** Return your response as a RAW JSON ARRAY of strings. ***',
          },
          {
            role: 'user',
            content: text + '\n\n*** Return your response as a RAW JSON ARRAY of strings. ***',
          },
        ]);
        sentences = sentences.content[0].text;
        sentences = sentences instanceof Array ? sentences : JSON.parse(sentences);
        const consumeSentence = async () => {
          return new Promise((resolve, reject) => {
            const loop: any = async () => {
              const sentence = sentences.shift();
              if (!sentence) return resolve('done');
              await speakSentence(sentence, voice);
              return await loop();
            };
            return loop();
          });
        };
        await consumeSentence();

      }

      return '(aloud) ' + text;
    },
  },
  pause: {
    'name': 'pause',
    'version': '1.0.0',
    'description': 'Pause execution for the specified duration.',
    'schema': {
      'name': 'pause',
      'description': 'Pause execution for the specified duration.',
      "methodSignature": "pause(duration: number): void",
    },
    execute: async ({ duration }: any) => {
      return await new Promise((resolve) => setTimeout(resolve, duration));
    },
  },
  echo: {
    'name': 'echo',
    'version': '1.0.0',
    'description': 'Print the given text to the console',
    'schema': {
      'name': 'echo',
      'description': 'Print the given text to the console',
      'input_schema': {
        'type': 'object',
        'properties': {
          'text': {
            'type': 'string',
            'description': 'The text to print',
          },
        },
        'required': ['text'],
      },
    },
    execute: async ({ text }: any, api: any) => {
      api.emit('text', text);
      return text;
    },
  },
  'busybox': {
    'name': 'busybox',
    'version': '1.0.0',
    'description': 'Performs file operations. Supported operations include read, append, prepend, replace, insert_at, remove, delete, copy..',
    'schema': {
      'name': 'busybox',
      'description': 'Performs file operations. Supported operations include read, append, prepend, replace, insert_at, remove, delete, copy..',
      "methodSignature": "files(operations: { operation: string, path?: string, match?: string, data?: string, position?: number, target?: string }[]): string",
    },
    execute: async function ({ operations }: any, run: any) {
      try {
        const fs = require('fs');
        const pathModule = require('path');
        const cwd = process.cwd();
        for (const { operation, path, match, data, position, target } of operations) {
          const p = pathModule.join(cwd, path || '');
          const t = pathModule.join(cwd, target || '');
          if (!fs.existsSync(p || t)) {
            return `Error: File not found at path ${p || t} `;
          }
          let text = fs.readFileSync(p, 'utf8');
          switch (operation) {
            case 'read':
              return text;
            case 'append':
              text += data;
              break;
            case 'prepend':
              text = data + text;
              break;
            case 'replace':
              text = text.replace(match, data);
              break;
            case 'insert_at':
              text = text.slice(0, position) + data + text.slice(position);
              break;
            case 'remove':
              text = text.replace(match, '');
              break;
            case 'delete':
              fs.unlinkSync(p);
              break;
            case 'copy':
              fs.copyFileSync(p, t);
              break;
            default:
              return `Error: Unsupported operation ${operation} `;
          }
          fs.writeFileSync(p, text);
        }
        return `Successfully executed batch operations on files`;
      } catch (error: any) {
        const context = {
          errorCode: error.code,
          operations: operations,
        };
        await handleFileError(context, run);
        return `File operation '${operations}' failed. Check console.logs for details.`;
      }
    },
  },
  callLLM: {
    'name': 'callLLM',
    'version': '1.0.0',
    'description': 'Call the LLM with the given system prompt and prompt, optionally specifying the model and response format and setting a result variable.',
    'schema': {
      'name': 'callLLM',
      "methodSignature": "callLLM(params: { prompt: string, system_prompt?: string, model?: string, responseFormat?: string, resultVar?: string }[]): any",
      'description': 'Call the LLM with the given system prompt and prompt, optionally specifying the model and response format and setting a result variable.',
    },
    execute: async (params: any, api: any) => {
      if (!Array.isArray(params)) params = [params];
      for (const param of params) {
        let { prompt, system_prompt, model, responseFormat, resultVar } = param;
        try {
          if (!prompt) {
            throw new Error("Both 'prompt' and 'system_prompt' are required parameters for the 'callLLM' tool.");
          }
          if (!system_prompt) system_prompt = prompt;
          model = model || 'claude';
          if (model !== 'claude' && model !== 'gemini') {
            throw new Error("Invalid model specified. Choose either 'claude' or 'gemini'.");
          }
          if (responseFormat) {
            system_prompt = `${system_prompt}. Response Format: You MUST respond with a JSON - encoded string in the following format: \n\`\`\`typescript\n${responseFormat}\n\`\`\`\n`;
          }
          const convo = new Conversation(model);
          const response = await convo.chat([
            {
              role: 'system',
              content: system_prompt,
            },
            {
              role: 'user',
              content: prompt,
            },
          ]);

          const data = response.content[0].text.trim();

          // Validate JSON structure before parsing
          if (responseFormat) {
            try {
              const isValidJson = jsonValidator(responseFormat, data);
              if (!isValidJson) {
                throw new Error('Invalid JSON structure in LLM response. Actual response: ' + data) + ' Expected response format: ' + responseFormat;
              }

              const rr = JSON.parse(data);
              if (resultVar) {
                api.store[resultVar] = rr;
              }
              return rr;
            } catch (error: any) {
              api.emit('error', `JSON parsing failed for LLM response: ${data}`);
              if (resultVar) {
                api.store[resultVar] = data;
              }
              return data;
            }
          } else {
            if (resultVar) {
              api.store[resultVar] = data;
            }
            return data;
          }
        } catch (error: any) {
          let llmResponse = await api.conversation.chat([
            {
              role: 'system',
              content: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
            },
            {
              role: 'user',
              content: JSON.stringify({
                error: error.message,
                stackTrace: error.stack,
                context: { prompt, system_prompt, model, responseFormat, resultVar },
              }),
            },
          ]);
          llmResponse = llmResponse.content[0].text.trim();
          throw error;
        }
      }
    },
  },
  'call_agent': {
    'name': 'call_agent',
    'version': '1.0.0',
    'description': 'Call the agent with the given task to perform.',
    'schema': {
      'name': 'call_agent',
      "methodSignature": "call_agent(params: { prompt: string, model?: string, resultVar?: string }): any",
      'description': 'Call the agent with the given task to perform.'
    },
    execute: async ({ prompt, model = 'claude', resultVar }: any, api: any) => {
      try {
        if (!prompt) {
          throw new Error("The 'prompt' parameter is required for the 'call_agent' tool.");
        }
        if (model !== 'claude' && model !== 'gemini') {
          throw new Error("Invalid model specified. Choose either 'claude' or 'gemini'.");
        }
        const compactRepresentation = () => {
          return JSON.stringify(api.getSchemas());
        };
        const convo = new Conversation(model);
        const jsonPrompt = `Transform the given task into a sequence of subtasks, each with a JavaScript script that uses the provided tools to achieve the subtask objective.

Available Tools:

${compactRepresentation()}

Additional tools can be explored using 'list_all_tools', 'get_tool_details', and 'load_tool'.

Process:

1. Analyze the task and identify necessary steps
2. Decompose into subtasks with clear objectives and input/output
3. For each subtask, write a JavaScript script using the tools
  a. Access previous subtask results with taskResults.<taskName>_results: \`const lastResult = taskResults.firstTask_results; ...\`
  b. Store subtask results in a variable for future use: \`const result = { key: 'value' }; taskResults.subtask_results = result; ...\`
  b. End the script with a return statement for the subtask deliverable: \`return result;\`
4. Test each script and verify the output
5. Provide a concise explanation of the subtask's purpose and approach

Data Management:

- Store subtask results in resultVar (JSON/array format): \`taskResults.subtask_results = result;\`
Access previous subtask data with taskResults.<resultVar>: \`const lastResult = taskResults.subtask_results; ...\`
Include only resultVar instructions in responses, not the actual data.

Output Format:
\`\`\`json
[
  {
  "task": "<taskName>:<description>",
  "script": "<JavaScript script>",
  "chat": "<subtask explanation>",
  "resultVar": "<optional result variable>"
  },
  // ... additional subtasks
]
\`\`\`

CRITICAL: Verify the JSON output for accuracy and completeness before submission. *** OUTPUT ONLY JSON ***`;
        const response = await convo.chat([
          {
            role: 'system',
            content: jsonPrompt,
          },
          {
            role: 'user',
            content: JSON.stringify({
              task: 'First off: OUTPUTTING ONLY *VALID*, RAW JSON IS CRITICAL! Now read and handle this: ' + prompt,
            }),
          },
        ]);
        let tasks = response.content[0].text;

        // crop anything outside the ````json and ``` to get only the json response
        tasks = tasks.replace(/.*```json/g, '');
        tasks = tasks.replace(/.*```/g, '');
        tasks = tasks.replace(/[\r\n]+/g, '');
        let message = '';
        try {
          tasks = JSON.parse(tasks);
        } catch (error: any) {
          tasks = api.extractJson(response.content[0].text);
          message = error.message;
        }
        if (!Array.isArray(tasks) || tasks.length === 0) {
          api.emit('error', message);
          throw new Error('The task must be an array of subtasks. Check the format and try again. RETURN ONLY JSON RESPONSES' + message);
        }

        const results = [];

        api.store[prompt] = tasks;

        if (resultVar) {
          api.store[resultVar] = results;
        }

        for (const task of tasks) {
          let { task: taskName, script, chat } = task;
          const splitTask = taskName.split(':');
          let taskId = taskName;
          if (splitTask.length > 1) {
            taskId = splitTask[0];
            taskName = splitTask[1];
          }
          api.store['currentTaskId'] = taskId;
          api.emit('taskId', taskId);

          api.store[`${taskId}_task`] = task;
          api.emit(`${taskId}_task`, task);

          api.store[`${taskId}_chat`] = chat;
          api.emit(`${taskId}_chat`, chat);

          api.store[`${taskId}_script`] = script;
          api.emit(`${taskId}_script`, script);

          const sr = await api.callScript(script);
          task.scriptResult = sr;

          api.store[`${taskId}_result`] = sr;
          api.store[`${taskId}_results`] = sr;
          const rout = { id: taskId, task: taskName, script, result: sr };
          api.emit(`${taskId}_results`, rout);

          results.push(rout);
        }

        if (resultVar) {
          api.store[resultVar] = results;
        }

        return results;
      } catch (error: any) {
        let llmResponse = await api.conversation.chat([
          {
            role: 'system',
            content: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          },
          {
            role: 'user',
            content: JSON.stringify({
              error: error.message,
              stackTrace: error.stack,
              context: { prompt, model, resultVar },
            }),
          },
        ]);
        llmResponse = llmResponse.content[0].text.trim();
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
      }
    },
  },
  'call_agents': {
    'name': 'call_agents',
    'version': '1.0.0',
    'description': 'Call multiple agents with the given tasks to perform.',
    'schema': {
      'name': 'call_agents',
      "methodSignature": "call_agents(params: { prompts: string[], resultVar?: string }): any",
      'description': 'Call multiple agents with the given tasks to perform.',
    },
    execute: async ({ prompts, resultVar }: any, api: any) => {
      try {
        if (!prompts || !Array.isArray(prompts)) {
          throw new Error("The 'prompts' parameter must be an array for the 'call_agents' tool.");
        }
        const results = await Promise.all(
          prompts.map(async (prompt: string) => {
            return await api.callTool('call_agent', { prompt, model: 'claude' });
          }),
        );
        if (resultVar) {
          api.store[resultVar] = results;
        }
        return results;
      } catch (error: any) {
        let llmResponse = await api.conversation.chat([
          {
            role: 'system',
            content: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          },
          {
            role: 'user',
            content: JSON.stringify({
              error: error.message,
              stackTrace: error.stack,
              context: { prompts, resultVar },
            }),
          },
        ]);
        llmResponse = llmResponse.content[0].text.trim();
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
        throw error;
      }
    },
  },
  callLLMs: {
    'name': 'callLLMs',
    'version': '1.0.0',
    'description': 'Call the LLM with the given system prompt and prompts concurrently.',
    'schema': {
      'name': 'callLLMs',
      "methodSignature": "callLLMs(params: { prompts: string[], system_prompt: string, resultVar?: string }): any",
      'description': 'Call the LLM with the given system prompt and prompts concurrently.',
    },
    execute: async ({ prompts, system_prompt, resultVar }: any, api: any) => {
      try {
        if (!prompts || !Array.isArray(prompts) || !system_prompt) {
          throw new Error("The 'prompts' parameter must be an array and 'system_prompt' is required for the 'callLLMs' tool.");
        }
        const results = await Promise.all(
          prompts.map(async (prompt: string) => {
            return await api.conversation.chat([
              {
                role: 'system',
                content: system_prompt,
              },
              {
                role: 'user',
                content: prompt,
              },
            ]);
          }),
        );
        if (resultVar) {
          api.store[resultVar] = results;
        }
        return results;
      } catch (error: any) {
        let llmResponse = await api.conversation.chat([
          {
            role: 'system',
            content: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          },
          {
            role: 'user',
            content: JSON.stringify({
              error: error.message,
              stackTrace: error.stack,
              context: { prompts, system_prompt, resultVar },
            }),
          },
        ]);
        llmResponse = llmResponse.content[0].text.trim();
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
        throw error;
      }
    },
  },
  // apply a universal patch to a file
  'apply_patch': {
    'name': 'apply_patch',
    'version': '1.0.0',
    'description': 'Apply a universal patch to a file. Pass a file path, a patch string, and an optional resultVar to save the patched file contents.',
    'schema': {
      'name': 'apply_patch',
      "methodSignature": "apply_patch({ file: string, patch: string, resultVar?: string }): string",
      'description': 'Apply a universal patch to a file. Pass a file path, a patch string, and an optional resultVar to save the patched file contents.',
      "required": ["file", "patch"],
    },
    execute: async (params: any, api: any) => {
      if (!Array.isArray(params)) params = [params];
      for (const { file, patch, resultVar } of params) {
        try {
          if (!file || !patch) {
            throw new Error("Both 'file' and 'patch' are required parameters for the 'apply_patch' tool.");
          }
          const existsSync = require('fs').existsSync;
          const filePath = require('path').resolve(file);
          if (!(await existsSync(filePath))) {
            throw new Error(`The file '${file}' does not exist.`);
          }
          try {
            const result = await api.callTool('busybox', {
              command: 'patch',
              args: [file],
              options: { input: patch },
              resultVar,
            });
            if (resultVar) {
              api.store[resultVar] = result;
            }
            return result;
          } catch (error: any) {
            try {
              const fileContent = await fs.readFile(file, 'utf8');
              const results = await api.conversation.chat([
                {
                  role: 'system',
                  content: 'Given one or more universal patches and file content, analyze the patches and the file content to determine the best way to apply the patch to the content, then apply the patch to the file. Return ONLY the patched file contents IN ITS ENTIRETY.',
                },
                {
                  role: 'user',
                  content: `File content: ${fileContent}\n\nPatch: ${patch}`,
                },
              ]);
              return results.content[0].text;
            } catch (error: any) {
              throw new Error(`Failed to apply patch: ${error.message} Tool source: ${error.stack}`);
            }
          }
        } catch (error: any) {
          let llmResponse = await api.conversation.chat([
            {
              role: 'system',
              content: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
            },
            {
              role: 'user',
              content: JSON.stringify({
                error: error.message,
                stackTrace: error.stack,
                context: { file, patch, resultVar },
              }),
            },
          ]);
          llmResponse = llmResponse.content[0].text.trim();
          throw new Error(llmResponse);
        }
      }
    },
  },
  'generate_patches': {
    'name': 'generate_patches',
    'version': '1.0.0',
    'description':
      'Generate a number of patches for a number of files given a list of file paths and instructions for what to generate. Use this tool to make changes to one or more files given a set of instructions.',
    'schema': {
      'name': 'generate_patches',
      "methodSignature": "generate_patches(params: { files: string[], instructions: string, resultVar?: string }): string",
      'description':
        'Generate a number of patches for a number of files given a list of file paths and instructions for what to generate. Use this tool to make changes to one or more files given a set of instructions.',
    },
    execute: async ({ files, instructions, resultVar }: any, api: any) => {
      try {
        const content = files
          .map((file: string) => {
            return [file, api.fs.readFileSync(file).toString()].join('\n');
          })
          .join('\n\n');
        const prompt = `INSTRUCTIONS: ${instructions}\n\nFILES:\n\n${content}\n\nRemember to provide a JSON array of objects with the following format: [{ file: <file>, patch: <patch> }].`;
        let llmResponse = await api.conversation.chat([
          {
            role: 'system',
            content: 'Analyze the provided files, then analyse the instructions. Then, generate one or more patches for the files based on the given instructions. Return your patches as a JSON array of objects with the following format: [{ file: <file>, patch: <patch> }]. OUTPUT ONLY RAW JSON!',
          },
          {
            role: 'user',
            content: prompt,
          },
        ]);
        llmResponse = llmResponse.content[0].text.trim();
        if (resultVar) {
          api.store[resultVar] = llmResponse;
        }
        return llmResponse;
      } catch (error: any) {
        let llmResponse = await api.conversation.chat([
          {
            role: 'system',
            content: 'Analyze the provided error details and generate a fix or provide guidance on resolving the issue.',
          },
          {
            role: 'user',
            content: JSON.stringify({
              error: error.message,
              stackTrace: error.stack,
              context: { files, instructions },
            }),
          },
        ]);
        llmResponse = llmResponse.content[0].text.trim();
        if (llmResponse.fix) {
          return llmResponse.fix;
        }
        throw new Error(llmResponse);
      }
    },
  },
  'get_tools_home': {
    'name': 'get_tools_home',
    'version': '1.0.0',
    'description': 'Get the path to the tools home directory.',
    'schema': {
      'name': 'get_tools_home',
      "methodSignature": "get_tools_home(): string",
      'description': 'Get the path to the tools home directory.',
    },
    execute: async (params: any, api: any) => {
      const thisFolder = __dirname;
      const toolsHome = thisFolder + '/tools';
      return toolsHome;
    },
  },
  'list_all_tools': {
    'name': 'list_all_tools',
    'version': '1.0.0',
    'description': 'List all the tools available in the tools home directory.',
    'schema': {
      'name': 'list_all_tools',
      "methodSignature": "list_all_tools(): { type: 'array', items: { name: 'string' } }",
      'description': 'List all the tools available in the tools home directory.',
    },
    execute: async (params: any, api: any) => {
      const toolsHome = await api.callTool('get_tools_home', {});
      //const tools = fs.readdirSync(toolsHome).filter((file: string) => file.endsWith('.ts')).map((file: string) => file.replace('.ts', ''));
      const tools = await fs.readdir(toolsHome);
      return tools;
    },
  },
  'get_tool_details': {
    'name': 'get_tool_details',
    'version': '1.0.0',
    'description': 'Get the details of a tool.',
    'schema': {
      'name': 'get_tool_details',
      "methodSignature": "get_tool_details(tool: string): { name: 'string', description: 'string', input_schema: 'object', output_schema: 'object' }",
      'description': 'Get the details of a tool.',
    },
    execute: async ({ tool }: any, api: any) => {
      const toolsHome = await api.callTool('get_tools_home', {});
      const toolPath = `${toolsHome}/${tool}.ts`;
      const existsSync = require('fs').existsSync;
      if (!existsSync(toolPath)) {
        throw new Error(`The tool '${tool}' does not exist.`);
      }
      const toolModule = require(toolPath);
      return toolModule.schema;
    },
  },
  'get_tools_details': {
    'name': 'get_tools_details',
    'version': '1.0.0',
    'description': 'Get the details of the specified tools.',
    'schema': {
      'name': 'get_tools_details',
      "methodSignature": "get_tools_details(tools: string[]): { name: 'string', description: 'string', input_schema: 'object', output_schema: 'object' }[]",
      'description': 'Get the details of the specified tools.',
    },
    execute: async (params: any, api: any) => {
      const { tools } = params;
      const toolsDetails = await Promise.all(
        tools.map(async (tool: string) => {
          return await api.callTool('get_tool_details', { tool });
        }),
      );
      return toolsDetails;
    },
  },
  'list_active_tools': {
    'name': 'list_active_tools',
    'version': '1.0.0',
    'description': 'List all the active tools in the current session.',
    'schema': {
      'name': 'list_active_tools',
      "methodSignature": "list_active_tools(): string[]",
      'description': 'List all the active tools in the current session.',
    },
    execute: async (params: any, api: any) => {
      return Object.keys(api.tools);
    },
  },
  'load_tool': {
    'name': 'load_tool',
    'version': '1.0.0',
    'description': 'Load a tool from a file path.',
    'schema': {
      name: 'load_tool',
      "methodSignature": "load_tool(path: string): string",
      description: 'Load a tool from a file path.',
    },
    execute: async ({ path }: any, api: any) => {
      try {
        const toolModule = require(path);
        const toolName = toolModule.name; // Assuming the tool module exports its name
        api.toolRegistry.addTool(toolName, toolModule.source, toolModule.schema, toolModule.tags || []);
        return toolName;
      } catch (error: any) {
        throw new Error(`Failed to load tool: ${error.message} Tool source: ${error.stack}`);
      }
    },
  },
  'load_tool_source': {
    'name': 'load_tool_source',
    'version': '1.0.0',
    'description': 'Load a tool from a file path and return the source code.',
    'schema': {
      'name': 'load_tool_source',
      "methodSignature": "load_tool_source(path: string): string",
      'description': 'Load a tool from a file path and return the source code.',
    },
    execute: async ({ path }: any, api: any) => {
      try {
        const tool = await fs.readFile(path, 'utf8');
        return tool;
      } catch (error: any) {
        throw new Error(`Failed to load tool source: ${error.message} Tool source: ${error.stack}`);
      }
    },
  },
  'save_tool': {
    'name': 'save_tool',
    'version': '1.0.0',
    'description': 'Save a tool to a file path.',
    'schema': {
      name: 'save_tool',
      'methodSignature': 'save_tool(params: { tool: object, path: string }): string',
      description: 'Save a tool to a file path.',
    },
    execute: async ({ tool, path }: any, api: any) => {
      try {
        const name = Object.keys(tool)[0];
        await fs.writeFile(path, `module.exports = ${JSON.stringify(tool, null, 2)};`);
        return name;
      } catch (error: any) {
        throw new Error(`Failed to save tool: ${error.message} Tool source: ${error.stack}`);
      }
    },
  },
  search_news_api: {
    'name': 'search_news_api',
    'version': '1.0.0',
    'description': 'Performs a news search using the given query.',
    'schema': {
      'name': 'search_news_api',
      "methodSignature": "search_news_api(params: { q: string, from?: string, to?: string, language?: string, country?: string, domains?: string, sources?: string, sortBy?: string, num?: number }): string",
      'description': 'Performs a news search using the given query.',
    },
    execute: async (values: any) => {
      const axios = require('axios');
      const trunc = (str: any, len: any) => {
        return str.length > len ? str.substring(0, len - 3) + '...' : str;
      }
      try {
        const response = await axios.get(`https://newsapi.org/v2/everything?q=${values.q}&apiKey=${process.env.NEWS_API_KEY}`);
        const results = response.data.articles.map((item: any) => ({
          content: trunc(item.content, 100),
          title: item.title,
          url: item.url,
        }));
        // keep only the first num results
        let num = values.num ? values.num : 10;
        const res = results.slice(0, num);
        return JSON.stringify(res);
      } catch (error: any) {
        return `Error calling News API: ${error.message}`
      }
    }
  },
  search_google: {
    'name': 'search_google',
    'version': '1.0.0',
    'description': 'perform a google search using the given query',
    'schema': {
      "name": "search_google",
      "methodSignature": "search_google(params: { query: string }): string",
      "description": "perform a google search using the given query",
    },
    execute: async ({ query }: any) => {
      const config = {
        GOOGLE_API_KEY: process.env.GOOGLE_API_KEY,
        GOOGLE_CX_ID: process.env.GOOGLE_CX_ID
      }
      try {
        const axios = require('axios');
        const response = await
          axios.get(`https://www.googleapis.com/customsearch/v1?key=${config.GOOGLE_API_KEY}&cx=${config.GOOGLE_CX_ID}&q=${query}`);
        const results = response.data.items.map((item: any) => ({
          title: item.title,
          link: item.link
        }));
        const res = JSON.stringify(results);
        return res;
      } catch (error: any) {
        return error.message;
      }
    }
  },
  fixJson: {
    // given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array
    // given some text content without any JSON within it, it will attempt to structure the text content into a JSON object
    'name': 'fixJson',
    'version': '1.0.0',
    'description': 'given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array, given some text content without any JSON within it, it will attempt to structure the text content into a JSON object',
    'schema': {
      'name': 'fixJson',
      'methodSignature': 'fixJson(params: { json: string, resultVar?: string }): any',
      'description': 'given some text content with some JSON within it, it will extract the JSON and return a syntactically correct JSON object/array, given some text content without any JSON within it, it will attempt to structure the text content into a JSON object',
    },
    execute: async ({ json, resultVar }: any, api: any) => {
      const convo = new Conversation('gemini');
      const sp = `Given some content that contains a JSON object or array, you ignore EVERYTHING BEFORE OR AFTER what is obviously JSON data, ignoring funky keys and weird data, and you output a syntactically-valid version of the JSON, with other quoting characters properly escaped, on a single line. If the content contains no JSON data, you output a JSON object containing the input data, structured in the most appropriate manner for the data.`;
      const tasks = await convo.chat([
        {
          role: 'system',
          content: sp
        },
        {
          role: 'user',
          content: json,
        },
      ], {} as any, 'gemini-1.5-flash-001');
      let task = tasks.content[0].text;
      try {
        task = JSON.parse(task);
      } catch (error: any) {
        task = api.extractJson(task);
      }
      if (resultVar) {
        api.store[resultVar] = task;
      }
      return task;
    }
  }

};
.//script/cleanupManager.ts
import { Tool } from '../tools/tool';
import { ToolRegistry } from '../tools/toolRegistry';

import { ScriptPerformanceMonitor } from './performanceMonitor';

export class ScriptCleanupManager {
  static async cleanupUnusedScripts(toolRegistry: ToolRegistry): Promise<void> {
    const allScripts = await toolRegistry.getToolList();
    const currentDate = new Date();

    for (const script of allScripts) {
      const metrics = ScriptPerformanceMonitor.getMetrics(script.name);
      if (metrics) {
        const daysSinceLastExecution = (currentDate.getTime() - metrics.lastExecutionTime.getTime()) / (24 * 60 * 60 * 1000);
        if (daysSinceLastExecution > 30 && metrics.executionCount < 5) {
          await this.archiveScript(toolRegistry, script);
        }
      }
    }
  }

  private static async archiveScript(toolRegistry: ToolRegistry, script: Tool): Promise<void> {
    await toolRegistry.updateTool(script.name, script.source, { ...script.schema, archived: true }, script.tags);
  }
}.//script/metadataManager.ts
// metadataManager.ts

import { ToolRegistry } from "../tools/toolRegistry";

export interface ScriptMetadata {
  originalQuery: string;
  creationDate: Date;
  lastModifiedDate: Date;
  author: string;
  version: string;
  tags: string[];
  dependencies: string[];
  description?: string;
}

export class MetadataManager {
  static async addMetadata(toolRegistry: ToolRegistry, scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    const script = await toolRegistry.getTool(scriptName);
    if (script) {
      const updatedScript = {
        ...script,
        metadata: {
          ...script.metadata,
          ...metadata,
          lastModifiedDate: new Date()
        }
      };
      await toolRegistry.updateTool(scriptName, updatedScript.source, updatedScript.schema, updatedScript.tags);
    }
  }

  static async getMetadata(toolRegistry: ToolRegistry, scriptName: string): Promise<ScriptMetadata | null> {
    const script = await toolRegistry.getTool(scriptName);
    return script ? script.metadata : null;
  }

  static async updateMetadata(toolRegistry: ToolRegistry, scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    const script = await toolRegistry.getTool(scriptName);
    if (script) {
      const updatedScript = {
        ...script,
        metadata: {
          ...script.metadata,
          ...metadata,
          lastModifiedDate: new Date()
        }
      };
      await toolRegistry.updateTool(scriptName, updatedScript.source, updatedScript.schema, updatedScript.tags);
    }
  }

  static async removeMetadata(toolRegistry: ToolRegistry, scriptName: string): Promise<void> {
    const script = await toolRegistry.getTool(scriptName);
    if (script) {
      const updatedScript = {
        ...script,
        metadata: {
          originalQuery: '',
          creationDate: new Date(),
          lastModifiedDate: new Date(),
        }
      };
      await toolRegistry.updateTool(scriptName, updatedScript.source, updatedScript.schema, updatedScript.tags);
    }
  }
}
.//script/performanceMonitor.ts
export class ScriptPerformanceMonitor {
    private static metrics: Map<string, {
      executionCount: number,
      totalExecutionTime: number,
      averageExecutionTime: number,
      lastExecutionTime: Date
    }> = new Map();
  
    static recordExecution(scriptName: string, executionTime: number): void {
      const metric = this.metrics.get(scriptName) || {
        executionCount: 0,
        totalExecutionTime: 0,
        averageExecutionTime: 0,
        lastExecutionTime: new Date()
      };
  
      metric.executionCount++;
      metric.totalExecutionTime += executionTime;
      metric.averageExecutionTime = metric.totalExecutionTime / metric.executionCount;
      metric.lastExecutionTime = new Date();
  
      this.metrics.set(scriptName, metric);
    }
  
    static getMetrics(scriptName: string): any {
      return this.metrics.get(scriptName);
    }
  
    static getAllMetrics(): Map<string, any> {
      return this.metrics;
    }
  }.//script/__test__/cleanupManager.test.ts
import { ScriptCleanupManager } from '../cleanupManager';
import { ToolRegistry } from '../../tools/toolRegistry';
import { ScriptPerformanceMonitor } from '../performanceMonitor';
import { MetricsService } from '../../metrics/metricsService';
import { ConversationService } from '../../conversation/conversationService';

jest.mock('../../tools/toolRegistry');
jest.mock('../performanceMonitor');
jest.mock('../../metrics/metricsService');
jest.mock('../../conversation/conversationService');

describe('ScriptCleanupManager', () => {
  let mockToolRegistry: jest.Mocked<ToolRegistry>;
  let mockMetricsService: jest.Mocked<MetricsService>;
  let mockConversationService: jest.Mocked<ConversationService>;


  beforeEach(() => {
    mockMetricsService = new MetricsService() as jest.Mocked<MetricsService>;
    mockConversationService = new ConversationService() as jest.Mocked<ConversationService>;
    mockToolRegistry = new ToolRegistry(mockMetricsService, mockConversationService) as jest.Mocked<ToolRegistry>;
    jest.spyOn(ScriptPerformanceMonitor, 'getMetrics').mockImplementation((scriptName) => ({
      executionCount: scriptName === 'oldScript' ? 3 : 10,
      lastExecutionTime: new Date(Date.now() - (scriptName === 'oldScript' ? 40 : 20) * 24 * 60 * 60 * 1000),
      totalExecutionTime: 1000,
      averageExecutionTime: 100
    }));
  });

  it('should archive old and rarely used scripts', async () => {
    mockToolRegistry.getToolList.mockResolvedValue([
      { name: 'oldScript', source: 'console.log("old")', schema: {}, tags: [] },
      { name: 'newScript', source: 'console.log("new")', schema: {}, tags: [] }
    ] as any);

    await ScriptCleanupManager.cleanupUnusedScripts(mockToolRegistry);

    expect(mockToolRegistry.updateTool).toHaveBeenCalledWith(
      'oldScript',
      'console.log("old")',
      { archived: true },
      []
    );
    expect(mockToolRegistry.updateTool).not.toHaveBeenCalledWith(
      'newScript',
      expect.anything(),
      expect.anything(),
      expect.anything()
    );
  });


  it('should not archive recently used scripts', async () => {
    mockToolRegistry.getToolList.mockResolvedValue([
      { name: 'recentScript', source: 'console.log("recent")', schema: {}, tags: [] } as any
    ]);

    jest.spyOn(ScriptPerformanceMonitor, 'getMetrics').mockImplementation(() => ({
      executionCount: 10,
      lastExecutionTime: new Date(),
      totalExecutionTime: 1000,
      averageExecutionTime: 100
    }));

    await ScriptCleanupManager.cleanupUnusedScripts(mockToolRegistry);

    expect(mockToolRegistry.updateTool).not.toHaveBeenCalled();
  });
});.//script/__test__/scriptManager.test.ts
import { ScriptManager } from '../scriptManager';
import { ToolRegistry } from '../../tools/toolRegistry';
import { ScriptValidator } from '../validator';
import { ScriptPerformanceMonitor } from '../performanceMonitor';
import { ScriptCleanupManager } from '../cleanupManager';
import { MetadataManager } from '../metadataManager';

jest.mock('../validator');
jest.mock('../performanceMonitor');
jest.mock('../cleanupManager');
jest.mock('../metadataManager');

describe('ScriptManager', () => {
  let scriptManager: ScriptManager;
  let mockToolRegistry: jest.Mocked<ToolRegistry>;

  beforeEach(() => {
    mockToolRegistry = {
      addTool: jest.fn(),
      updateTool: jest.fn(),
      removeTool: jest.fn(),
      getTool: jest.fn(),
    } as any;
    scriptManager = new ScriptManager(mockToolRegistry);
  });

  it('should initialize and clean up unused scripts', async () => {
    await scriptManager.initialize();
    expect(ScriptCleanupManager.cleanupUnusedScripts).toHaveBeenCalledWith(mockToolRegistry);
  });

  it('should validate a script', async () => {
    const script = 'console.log("Hello, World!");';
    await scriptManager.validateScript(script);
    expect(ScriptValidator.validate).toHaveBeenCalledWith(script);
  });

  it('should record script execution', () => {
    const scriptName = 'testScript';
    const executionTime = 100;
    scriptManager.recordExecution(scriptName, executionTime);
    expect(ScriptPerformanceMonitor.recordExecution).toHaveBeenCalledWith(scriptName, executionTime);
  });

  it('should clean up unused scripts', async () => {
    await scriptManager.cleanupUnusedScripts();
    expect(ScriptCleanupManager.cleanupUnusedScripts).toHaveBeenCalledWith(mockToolRegistry);
  });

  it('should add metadata to a script', async () => {
    const scriptName = 'testScript';
    const metadata = { description: 'Test script' };
    await scriptManager.addMetadata(scriptName, metadata);
    expect(MetadataManager.addMetadata).toHaveBeenCalledWith(mockToolRegistry, scriptName, metadata);
  });

  it('should get metadata for a script', async () => {
    const scriptName = 'testScript';
    await scriptManager.getMetadata(scriptName);
    expect(MetadataManager.getMetadata).toHaveBeenCalledWith(mockToolRegistry, scriptName);
  });

  it('should update metadata for a script', async () => {
    const scriptName = 'testScript';
    const metadata = { description: 'Updated test script' };
    await scriptManager.updateMetadata(scriptName, metadata);
    expect(MetadataManager.updateMetadata).toHaveBeenCalledWith(mockToolRegistry, scriptName, metadata);
  });

  it('should remove metadata from a script', async () => {
    const scriptName = 'testScript';
    await scriptManager.removeMetadata(scriptName);
    expect(MetadataManager.removeMetadata).toHaveBeenCalledWith(mockToolRegistry, scriptName);
  });

  it('should get metrics for a script', () => {
    const scriptName = 'testScript';
    scriptManager.getMetrics(scriptName);
    expect(ScriptPerformanceMonitor.getMetrics).toHaveBeenCalledWith(scriptName);
  });

  it('should get all metrics', () => {
    scriptManager.getAllMetrics();
    expect(ScriptPerformanceMonitor.getAllMetrics).toHaveBeenCalled();
  });
});.//script/__test__/metadataManager.test.ts
import { MetadataManager, ScriptMetadata } from '../metadataManager';
import { ToolRegistry } from '../../tools/toolRegistry';

jest.mock('../../tools/toolRegistry');

describe('MetadataManager', () => {
  let mockToolRegistry: jest.Mocked<ToolRegistry>;
  let mockMetricsService: any;
  let mockConversationService: any;
  beforeEach(() => {
    mockMetricsService = {
      recordToolAddition: jest.fn(),
      recordToolUpdate: jest.fn(),
      recordToolRemoval: jest.fn(),
      getToolMetrics: jest.fn(),
      getAllMetrics: jest.fn()
    };
    mockConversationService = {
      chat: jest.fn()
    };
    mockToolRegistry = new ToolRegistry(mockMetricsService, mockConversationService) as any;
  });

  it('should add metadata to a script', async () => {
    const scriptName = 'testScript';
    const metadata: Partial<ScriptMetadata> = { description: 'Test script' };
    
    mockToolRegistry.getTool.mockResolvedValue({
      name: scriptName,
      source: 'console.log("test")',
      schema: {},
      tags: [],
      metadata: {}
    } as any);

    await MetadataManager.addMetadata(mockToolRegistry, scriptName, metadata);

    expect(mockToolRegistry.updateTool).toHaveBeenCalledWith(
      "testScript",
      "console.log(\"test\")",
      {},
      [],
      expect.objectContaining({ description: "Test script" })
    );
  });

  // Add more tests for getMetadata, updateMetadata, and removeMetadata
});.//script/__test__/validator.test.ts
import { ScriptValidator } from '../validator';

describe('ScriptValidator', () => {
  it('should validate a correct script', async () => {
    const validScript = 'console.log("Hello, World!");';
    const result = await ScriptValidator.validate(validScript);
    expect(result).toBe(true);
  });

  it('should reject an invalid script', async () => {
    const invalidScript = 'console.log("Unclosed string;';
    const result = await ScriptValidator.validate(invalidScript);
    expect(result).toBe(false);
  });
});
.//script/__test__/performanceMonitor.test.ts
import { ScriptPerformanceMonitor } from '../performanceMonitor';

describe('ScriptPerformanceMonitor', () => {
  beforeEach(() => {
    // Clear the metrics before each test
    (ScriptPerformanceMonitor as any).metrics.clear();
  });

  it('should record script execution', () => {
    ScriptPerformanceMonitor.recordExecution('testScript', 100);
    const metrics = ScriptPerformanceMonitor.getMetrics('testScript');
    expect(metrics).toEqual({
      executionCount: 1,
      totalExecutionTime: 100,
      averageExecutionTime: 100,
      lastExecutionTime: expect.any(Date)
    });
  });

  it('should update metrics on multiple executions', () => {
    ScriptPerformanceMonitor.recordExecution('testScript', 100);
    ScriptPerformanceMonitor.recordExecution('testScript', 200);
    const metrics = ScriptPerformanceMonitor.getMetrics('testScript');
    expect(metrics).toEqual({
      executionCount: 2,
      totalExecutionTime: 300,
      averageExecutionTime: 150,
      lastExecutionTime: expect.any(Date)
    });
  });

  it('should return null for non-existent script metrics', () => {
    const metrics = ScriptPerformanceMonitor.getMetrics('nonExistentScript');
    expect(metrics).toBeUndefined();
  });

  it('should return all metrics', () => {
    ScriptPerformanceMonitor.recordExecution('script1', 100);
    ScriptPerformanceMonitor.recordExecution('script2', 200);
    const allMetrics = ScriptPerformanceMonitor.getAllMetrics();
    expect(allMetrics.size).toBe(2);
    expect(allMetrics.has('script1')).toBe(true);
    expect(allMetrics.has('script2')).toBe(true);
  });


  it('should record execution and calculate average time', () => {
    ScriptPerformanceMonitor.recordExecution('testScript', 100);
    ScriptPerformanceMonitor.recordExecution('testScript', 200);

    const metrics = ScriptPerformanceMonitor.getMetrics('testScript');
    expect(metrics).toEqual({
      executionCount: 2,
      totalExecutionTime: 300,
      averageExecutionTime: 150,
      lastExecutionTime: expect.any(Date)
    });
  });

  it('should return undefined for non-existent script metrics', () => {
    const metrics = ScriptPerformanceMonitor.getMetrics('nonExistentScript');
    expect(metrics).toBeUndefined();
  });

  it('should return all metrics', () => {
    ScriptPerformanceMonitor.recordExecution('script1', 100);
    ScriptPerformanceMonitor.recordExecution('script2', 200);

    const allMetrics = ScriptPerformanceMonitor.getAllMetrics();
    expect(allMetrics.size).toBe(2);
    expect(allMetrics.get('script1')).toBeDefined();
    expect(allMetrics.get('script2')).toBeDefined();
  });
});

.//script/scriptManager.ts
// scriptManager.ts
import { ScriptValidator } from './validator';
import { ScriptPerformanceMonitor } from './performanceMonitor';
import { ScriptCleanupManager } from './cleanupManager';
import { MetadataManager, ScriptMetadata } from './metadataManager';
import { ToolRegistry } from '../tools/toolRegistry';

export class ScriptManager {

  constructor(private toolRegistry: ToolRegistry) {
  }

  async initialize(): Promise<void> {
    await ScriptCleanupManager.cleanupUnusedScripts(this.toolRegistry);
  }

  async validateScript(script: string): Promise<boolean> {
    return await ScriptValidator.validate(script);
  }

  recordExecution(scriptName: string, executionTime: number): void {
    ScriptPerformanceMonitor.recordExecution(scriptName, executionTime);
  }

  async cleanupUnusedScripts(): Promise<void> {
    await ScriptCleanupManager.cleanupUnusedScripts(this.toolRegistry);
  }

  async addMetadata(scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    await MetadataManager.addMetadata(this.toolRegistry, scriptName, metadata);
  }

  async getMetadata(scriptName: string): Promise<ScriptMetadata | null> {
    return await MetadataManager.getMetadata(this.toolRegistry, scriptName);
  }

  async updateMetadata(scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    await MetadataManager.updateMetadata(this.toolRegistry, scriptName, metadata);
  }

  async removeMetadata(scriptName: string): Promise<void> {
    await MetadataManager.removeMetadata(this.toolRegistry, scriptName);
  }

  getMetrics(scriptName: string): any {
    return ScriptPerformanceMonitor.getMetrics(scriptName);
  }

  getAllMetrics(): Map<string, any> {
    return ScriptPerformanceMonitor.getAllMetrics();
  }
}.//script/validator.ts
import * as vm from 'vm2';

export class ScriptValidator {
  static async validate(script: string): Promise<boolean> {
    const staticAnalysisResult = await this.performStaticAnalysis(script);
    if (!staticAnalysisResult.valid) return false;

    const sandboxResult = await this.runInSandbox(script);
    if (!sandboxResult.valid) return false;

    return true;
  }

  private static async performStaticAnalysis(script: string): Promise<{valid: boolean, issues?: string[]}> {
    // Implement static code analysis here
    // This could use tools like ESLint or custom rules
    return { valid: true };
  }

  private static async runInSandbox(script: string): Promise<{valid: boolean, output?: any}> {
    const sandbox = new vm.VM({
      timeout: 5000,
      sandbox: {}
    });

    try {
      sandbox.run(script);
      return { valid: true };
    } catch (error) {
      console.error('Script execution in sandbox failed:', error);
      return { valid: false, output: error.message };
    }
  }
}.//search/fuzzySearch.ts
export function fuzzySearch(items: string[], query: string): string[] {
    const lowercaseQuery = query.toLowerCase();
    return items.filter(item => {
      const lowercaseItem = item.toLowerCase();
      let i = 0, n = -1, l;
      for (; l = lowercaseQuery[i++] ;) {
        if (!~(n = lowercaseItem.indexOf(l, n + 1))) return false;
      }
      return true;
    });
  }.//history/historyService.ts
// historyService.ts

export class HistoryService {
    private history: string[] = [];
    private maxHistorySize: number;
  
    constructor(maxHistorySize: number = 1000) {
      this.maxHistorySize = maxHistorySize;
    }
  
    saveToHistory(command: string): void {
      this.history.unshift(command);
      if (this.history.length > this.maxHistorySize) {
        this.history.pop();
      }
    }
  
    getHistory(): string[] {
      return [...this.history];
    }
  
    clearHistory(): void {
      this.history = [];
    }
  
    searchHistory(query: string): string[] {
      return this.history.filter(cmd => cmd.includes(query));
    }
  }.//prompts/promptService.ts
import Conversation from "../conversation/conversation";
import { ConversationService } from "../conversation/conversationService";
import { ToolRegistry } from "../tools/toolRegistry";

export function makePromptFunction(
  conversation: any,
  systemPrompt: string,
  userPromptTemplate: string,
  jsonRequestFormat: any,
  jsonResultFormat: any) {
  const validateRequestObject = (requestObject: any, jsonRequestFormat: any) => {
    if (jsonRequestFormat) {
      if (typeof requestObject !== 'object') {
        throw new Error('Request object must be an object');
      }
      for (const key in jsonRequestFormat) {
        if (jsonRequestFormat[key] === 'required' && !requestObject[key]) {
          throw new Error(`Request object must contain key: ${key}`);
        }
      }
    }
  }
  const replaceWithValues = (template: string, values: any) => {
    return template.replace(/\${([^{}]*)}/g, (substring: string, ...args: any[]) => {
      const b = args[0];
      const r = values[b];
      return typeof r === 'string' ? r : typeof r === 'number' ? r.toString() : substring;
    });
  }
  return async (requestObject: any) => {
    jsonRequestFormat && validateRequestObject(requestObject, jsonRequestFormat);
    let userPrompt = userPromptTemplate ? replaceWithValues(userPromptTemplate, requestObject) : requestObject;
    if (jsonResultFormat && systemPrompt) {
      systemPrompt = JSON.stringify({
        systemPrompt: systemPrompt && replaceWithValues(systemPrompt, requestObject),
        resultFormat: jsonResultFormat,
        userPrompt,
        options: ['DISABLE_ALL_COMMENTARY', 'DISABLE_CODEBLOCKS', 'JSON_OUTPUT_ONLY']
      });
    }
    try {
      const response = await conversation.chat([{
        role: 'system',
        content: systemPrompt,
      },
      {
        role: 'user',
        content: userPrompt,
      },]);
      return response;
    } catch (error) {
      console.error(`Error calling prompt:`, error);
      throw error;
    }
  }
}

export class PromptService {
  constructor(private conversationService: ConversationService, private toolRegistry: ToolRegistry) { }

  // given a task, likely tools, and relevant memories, determine:
  // - which existing tools to likely use
  // - which new tools to create
  // - which npm packages to install
  // - whether to use a single tool or multiple tools
  // - the name of the tool to use
  // - the parameters to pass to the tool
  determineTaskTools = async ({
    task,
    likelyTools,
    relevantMemories
  }: any): Promise<{
    existingTools: string[],
    newTools: string[],
    packages: string[],
    useSingleTool: boolean,
    toolName: string,
    params: any
  }> => {
    const fn = makePromptFunction(this.conversationService,
    `Given the list of available tools, Determine the best tools to use for the following task. If you need to install npm packages, return them in the "packages" field.\n
- If an available tool can fulfill the entire task, then return that tool's name along with the parameters.
- If multiple tools are needed to complete the task, then return the list of tools.
- Allow your memory of past tasks to influence your decision.
- Your available tools are:\n${this.toolRegistry.getCompactRepresentation()}`,
    `Task: ${task}\nLikely Tools: ${likelyTools}\nRelevant Memories: ${relevantMemories}`, {
    task: "string",
    likelyTools: "string",
    relevantMemories: "string"
  }, {
    existingTools: ["Tool1", "Tool2"],
    newTools: ["tool1:<tool description including functional behavior,input params and return value", "tool2:..."],
    packages: ["package1", "package2"],
    useSingleTool: "boolean",
    toolName: "Tool1",
    params: {}
  });
  return await fn({ task, likelyTools, relevantMemories });
}

  // given a tool name, description, and task, generate a new tool module, returning:
  // - the tool name
  // - the tools description
  // - the method signature for the tool
  // - the tools script
  // - the packages to install
  generateTool = async ({
    toolName,
    description,
    task
  }: any): Promise<{
    tool: string,
    description: string,
    methodSignature: string,
    script: string,
    packages: string[]
  }> => {
    const fn = makePromptFunction(this.conversationService,
      `You are an AI assistant tasked with writing a new tool in Javascript.\n
- You are given a tool name and description, along with the originating task name.
- You must create a new tool module using the provided template which accomplishes the task.
- You can use npm packages and external libraries if needed. If you need to install npm packages, return them in the "packages" field.
- Return the tool module code, packages to install, and a method signature for the tool.\n
Please provide the complete standardized tool module code, including the class definition and export.
Your available tools are:\n${this.toolRegistry.getCompactRepresentation()}`,
      `Tool name: ${toolName}\nDescription: ${description}\nTask: ${task}\n\n
Template:\n\n\`\`\`javascript
// This is javascript code for a tool module
class {toolName}Tool {\n
  async execute(params, api) {
    // Tool implementation goes here
  }\n\n}\n\nmodule.exports = new {toolName}Tool();
\`\`\``,
      {
        toolName: "string",
        description: "string",
        task: "string"
      },
      {
        tool: "<toolName>",
        description: "<description>",
        methodSignature: "<method signature>",
        script: "<JavaScript script formatted in template>",
        packages: ["package1", "package2"]
      });
    return await fn({ toolName, description, task });
  };

  // given a task and available tools, generate a sequence of subtasks with scripts
  generateTasks = async ({
    task,
    availableTools,
    memories
  }: any): Promise<{
    task: string,
    script: string,
    chat: string,
  }[]> => {
    const fn = makePromptFunction(this.conversationService,
      `Transform the given task into a sequence of subtasks, each with a JavaScript script that uses the provided tools to achieve the subtask objective.\n
Available Tools:\n${availableTools}\n
Similar Past Experiences:\n${memories}\n
Process:\n
1. Analyze the task and identify necessary steps, considering similar past experiences
2. Decompose into subtasks with clear objectives and input/output
3. For each subtask, write a JavaScript script using the tools
  a. Access previous subtask results with taskResults.<taskName>_results: \`const lastResult = taskResults.firstTask_results; ...\`
  b. Store subtask results in a variable for future use: \`const result = { key: 'value' }; taskResults.subtask_results = result; ...\`
  c. End the script with a return statement for the subtask deliverable: \`return result;\`
4. Test each script and verify the output
  a. Use the template below to structure the script. Replace [name] with the subtask name.`,
      `Task: ${task}\n\nTemplate:\n\n\`\`\`javascript
// This is javascript code for a tool module
class [name]Tool {\n
  async execute(params, api) {
    // Tool implementation goes here. MUST return a value.
  }\n\n}\n
module.exports = new [name]Tool();
\`\`\`\n
5. Provide a concise explanation of the subtask's purpose and approach
6. MAKE SURE THE SCRIPT YOU WRITE IS JAVASCRIPT.\n      
Data Management:\n
- Store subtask results in resultVar (JSON/array format): \`taskResults.subtask_results = result;\`
- Access previous subtask data with taskResults.<resultVar>: \`const lastResult = taskResults.subtask_results; ...\`
- <critical>Include only resultVar instructions in responses, not the actual data.</critical>`,
      {
        task: "string",
        memories: "string"
      },
      [{
        task: "<taskName>:<description>",
        script: "<JavaScript script formatted in template>",
        chat: "<subtask explanation>",
      }, '...']);
    return await fn({ task, memories });
  };

  repairFailedScriptExecution = async ({
    task,
    source,
    availableTools,
    memories
  }: any): Promise<{
    repaired: boolean,
    reason: string,
    name: string,
    source: string
  }> => {
    const fn = makePromptFunction(this.conversationService,
      `You are an AI assistant tasked with repairing a failed script execution.\n
Available Tools:\n${availableTools}\n
Similar Past Experiences:\n${memories}\n
Process:\n
1. Analyze the failed script source code and identify the issue
2. If you can repair the script, do so, using the provided source code as your starting point. Set reason to the failure reason and what you did to fix it.
3. If tou cannot repair the script, set repaired to false and provide a reason why.`,
`Task: ${task}\n\nSource:\n\n${source}\n\nTemplate:\n\n\`\`\`javascript
// This is javascript code for a tool module
class [name]Tool {\n
  async execute(params, api) {
    // Tool implementation goes here. MUST return a value.
  }\n\n}\n
  };
  module.exports = new [name]Tool();
\`\`\`\n`,
      {
        task: "string",
        source: "string",
        memories: "string"
      },
      {
        repaired: "boolean",
        reason: "string",
        name: "string",
        source: "string"
      });
    return await fn({ task, source, memories });
  }
}.//prompts/__test__/promptService.test.ts
import { PromptService } from '../promptService';
import { ConversationService } from '../../conversation/conversationService';
import { ToolRegistry } from '../../tools/toolRegistry';
import { MetricsService } from '../../metrics/metricsService';

jest.mock('../../conversation/conversationService');
jest.mock('../../tools/toolRegistry');
jest.mock('../../metrics/metricsService');

describe('PromptService', () => {
  let promptService: PromptService;
  let mockConversationService: jest.Mocked<ConversationService>;
  let mockToolRegistry: jest.Mocked<ToolRegistry>;
  let mockMetricsService: jest.Mocked<MetricsService>;

  beforeEach(() => {
    mockConversationService = {
      chat: jest.fn(),
    } as unknown as jest.Mocked<ConversationService>;
    mockMetricsService = new MetricsService() as jest.Mocked<MetricsService>;
    mockToolRegistry = {
      getCompactRepresentation: jest.fn().mockReturnValue('mock representation'),
    } as unknown as jest.Mocked<ToolRegistry>;
    promptService = new PromptService(mockConversationService, mockToolRegistry);
  });
  

  it('should determine task tools', async () => {
    const mockResponse = {
      content: [{ text: JSON.stringify({
        existingTools: ['tool1'],
        newTools: ['newTool'],
        packages: ['package1'],
        useSingleTool: false,
        toolName: '',
        params: {}
      }) }]
    };
    mockConversationService.chat.mockResolvedValueOnce(mockResponse);
  
    const result = await promptService.determineTaskTools({
      task: 'test task',
      likelyTools: 'tool1, tool2',
      relevantMemories: 'memory1, memory2'
    });
  
    expect(mockConversationService.chat).toHaveBeenCalled();
    expect(result).toEqual({
      existingTools: ['tool1'],
      newTools: ['newTool'],
      packages: ['package1'],
      useSingleTool: false,
      toolName: '',
      params: {}
    });
  });

  it('should generate a tool', async () => {
    const mockResponse = {
      tool: 'newTool',
      description: 'A new tool',
      methodSignature: 'newTool(param: string): string',
      script: 'console.log("New tool");',
      packages: ['package1']
    };
    mockConversationService.chat.mockResolvedValue({ content: [{ text: JSON.stringify(mockResponse) }] });

    const result = await promptService.generateTool({
      toolName: 'newTool',
      description: 'A new tool',
      task: 'Create a new tool'
    });

    expect(result).toEqual(mockResponse);
  });

  it('should generate tasks', async () => {
    const mockResponse = [
      { task: 'task1', script: 'console.log("Task 1");', chat: 'Explanation 1' },
      { task: 'task2', script: 'console.log("Task 2");', chat: 'Explanation 2' }
    ];
    mockConversationService.chat.mockResolvedValue({ content: [{ text: JSON.stringify(mockResponse) }] });

    const result = await promptService.generateTasks({
      task: 'Main task',
      availableTools: ['tool1', 'tool2'],
      memories: 'memory1, memory2'
    });

    expect(result).toEqual(mockResponse);
  });

  it('should repair failed script execution', async () => {
    const mockResponse = {
      repaired: true,
      reason: 'Fixed syntax error',
      name: 'repairedScript',
      source: 'console.log("Repaired");'
    };
    mockConversationService.chat.mockResolvedValue({ content: [{ text: JSON.stringify(mockResponse) }] });

    const result = await promptService.repairFailedScriptExecution({
      error: new Error('Syntax error'),
      source: 'console.log("Broken")',
      availableTools: ['tool1', 'tool2'],
      memories: 'memory1, memory2'
    });

    expect(result).toEqual(mockResponse);
  });
  // Add more tests for generateTool, generateTasks, and repairFailedScriptExecution
});.//maintenance.ts
// maintenanceManager.ts
import { AgentService } from './agentService';
import { ToolRegistry } from './tools/toolRegistry';
import { MemoryService } from './memory/memoryService';

export class MaintenanceManager {
  constructor(
    private agentService: AgentService,
    private toolRegistry: ToolRegistry,
    private memoryService: MemoryService
  ) {}

  async performMaintenance(): Promise<void> {
    await this.reviewAutoGeneratedTools();
    await this.optimizeMemory();
    await this.agentService.performMaintenance();
  }

  private async reviewAutoGeneratedTools(): Promise<void> {
    await this.toolRegistry.reviewAutoGeneratedTools();
  }

  private async optimizeMemory(): Promise<void> {
    const memories = await this.memoryService.listMemories();
    const lowConfidenceMemories = memories.filter(memory => memory.confidence < 0.3);
    for (const memory of lowConfidenceMemories) {
      await this.memoryService.removeMemory(memory.input);
    }
  }
}.//logging/errorHandlingService.ts
// errorHandlingService.ts
import { loggingService } from './logger';

export class ErrorHandlingService {
  async withRetry<T>(operation: (repairedValues: any) => Promise<T>, maxRetries: number = 3, fixOperation: (error: any) => Promise<T>): Promise<T> {
    let lastError: Error | null = null;
    let repairedValues: any = {};
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation(repairedValues);
      } catch (error) {
        lastError = error;
        loggingService.error(`Attempt ${attempt} failed`, error, { attempt, maxRetries });
        if (attempt < maxRetries) {
          await this.delay(Math.pow(2, attempt) * 1000); // Exponential backoff
        }
        if (fixOperation) {
          repairedValues = await fixOperation(error);
        }
      }
    }
    throw lastError || new Error('Operation failed after max retries');
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}.//logging/logger.ts
// logger.ts
import winston from 'winston';
import chalk from 'chalk';
import { loggingConfig } from './config';

// Define custom log levels
const logLevels = {
  error: 0,
  warn: 1,
  info: 2,
  text: 2,
  debug: 3,
  verbose: 4,
};

// Create color scheme for log levels
const logColors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  text: 'green',
  debug: 'blue',
  verbose: 'cyan',
};

export class LoggingService {
  private logger: winston.Logger;

  constructor() {
    this.logger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      ),
      transports: [
        new winston.transports.Console(loggingConfig.console),
        new winston.transports.File(loggingConfig.file)
      ]
    });
  }

  log(level: string, message: string, meta?: any): void {
    this.logger.log(level, message, meta);
  }

  error(message: string, error: Error, meta?: any): void {
    this.logger.error(message, { error, ...meta });
  }

  warn(message: string, meta?: any): void {
    this.logger.warn(message, meta);
  }

  info(message: string, meta?: any): void {
    this.logger.info(message, meta);
  }

  debug(message: string, meta?: any): void {
    this.logger.debug(message, meta);
  }

  setLogLevel(level: string): void {
    this.logger.level = level;
    this.logger.info(`Log level changed to: ${level}`);
  }

  addTransport(transport: winston.transport): void {
    this.logger.add(transport);
  }

  removeTransport(transport: winston.transport): void {
    this.logger.remove(transport);
  }
}

export const loggingService = new LoggingService();

// Add this function to maintain compatibility
export function log(level: string, message: string, service?: string): void {
  loggingService.log(level, message, { service });
}.//logging/config.ts
// config.ts
import winston from 'winston';

export const loggingConfig = {
  console: {
    level: 'info',
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  },
  file: {
    level: 'debug',
    filename: 'app.log',
    format: winston.format.json()
  },
  ui: {
    level: 'info'
  }
};.//systemTools.ts
// systemTools.ts

import { UI } from './ui';
import ToolRegistry from './toolRegistry';
import { log, setLogLevel, toggleService } from './logger';
import chalk from "chalk";
import boxen from "boxen";

export const createSystemTools = (ui: UI, toolRegistry: ToolRegistry, sessionManager: any) => ({
  showHelp: {
    name: 'showHelp',
    description: 'Display help information about available commands',
    execute: () => {
      const helpText = `
Available commands:
- Show help: Ask for help or command list
- Toggle debug mode: Turn debug mode on or off
- Show history: Display command history
- Show session state: Display current session state
- Exit session: End the current session
- Create new session: Start a new session
- Switch session: Change to a different session
- Set log level: Change the logging level
- Enable/Disable logging: Turn logging on or off for a service
- Switch theme: Change the UI theme
- Clear screen: Clear the terminal display
- Manage tools: List, add, update, or get history of tools
      `;
      ui.updateOutput(boxen(helpText, { padding: 1 }));
    }
  },
  toggleDebug: {
    name: 'toggleDebug',
    description: 'Toggle debug mode on or off',
    execute: (session: any) => {
      session.debug = !session.debug;
      ui.updateOutput(`Debug mode is now ${session.debug ? 'on' : 'off'}`, 'info');
    }
  },
  showHistory: {
    name: 'showHistory',
    description: 'Display command history',
    execute: (session: any) => {
      if (session.history.length === 0) {
        ui.updateOutput('No commands in history.', 'info');
        return;
      }
      session.history.forEach((cmd: string, index: number) => {
        ui.updateOutput(`${index + 1}. ${cmd}`, 'info');
      });
    }
  },
  showState: {
    name: 'showState',
    description: 'Display current session state',
    execute: (session: any) => {
      const state = {
        id: session.id,
        debug: session.debug,
        historyLength: session.history.length
      };
      ui.updateOutput(boxen(JSON.stringify(state, null, 2), { padding: 1 }), 'info');
    }
  },
  exitSession: {
    name: 'exitSession',
    description: 'End the current session',
    execute: () => {
      sessionManager.exitSession();
    }
  },
  createNewSession: {
    name: 'createNewSession',
    description: 'Start a new session',
    execute: () => {
      sessionManager.createNewSession();
    }
  },
  switchSession: {
    name: 'switchSession',
    description: 'Change to a different session',
    execute: (index: number) => {
      sessionManager.switchToSession(index);
    }
  },
  setLogLevel: {
    name: 'setLogLevel',
    description: 'Change the logging level',
    execute: (level: string) => {
      setLogLevel(level);
      log('info', `Log level set to: ${level}`, 'SystemTools');
    }
  },
  toggleLogging: {
    name: 'toggleLogging',
    description: 'Turn logging on or off for a service',
    execute: (service: string, enable: boolean) => {
      toggleService(service, enable);
      log('info', `Logging ${enable ? 'enabled' : 'disabled'} for service: ${service}`, 'SystemTools');
    }
  },
  switchTheme: {
    name: 'switchTheme',
    description: 'Change the UI theme',
    execute: (themeName: string) => {
      ui.switchTheme(themeName);
    }
  },
  clearScreen: {
    name: 'clearScreen',
    description: 'Clear the terminal display',
    execute: () => {
      console.clear();
    }
  },
  listTools: {
    name: 'listTools',
    description: 'List all available tools',
    execute: async () => {
      const tools = await toolRegistry.getToolList();
      ui.updateOutput(chalk.bold("Available tools:"));
      tools.forEach((tool: any) => {
        ui.updateOutput(` ${chalk.cyan(tool.name)} (v${tool.version})`);
      });
    }
  },
  addTool: {
    name: 'addTool',
    description: 'Add a new tool',
    execute: async (name: string, source: string, schema: any, tags: string[]) => {
      try {
        const added = await toolRegistry.addTool(name, source, schema, tags);
        if (added) {
          ui.updateOutput(chalk.green(`Tool '${name}' added successfully.`), 'success');
        } else {
          ui.updateOutput(chalk.yellow(`Tool '${name}' already exists.`), 'warning');
        }
      } catch (error) {
        ui.updateOutput(chalk.red(`Error adding tool: ${error.message}`), 'error');
      }
    }
  },
  updateTool: {
    name: 'updateTool',
    description: 'Update an existing tool',
    execute: async (name: string, source: string) => {
      try {
        const tool = await toolRegistry.getTool(name);
        const updated = await toolRegistry.updateTool(name, source, tool.schema, tool.tags);
        if (updated) {
          ui.updateOutput(chalk.green(`Tool '${name}' updated successfully.`), 'success');
        } else {
          ui.updateOutput(chalk.yellow(`Tool '${name}' not found.`), 'warning');
        }
      } catch (error) {
        ui.updateOutput(chalk.red(`Error updating tool: ${error.message}`), 'error');
      }
    }
  },
  getToolHistory: {
    name: 'getToolHistory',
    description: 'Get the version history of a tool',
    execute: async (name: string) => {
      try {
        const history = await toolRegistry.getToolHistory(name);
        ui.updateOutput(`Version history for tool '${name}':`);
        history.forEach((version: any) => {
          ui.updateOutput(` v${version.version} - ${version.date}`);
        });
      } catch (error) {
        ui.updateOutput(`Error getting tool history: ${error.message}`, 'error');
      }
    }
  }
});.//conversation/__test__/conversation.test.ts
import Conversation from '../conversation';
import { AnthropicVertex } from '@anthropic-ai/vertex-sdk';
import { VertexAI } from '@google-cloud/vertexai';

jest.mock('@anthropic-ai/vertex-sdk');
jest.mock('@google-cloud/vertexai');


describe('Conversation', () => {
    let conversation: Conversation;

    beforeEach(() => {
        conversation = new Conversation('claude');
    });

    it('should create a Conversation instance', () => {
        expect(conversation).toBeInstanceOf(Conversation);
    });

    it('should throw an error for invalid model', () => {
        expect(() => new Conversation('invalid-model')).toThrow('Invalid model specified');
    });


    it('should chat with Claude', async () => {
        const mockCreate = jest.fn().mockResolvedValue({ content: [{ text: 'Claude response' }] });
        (AnthropicVertex as jest.Mock).mockImplementation(() => ({
            messages: {
                create: mockCreate
            }
        }));

        conversation = new Conversation('claude');
        const result = await conversation.chat([{ role: 'system', content: 'Hello' },{ role: 'user', content: 'Hello' }]);

        expect(result.content[0].text).toEqual('Claude response');
        expect(mockCreate).toHaveBeenCalled();
    });

    it('should chat with Gemini', async () => {
        const mockGenerateContent = jest.fn().mockResolvedValue({ response: { text: 'Gemini response' } });
        const mockModel = { generateContent: mockGenerateContent };
        const mockGetGenerativeModel = jest.fn().mockReturnValue(mockModel);
        
        (VertexAI as jest.Mock).mockImplementation(() => ({
            getGenerativeModel: mockGetGenerativeModel
        }));

        conversation = new Conversation('gemini');
        const result = await conversation.chat([{ role: 'user', content: 'Hello' }]);

        expect(result).toEqual({ text: 'Gemini response' });
        expect(mockGenerateContent).toHaveBeenCalled();
        expect(mockGetGenerativeModel).toHaveBeenCalledWith({ model: 'gemini-1.5-pro-001' });
    });
});
.//conversation/conversation.ts

// conversation.ts
import { AnthropicVertex } from '@anthropic-ai/vertex-sdk';
import { VertexAI } from '@google-cloud/vertexai';

export default class Conversation {
  model: string;
  projectId: string;
  location: string;
  client: any;
  vertexAI: any;
  constructor(model: any) {
    this.model = model.toLowerCase();

    if (this.model !== 'claude' && this.model !== 'gemini') {
      throw new Error("Invalid model specified. Choose either 'claude' or 'gemini'.");
    }

    // Vertex AI Configuration (adjust if needed)
    this.projectId = 'silent-blade-417120';
    this.location = this.model === 'claude' ? 'us-east5' : 'us-central1';

    if (this.model === 'claude') {
      this.client = new AnthropicVertex({
        region: this.location,
        projectId: this.projectId,
      });
    } else {
      this.vertexAI = new VertexAI({
        project: this.projectId,
        location: this.location
      });
    }
  }

  async chat(messages: any[], options = {
    max_tokens : 4000, 
    temperature : 0.618,
    responseFormat: ''
  }, model = 'gemini-1.5-pro-001') {
    const {}: any = options;
    if(!Array.isArray(messages)) {
      throw new Error('Messages must be an array of objects.');
    }

    if (this.model === 'claude') {
      return this.chatWithClaude(messages, options);
    } else {
      return this.chatWithGemini(messages, options, model);
    }
  }

  async chatWithClaude(messages: any[], options = {
    max_tokens : 4000, 
    temperature : 0.15,
    responseFormat : ''
  }) {
    let { max_tokens, temperature, responseFormat } = options;
    if(responseFormat !== '') {
      responseFormat = `\n\nRESPONSE FORMAT. *** YOU are REQUIRED to return the response in JSON formatted with the following format: ${responseFormat} Do NOT SURROUND with Codeblocks ***`
    }
    try {
      let system = "You are a helpful assistant.";
      if (messages[0].role === "system") {
        system = messages[0].content + (responseFormat ? responseFormat : '');
        messages.shift();
      }
      if(responseFormat !== '') {
        messages[messages.length - 1].content += responseFormat;
      }
      let result = await this.client.messages.create({
        messages: messages,
        model: 'claude-3-5-sonnet@20240620',
        system,
        max_tokens: max_tokens || 4000,
        temperature: temperature,
      });
      if(responseFormat !== '') {
        try {
        result = JSON.parse(result.content[0].text);
        } catch (error) {
          result = result.content[0].text;
        }
      }
      return result;
    } catch (error) {
      console.error(error);
      return error;
    }
  }

  async chatWithGemini(messages: any[], options: any, model: string = 'gemini-1.5-pro-001') {
    const { max_tokens, temperature } = options;
    const generativeModel = this.vertexAI.getGenerativeModel({
      model: model,
    });
    const prompt = messages.map(message => `${message.role}: ${message.content}`).join('\n');

    const resp = await generativeModel.generateContent(prompt, {
      temperature: temperature,
      maxOutputTokens: max_tokens,
    });

    const contentResponse = await resp.response;
    return contentResponse;
  }
}.//conversation/conversationService.ts
// conversationService.ts
import Conversation from './conversation';

export class ConversationService {
  public conversation: Conversation;

  constructor(model: string = 'claude') {
    this.conversation = new Conversation(model);
  }

  async chat(messages: any[], options: any = {}, model: string = 'gemini-1.5-pro-001'): Promise<any> {
    try {
      const response = await this.conversation.chat(messages, options, model);
      return response;
    } catch (error) {
      console.error('Error in conversation:', error);
      throw error;
    }
  }

  setModel(model: string): void {
    this.conversation = new Conversation(model);
  }
}