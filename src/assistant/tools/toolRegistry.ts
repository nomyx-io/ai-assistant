
// toolRegistry.ts
import { Tool } from './tool';
import { MetricsService, ToolMetrics } from '../metrics/metricsService';
import { ConversationService } from '../conversation/conversationService';
import { ScriptManager } from '../script/scriptManager';
import { ToolWatcher } from './toolWatcher';
import { ScriptMetadata } from '../script/metadataManager';
import { makePromptFunction } from '../prompts/promptService';
import * as tools from '../defaultTools';
import { StateObject } from '../state';
import { loggingService } from '../logging/logger';
import { ToolStorage } from './toolStorage';

const bash = {
  'name': 'bash',
  'version': '1.0.0',
  'description': 'Performs bash operations. Supported operations include execute.',
  'schema': {
    'name': 'bash',
    'description': 'Performs bash operations. Supported operations include execute.',
    "methodSignature": "bash({ operations: { operation: string, command: string }[...] }): Promise<string[]>",
  },
  execute: async function (operations, state, api) {
    if (!Array.isArray(operations)) operations = [operations];

    try {
      const results = await Promise.all(operations.map(({ command }) => {
        return new Promise((resolve, reject) => {
          const { exec } = require('shelljs');
          exec(command, { async: true, silent: true }, (code, stdout, stderr) => {
            if (code === 0) {
              resolve(stdout.trim());
            } else {
              resolve(new Error(`Command failed with exit code ${code}: ${stderr}`));
            }
          });
        });
      }));

      return results;
    } catch (error) {
      throw error;
    }
  },
};


export class ToolRegistry {
  private tools: Map<string, Tool> = new Map();
  private scriptManager: ScriptManager;
  public toolWatcher: ToolWatcher;
  private conversation: any;
  private toolStorage: ToolStorage;

  constructor(
    private metricsService: MetricsService,
    private conversationService: ConversationService
  ) {
    this.scriptManager = new ScriptManager(this);
    this.toolStorage = new ToolStorage();
    this.toolWatcher = new ToolWatcher(this);
    this.metricsService = new MetricsService();
    this.conversation = this.conversationService.conversation;
  }

  async initialize(): Promise<void> {
    await this.scriptManager.initialize();
    await this.toolWatcher.initialize();
    await this.loadToolsFromStorage();

    this.addTool('bash', bash.execute.toString(), bash.schema, ['auto-generated'], bash.execute);
    for(const [k,v] of Object.entries(tools.tools)) {
      const tool = v as any;
      this.addTool(tool.schema.name, tool.execute.toString(), tool.schema, [], tool.execute);
      console.log(`Tool added: ${tool.schema.name}`);
    }
  }

  private async loadToolsFromStorage(): Promise<void> {
    const storedTools = await this.toolStorage.loadAllTools();
    for (const tool of storedTools) {
      this.tools.set(tool.name, tool);
    }
    loggingService.info(`Loaded ${storedTools.length} tools from storage`);
  }
  
  async reviewAutoGeneratedTools(state: any): Promise<void> {
    const allTools = await this.getToolList();
    const autoGeneratedTools = allTools.filter(tool => tool.tags.includes('auto-generated'));
  
    for (const tool of autoGeneratedTools) {
      const reviewPrompt = `
        Review the following auto-generated tool and determine if it should be kept, modified, or removed:
  
        Name: ${tool.name}
        Description: ${tool.schema.description}
        Source:
        ${tool.source}
  
        Provide your recommendation in JSON format:
        {
          "action": "keep" | "modify" | "remove",
          "reason": "Brief explanation",
          "modifications": "If action is 'modify', provide the modified source code here"
        }
      `;
  
      const reviewResult = await this.conversationService.chat([
        { role: 'system', content: 'You are an AI assistant tasked with reviewing and maintaining the tool registry.' },
        { role: 'user', content: reviewPrompt }
      ], state);
  
      const { action, reason, modifications } = JSON.parse(reviewResult.content[0].text);
  
      switch (action) {
        case 'keep':
          console.log(`Tool '${tool.name}' kept. Reason: ${reason}`);
          break;
        case 'modify':
          await this.updateTool(tool.name, modifications, tool.schema, tool.tags);
          console.log(`Tool '${tool.name}' modified. Reason: ${reason}`);
          break;
        case 'remove':
          await this.removeTool(tool.name);
          console.log(`Tool '${tool.name}' removed. Reason: ${reason}`);
          break;
      }
    }
  }

  getKnownErrorPatterns(): any {
    return [];
  }

  modifyExecutionEnvironment(modification: any): void {
    console.log(`Modifying execution environment: ${modification}`);
  }

  // install an npm package in our environment
  async installPackage(packageName: string): Promise<void> {
    try {
      const { execSync } = require('child_process');
      execSync(`npm install ${packageName}`);
    } catch (error) {
      console.log(`Error installing package: ${packageName}`);
      console.log(error);
    }
  }

  async installPackages(packages: string[]): Promise<void> {
    const promises: any = [];
    for (const pkg of packages) {
      promises.push(this.installPackage(pkg));
    }
    await Promise.all(promises);
  }

  async createTools(tools: any) {
    const promises: any = [];
    for (const tool of tools) {
      promises.push(this.addTool(tool.name, tool.execute.toString(), tool.schema, tool.tags, tool.execute));
    }
    await Promise.all(promises);
  }

  async createTool(name: string, source: string, schema: any, tags: string[], _execute: any, metadata?: Partial<ScriptMetadata>): Promise<boolean> {
    return this.addTool(name, source, schema, tags, _execute, metadata);
  }

async callTool(name: string, params: any, state: StateObject): Promise<[any, StateObject]> {
  if (!this.tools.has(name)) {
    throw new Error(`Tool not found: ${name}`);
  }
  const tool = this.tools.get(name)!;
  const startTime = Date.now();
  try {
    const [result, updatedState] = await tool.execute(params, state, this);
    const executionTime = Date.now() - startTime;
    this.metricsService.recordToolUsage(name, executionTime, true);
    return [result, updatedState];
  } catch (error) {
    const executionTime = Date.now() - startTime;
    this.metricsService.recordToolUsage(name, executionTime, false);
    throw error;
  }
}

  

  async updateTool(name: string, source: string, schema: any, tags: string[], metadata?: Partial<ScriptMetadata>): Promise<boolean> {
  if (!this.tools.has(name)) {
    return false;
  }
  const tool = this.tools.get(name)!;
  tool.update(source, schema, tags, metadata || {});
  await this.toolStorage.saveTool(tool);
  this.metricsService.recordToolUpdate(name);
  return true;
}

async removeTool(name: string): Promise<boolean> {
  if (this.tools.has(name)) {
    this.tools.delete(name);
    await this.toolStorage.deleteTool(name);
    this.metricsService.recordToolRemoval(name);
    return true;
  }
  return false;
}

  async addTool(name: string, source: string, schema: any, tags: string[], _execute: any, metadata?: Partial<ScriptMetadata>): Promise<boolean> {
    if (this.tools.has(name)) {
      return false;
    }
    const defaultMetadata: ScriptMetadata = {
      originalQuery: '',
      creationDate: new Date(),
      lastModifiedDate: new Date(),
      author: 'System',
      version: '1.0.0',
      tags: tags,
      dependencies: [],
      description: schema.description || ''
    };
    const fullMetadata = { ...defaultMetadata, ...metadata };
    const tool = new Tool(name, source, schema, tags, fullMetadata, _execute);
  this.tools.set(name, tool);
  await this.toolStorage.saveTool(tool);
  this.metricsService.recordToolAddition(name);
  return true;
  }

  async modifyTool(name: string, modifications: any): Promise<boolean> {
    if (!this.tools.has(name)) {
      return false;
    }
    const tool = this.tools.get(name)!;
    const updatedSource = modifications.source || tool.source;
    const updatedSchema = modifications.schema || tool.schema;
    const updatedTags = modifications.tags || tool.tags;
    const updatedMetadata = modifications.metadata || tool.metadata;
    tool.update(updatedSource, updatedSchema, updatedTags, updatedMetadata);
    this.metricsService.recordToolUpdate(name);
    return true;
  }

getMetrics(toolName: string): ToolMetrics | undefined {
  return this.metricsService.getToolMetrics(toolName);
}

getAllMetrics(): Map<string, ToolMetrics> {
  return this.metricsService.getAllMetrics();
}

  getCompactRepresentation(): string {
    return Array.from(this.tools.keys())
      .map(name => `${name}: ${this.tools.get(name)!.schema.description}`)
      .join('\n');
  }

  listTools(): Tool[] {
    return Array.from(this.tools.values());
  }
  
  async getTool(name: string): Promise<Tool | undefined> {
    return this.tools.get(name);
  }

  async getToolList(): Promise<Tool[]> {
    return Array.from(this.tools.values());
  }

  async cleanupUnusedScripts(): Promise<void> {
    await this.scriptManager.cleanupUnusedScripts();
  }

  async addMetadata(scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    await this.scriptManager.addMetadata(scriptName, metadata);
  }

  async getMetadata(scriptName: string): Promise<ScriptMetadata | null> {
    return await this.scriptManager.getMetadata(scriptName);
  }

  async updateMetadata(scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    await this.scriptManager.updateMetadata(scriptName, metadata);
  }

  async removeMetadata(scriptName: string): Promise<void> {
    await this.scriptManager.removeMetadata(scriptName);
  }

  async predictLikelyTools(input: any): Promise<{ tool: string, justification: string }[]> {
    const toolNames = Array.from(this.tools.keys());
    const systemPrompt = 'You are tasked with selecting the most appropriate tools for accomplishing a given task.';
    const prompt = `Given the request: ${input.task}\nand tools: ${toolNames.join(', ')}\n${systemPrompt}\n
Which tools do you think would be most useful for accomplishing the task?
Provide your predictions as an array of tool names and your justification for each choice.`;
    const response = makePromptFunction(
      this.conversationService, 
      systemPrompt, 
      prompt, 
      { task: 'required' }, 
      '{ tool: string, justification: string }[]'
    )(input);
    return response;
  }

  async improveTools(): Promise<void> {
    for (const tool of this.tools.values()) {
      if (tool.needsImprovement()) {
        const improvedSource = await this.getImprovedToolSource(tool);
        await this.updateTool(tool.name, improvedSource, tool.schema, tool.tags);
      }
    }
  }

  async analyzeAndCreateToolFromScript(script: string, taskName: string, taskDescription: string): Promise<void> {
    const analysis = await this.analyzeScript(script, taskDescription);
    if (analysis.shouldCreateTool) {
      await this.addTool(taskName, analysis.source, analysis.schema, analysis.tags, new Function('params', analysis.source));
    }
  }

  private async getImprovedToolSource(tool: Tool): Promise<string> {
    return tool.source;
  }

  private async analyzeScript(script: string, taskDescription: string): Promise<any> {
    return {
      shouldCreateTool: true,
      name: 'new-tool',
      source: script,
      schema: {},
      tags: ['auto-generated']
    };
  }

  hasTool(name: string): boolean {
    return this.tools.has(name);
  }

  executeOperation(operation: any, context: any): any {
    return operation(context);
  }
}
