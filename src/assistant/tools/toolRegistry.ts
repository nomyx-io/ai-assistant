// toolRegistry.ts
import { Tool } from './tool';
import { MetricsService } from '../metrics/metricsService';
import { ConversationService } from '../conversation/conversationService';
import { ScriptManager } from '../script/scriptManager';
import { ToolWatcher } from './toolWatcher';
import { ScriptMetadata } from '../script/metadataManager';
import { makePromptFunction } from '../prompts/promptService';
import * as tools from '../defaultTools';
import { log } from '../logging/logger';

const bash = {
  'name': 'bash',
  'version': '1.0.0',
  'description': 'Performs bash operations. Supported operations include execute.',
  'schema': {
      'name': 'bash',
      'description': 'Performs bash operations. Supported operations include execute.',
      "methodSignature": "bash({ operations: { operation: string, command: string }[...] }): string",
  },
  execute: async function (operations, run) {
      const result: any = [];
      if(!Array.isArray(operations)) operations = [operations];
      try {
          const { execSync } = require('child_process');
          for (const { command } of operations) {
             result.push( execSync(command, { stdio: 'inherit' }));
          }
          return result.length > 1 ? result : result[0];
      }
      catch (error) {
          return error.message;
      }
  },
};

export class ToolRegistry {
  private tools: Map<string, Tool> = new Map();
  private scriptManager: ScriptManager;
  public toolWatcher: ToolWatcher;
  private conversation: any;
  constructor(
    private metricsService: MetricsService,
    private conversationService: ConversationService
  ) {
    this.scriptManager = new ScriptManager(this);
    this.initialize();
    this.toolWatcher = new ToolWatcher(this);
    this.conversation = this.conversationService.conversation;

    this.addTool('bash', bash.execute.toString(), bash.schema, ['auto-generated'], bash.execute);
    for(const [k,v] of Object.entries(tools.tools)) {
      const tool = v as any;
      this.addTool(tool.schema.name, tool.execute.toString(), tool.schema, [], tool.execute);
      console.log(`Tool added: ${tool.schema.name}`);
    }
  }

  async initialize(): Promise<void> {
    await this.scriptManager.initialize();
    await this.toolWatcher.initialize();

  }

  async reviewAutoGeneratedTools(): Promise<void> {
    const allTools = await this.getToolList();
    const autoGeneratedTools = allTools.filter(tool => tool.tags.includes('auto-generated'));
  
    for (const tool of autoGeneratedTools) {
      const reviewPrompt = `
        Review the following auto-generated tool and determine if it should be kept, modified, or removed:
  
        Name: ${tool.name}
        Description: ${tool.schema.description}
        Source:
        ${tool.source}
  
        Provide your recommendation in JSON format:
        {
          "action": "keep" | "modify" | "remove",
          "reason": "Brief explanation",
          "modifications": "If action is 'modify', provide the modified source code here"
        }
      `;
  
      const reviewResult = await this.conversationService.chat([
        { role: 'system', content: 'You are an AI assistant tasked with reviewing and maintaining the tool registry.' },
        { role: 'user', content: reviewPrompt }
      ]);
  
      const { action, reason, modifications } = JSON.parse(reviewResult.content[0].text);
  
      switch (action) {
        case 'keep':
          console.log(`Tool '${tool.name}' kept. Reason: ${reason}`);
          break;
        case 'modify':
          await this.updateTool(tool.name, modifications, tool.schema, tool.tags);
          console.log(`Tool '${tool.name}' modified. Reason: ${reason}`);
          break;
        case 'remove':
          await this.removeTool(tool.name);
          console.log(`Tool '${tool.name}' removed. Reason: ${reason}`);
          break;
      }
    }
  }

  // install an npm package in our environment
  async installPackage(packageName: string): Promise<void> {
    // simulate installation
    await new Promise(resolve => setTimeout(resolve, 2000));
    console.log(`Package installed: ${packageName}`);
  }

  async installPackages(packages: string[]): Promise<void> {
    const promises: any = [];
    for (const pkg of packages) {
      promises.push(this.installPackage(pkg));
    }
    await Promise.all(promises);
  }

  async createTools(tools: any) {
    const promises: any = [];
    for (const tool of tools) {
      promises.push(this.addTool(tool.name, tool.execute.toString(), tool.schema, tool.tags, tool.execute));
    }
    await Promise.all(promises);
  }

  async callTool(name: string, params: any): Promise<any> {
    if (!this. tools.has(name)) {
      throw new Error(`Tool not found: ${name}`);
    }
    const tool = this.tools.get(name)!;
    const startTime = Date.now();
    try {
      const result = await tool.execute(params, this);
      const executionTime = Date.now() - startTime;
      this.metricsService.recordToolUsage(name, executionTime, true);
      return result;
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.metricsService.recordToolUsage(name, executionTime, false);
      throw error;
    }
  }

  async addTool(name: string, source: string, schema: any, tags: string[], _execute: any, metadata?: Partial<ScriptMetadata>): Promise<boolean> {
    if (this.tools.has(name)) {
      return false;
    }
    const defaultMetadata: ScriptMetadata = {
      originalQuery: '',
      creationDate: new Date(),
      lastModifiedDate: new Date(),
      author: 'System',
      version: '1.0.0',
      tags: tags,
      dependencies: [],
      description: schema.description || ''
    };
    const fullMetadata = { ...defaultMetadata, ...metadata };
    const tool = new Tool(name, source, schema, tags, fullMetadata, _execute);
    this.tools.set(name, tool);
    this.metricsService.recordToolAddition(name);
    return true;
  }

  async updateTool(name: string, source: string, schema: any, tags: string[], metadata?: Partial<ScriptMetadata>): Promise<boolean> {
    if (!this.tools.has(name)) {
      return false;
    }
    const tool = this.tools.get(name)!;
    tool.update(source, schema, tags, metadata || {});
    this.metricsService.recordToolUpdate(name);
    return true;
  }

  async removeTool(name: string): Promise<boolean> {
    if (this.tools.has(name)) {
      this.tools.delete(name);
      this.metricsService.recordToolRemoval(name);
      return true;
    }
    return false;
  }

  getMetrics(toolName: string): any {
    return this.metricsService.getToolMetrics(toolName);
  }

  getAllMetrics(): Map<string, any> {
    return this.metricsService.getAllMetrics();
  }

  getCompactRepresentation(): string {
    return Array.from(this.tools.keys())
      .map(name => `${name}: ${this.tools.get(name)!.schema.description}`)
      .join('\n');
  }

  async getTool(name: string): Promise<Tool | undefined> {
    return this.tools.get(name);
  }

  async getToolList(): Promise<Tool[]> {
    return Array.from(this.tools.values());
  }

  async cleanupUnusedScripts(): Promise<void> {
    await this.scriptManager.cleanupUnusedScripts();
  }

  async addMetadata(scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    await this.scriptManager.addMetadata(scriptName, metadata);
  }

  async getMetadata(scriptName: string): Promise<ScriptMetadata | null> {
    return await this.scriptManager.getMetadata(scriptName);
  }

  async updateMetadata(scriptName: string, metadata: Partial<ScriptMetadata>): Promise<void> {
    await this.scriptManager.updateMetadata(scriptName, metadata);
  }

  async removeMetadata(scriptName: string): Promise<void> {
    await this.scriptManager.removeMetadata(scriptName);
  }

  async predictLikelyTools(input: any): Promise<{ tool: string, justification: string }[]> {
    const toolNames = Array.from(this.tools.keys());
    const systemPrompt = 'You are tasked with selecting the most appropriate tools for accomplishing a given task.';
    const prompt = `Given the request: ${input.task}\nand tools: ${toolNames.join(', ')}\n${systemPrompt}\n
Which tools do you think would be most useful for accomplishing the task?
Provide your predictions as an array of tool names and your justification for each choice.`;
    const response = makePromptFunction(
      this.conversationService, 
      systemPrompt, 
      prompt, 
      { task: 'required' }, 
      '{ tool: string, justification: string }[]'
    )(input);
    return response;
  }

  async improveTools(): Promise<void> {
    for (const tool of this.tools.values()) {
      if (tool.needsImprovement()) {
        const improvedSource = await this.getImprovedToolSource(tool);
        await this.updateTool(tool.name, improvedSource, tool.schema, tool.tags);
      }
    }
  }

  async analyzeAndCreateToolFromScript(script: string, taskName: string, taskDescription: string): Promise<void> {
    const analysis = await this.analyzeScript(script, taskDescription);
    if (analysis.shouldCreateTool) {
      await this.addTool(taskName, analysis.source, analysis.schema, analysis.tags, new Function('params', analysis.source));
    }
  }

  private async getImprovedToolSource(tool: Tool): Promise<string> {
    return tool.source;
  }

  private async analyzeScript(script: string, taskDescription: string): Promise<any> {
    return {
      shouldCreateTool: true,
      name: 'new-tool',
      source: script,
      schema: {},
      tags: ['auto-generated']
    };
  }

  hasTool(name: string): boolean {
    return this.tools.has(name);
  }

}